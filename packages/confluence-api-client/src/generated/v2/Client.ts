// @ts-nocheck
/* eslint-disable */
/**
 * Auto-generated by @tim-smart/openapi-gen
 * DO NOT EDIT - changes will be overwritten
 */
import type * as HttpClient from "@effect/platform/HttpClient"
import * as HttpClientError from "@effect/platform/HttpClientError"
import * as HttpClientRequest from "@effect/platform/HttpClientRequest"
import * as HttpClientResponse from "@effect/platform/HttpClientResponse"
import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { ParseError } from "effect/ParseResult"
import * as S from "effect/Schema"

export class AdminKeyResponse extends S.Class<AdminKeyResponse>("AdminKeyResponse")({
  /**
* User identifier.
*/
"accountId": S.optionalWith(S.String, { nullable: true }),
  /**
* Timestamp in UTC that represents when the admin key will expire. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"expirationTime": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* The sort fields for attachments. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
*/
export class AttachmentSortOrder extends S.Literal("created-date", "-created-date", "modified-date", "-modified-date") {}

export class GetAttachmentsParams extends S.Struct({
  "sort": S.optionalWith(AttachmentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "trashed")), { nullable: true }),
  "mediaType": S.optionalWith(S.String, { nullable: true }),
  "filename": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 50 as const })
}) {}

/**
* The status of the content.
*/
export class ContentStatus extends S.Literal("current", "draft", "archived", "historical", "trashed", "deleted", "any") {}

export class Version extends S.Class<Version>("Version")({
  /**
* Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Message associated with the current version.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* The version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
*/
"minorEdit": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The account ID of the user who created this version.
*/
"authorId": S.optionalWith(S.String, { nullable: true })
}) {}

export class AttachmentLinks extends S.Class<AttachmentLinks>("AttachmentLinks")({
  /**
* Web UI link of the content.
*/
"webui": S.optionalWith(S.String, { nullable: true }),
  /**
* Download link of the content.
*/
"download": S.optionalWith(S.String, { nullable: true })
}) {}

export class AttachmentBulk extends S.Class<AttachmentBulk>("AttachmentBulk")({
  /**
* ID of the attachment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the attachment was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the containing page.
* 
* Note: This is only returned if the attachment has a container that is a page.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the containing blog post.
* 
* Note: This is only returned if the attachment has a container that is a blog post.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the containing custom content.
* 
* Note: This is only returned if the attachment has a container that is custom content.
*/
"customContentId": S.optionalWith(S.String, { nullable: true }),
  /**
* Media Type for the attachment.
*/
"mediaType": S.optionalWith(S.String, { nullable: true }),
  /**
* Media Type description for the attachment.
*/
"mediaTypeDescription": S.optionalWith(S.String, { nullable: true }),
  /**
* Comment for the attachment.
*/
"comment": S.optionalWith(S.String, { nullable: true }),
  /**
* File ID of the attachment. This is the ID referenced in `atlas_doc_format` bodies and is distinct from the attachment ID.
*/
"fileId": S.optionalWith(S.String, { nullable: true }),
  /**
* File size of the attachment.
*/
"fileSize": S.optionalWith(S.Int, { nullable: true }),
  /**
* WebUI link of the attachment.
*/
"webuiLink": S.optionalWith(S.String, { nullable: true }),
  /**
* Download link of the attachment.
*/
"downloadLink": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "_links": S.optionalWith(AttachmentLinks, { nullable: true })
}) {}

export class MultiEntityLinks extends S.Class<MultiEntityLinks>("MultiEntityLinks")({
  /**
* Used for pagination. Contains the relative URL for the next set of results, using a cursor query parameter.
* This property will not be present if there is no additional data available.
*/
"next": S.optionalWith(S.String, { nullable: true }),
  /**
* Base url of the Confluence site.
*/
"base": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetAttachments200 extends S.Struct({
  "results": S.optionalWith(S.Array(AttachmentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetAttachmentByIdParams extends S.Struct({
  "version": S.optionalWith(S.Int, { nullable: true }),
  "include-labels": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-versions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-version": S.optionalWith(S.Boolean, { nullable: true, default: () => true as const }),
  "include-collaborators": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class Label extends S.Class<Label>("Label")({
  /**
* ID of the label.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Name of the label.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Prefix of the label.
*/
"prefix": S.optionalWith(S.String, { nullable: true })
}) {}

export class OptionalFieldMeta extends S.Class<OptionalFieldMeta>("OptionalFieldMeta")({
  /**
* Indicates if there are more available results that can be fetched.
*/
"hasMore": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* A token that can be used in the query parameter of the endpoint returned in the `_links` property to retrieve the next set of results.
*/
"cursor": S.optionalWith(S.String, { nullable: true })
}) {}

export class OptionalFieldLinks extends S.Class<OptionalFieldLinks>("OptionalFieldLinks")({
  /**
* A relative URL that can be used to fetch results beyond what this include parameter retrieves.
*/
"self": S.optionalWith(S.String, { nullable: true })
}) {}

export class ContentProperty extends S.Class<ContentProperty>("ContentProperty")({
  /**
* ID of the property
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Key of the property
*/
"key": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true })
}) {}

export class Operation extends S.Class<Operation>("Operation")({
  /**
* The type of operation.
*/
"operation": S.optionalWith(S.String, { nullable: true }),
  /**
* The type of entity the operation type targets.
*/
"targetType": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetAttachmentById200 extends S.Struct({}) {}

export class DeleteAttachmentParams extends S.Struct({
  "purge": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetAttachmentLabelsParamsPrefix extends S.Literal("my", "team", "global", "system") {}

export class GetAttachmentLabelsParams extends S.Struct({
  "prefix": S.optionalWith(GetAttachmentLabelsParamsPrefix, { nullable: true }),
  "sort": S.optionalWith(S.String, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetAttachmentLabels200 extends S.Struct({
  "results": S.optionalWith(S.Array(Label), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

/**
* The list of operations permitted on entity.
*/
export class PermittedOperationsResponse extends S.Class<PermittedOperationsResponse>("PermittedOperationsResponse")({
  "operations": S.optionalWith(S.Array(Operation), { nullable: true })
}) {}

/**
* The sort fields for content properties. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
*/
export class ContentPropertySortOrder extends S.Literal("key", "-key") {}

export class GetAttachmentContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetAttachmentContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class ContentPropertyCreateRequest extends S.Class<ContentPropertyCreateRequest>("ContentPropertyCreateRequest")({
  /**
* Key of the content property
*/
"key": S.optionalWith(S.String, { nullable: true })
}) {}

export class ContentPropertyUpdateRequest extends S.Class<ContentPropertyUpdateRequest>("ContentPropertyUpdateRequest")({
  /**
* Key of the content property
*/
"key": S.optionalWith(S.String, { nullable: true }),
  /**
* New version number and associated message
*/
"version": S.optionalWith(S.Struct({
  /**
* Version number of the new version. Should be 1 more than the current version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Message to be associated with the new version.
*/
"message": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}) {}

/**
* The sort fields for versions. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
*/
export class VersionSortOrder extends S.Literal("modified-date", "-modified-date") {}

export class GetAttachmentVersionsParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(VersionSortOrder, { nullable: true })
}) {}

export class BodyType extends S.Class<BodyType>("BodyType")({
  /**
* Type of content representation used for the value field.
*/
"representation": S.optionalWith(S.String, { nullable: true }),
  /**
* Body of the content, in the format found in the representation field.
*/
"value": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* Contains fields for each representation type requested.
*/
export class BodyBulk extends S.Class<BodyBulk>("BodyBulk")({
  "storage": S.optionalWith(BodyType, { nullable: true }),
  "atlas_doc_format": S.optionalWith(BodyType, { nullable: true })
}) {}

export class VersionedEntity extends S.Class<VersionedEntity>("VersionedEntity")({
  /**
* Title of the entity.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the entity.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true })
}) {}

export class AttachmentVersion extends S.Class<AttachmentVersion>("AttachmentVersion")({
  /**
* Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Message associated with the current version.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* The version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
*/
"minorEdit": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The account ID of the user who created this version.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  "attachment": S.optionalWith(VersionedEntity, { nullable: true })
}) {}

export class GetAttachmentVersions200 extends S.Struct({
  "results": S.optionalWith(S.Array(AttachmentVersion), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class DetailedVersion extends S.Class<DetailedVersion>("DetailedVersion")({
  /**
* The current version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* The account ID of the user who created this version.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  /**
* Message associated with the current version.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
*/
"minorEdit": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Describes if the content type is modified in this version (e.g. page to blog)
*/
"contentTypeModified": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The account IDs of users that collaborated on this version.
*/
"collaborators": S.optionalWith(S.Array(S.String), { nullable: true }),
  /**
* The version number of the version prior to this current content update.
*/
"prevVersion": S.optionalWith(S.Int, { nullable: true }),
  /**
* The version number of the version after this current content update.
*/
"nextVersion": S.optionalWith(S.Int, { nullable: true })
}) {}

/**
* The primary formats a body can be represented as. A subset of BodyRepresentation. These formats are the only allowed formats in certain use cases.
*/
export class PrimaryBodyRepresentation extends S.Literal("storage", "atlas_doc_format") {}

/**
* The sort fields for comments. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
*/
export class CommentSortOrder extends S.Literal("created-date", "-created-date", "modified-date", "-modified-date") {}

export class GetAttachmentCommentsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "version": S.optionalWith(S.Int, { nullable: true })
}) {}

/**
* Contains fields for each representation type requested.
*/
export class BodySingle extends S.Class<BodySingle>("BodySingle")({
  "storage": S.optionalWith(BodyType, { nullable: true }),
  "atlas_doc_format": S.optionalWith(BodyType, { nullable: true }),
  "view": S.optionalWith(BodyType, { nullable: true })
}) {}

export class CommentLinks extends S.Class<CommentLinks>("CommentLinks")({
  /**
* Web UI link of the content.
*/
"webui": S.optionalWith(S.String, { nullable: true })
}) {}

export class AttachmentCommentModel extends S.Class<AttachmentCommentModel>("AttachmentCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the attachment containing the comment.
*/
"attachmentId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodySingle, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetAttachmentComments200 extends S.Struct({
  "results": S.optionalWith(S.Array(AttachmentCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

/**
* The sort fields for blog posts. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
*/
export class BlogPostSortOrder extends S.Literal("id", "-id", "created-date", "-created-date", "modified-date", "-modified-date") {}

export class GetBlogPostsParams extends S.Struct({
  "id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "space-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(100)), { nullable: true }),
  "sort": S.optionalWith(BlogPostSortOrder, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "deleted", "trashed")), { nullable: true }),
  "title": S.optionalWith(S.String, { nullable: true }),
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

/**
* The status of the content.
*/
export class BlogPostContentStatus extends S.Literal("current", "draft", "historical", "trashed", "deleted", "any") {}

export class AbstractPageLinks extends S.Class<AbstractPageLinks>("AbstractPageLinks")({
  /**
* Web UI link of the content.
*/
"webui": S.optionalWith(S.String, { nullable: true }),
  /**
* Edit UI link of the content.
*/
"editui": S.optionalWith(S.String, { nullable: true }),
  /**
* Web UI link of the content.
*/
"tinyui": S.optionalWith(S.String, { nullable: true })
}) {}

export class BlogPostBulk extends S.Class<BlogPostBulk>("BlogPostBulk")({
  /**
* ID of the blog post.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(BlogPostContentStatus, { nullable: true }),
  /**
* Title of the blog post.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the space the blog post is in.
*/
"spaceId": S.optionalWith(S.String, { nullable: true }),
  /**
* The account ID of the user who created this blog post originally.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true }),
  "_links": S.optionalWith(AbstractPageLinks, { nullable: true })
}) {}

export class GetBlogPosts200 extends S.Struct({
  "results": S.optionalWith(S.Array(BlogPostBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class CreateBlogPostParams extends S.Struct({
  "private": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class Like extends S.Class<Like>("Like")({
  /**
* Account ID.
*/
"accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class CreateBlogPost200 extends S.Struct({}) {}

/**
* The primary formats a body can be represented as. A subset of BodyRepresentation. These formats are the only allowed formats in certain use cases.
*/
export class PrimaryBodyRepresentationSingle extends S.Literal("storage", "atlas_doc_format", "view", "export_view", "anonymous_export_view", "styled_view", "editor") {}

export class GetBlogPostByIdParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentationSingle, { nullable: true }),
  "get-draft": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "status": S.optionalWith(S.Array(S.Literal("current", "trashed", "deleted", "historical", "draft")), { nullable: true }),
  "version": S.optionalWith(S.Int, { nullable: true }),
  "include-labels": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-likes": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-versions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-version": S.optionalWith(S.Boolean, { nullable: true, default: () => true as const }),
  "include-favorited-by-current-user-status": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-webresources": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-collaborators": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetBlogPostById200 extends S.Struct({}) {}

export class UpdateBlogPost200 extends S.Struct({}) {}

export class DeleteBlogPostParams extends S.Struct({
  "purge": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "draft": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetBlogpostAttachmentsParams extends S.Struct({
  "sort": S.optionalWith(AttachmentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "trashed")), { nullable: true }),
  "mediaType": S.optionalWith(S.String, { nullable: true }),
  "filename": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 50 as const })
}) {}

export class GetBlogpostAttachments200 extends S.Struct({
  "results": S.optionalWith(S.Array(AttachmentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

/**
* The sort fields for custom content. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
*/
export class CustomContentSortOrder extends S.Literal("id", "-id", "created-date", "-created-date", "modified-date", "-modified-date", "title", "-title") {}

/**
* The formats a custom content body can be represented as. A subset of BodyRepresentation.
*/
export class CustomContentBodyRepresentation extends S.Literal("raw", "storage", "atlas_doc_format") {}

export class GetCustomContentByTypeInBlogPostParams extends S.Struct({
  "type": S.String,
  "sort": S.optionalWith(CustomContentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "body-format": S.optionalWith(CustomContentBodyRepresentation, { nullable: true })
}) {}

/**
* Contains fields for each representation type requested.
*/
export class CustomContentBodyBulk extends S.Class<CustomContentBodyBulk>("CustomContentBodyBulk")({
  "raw": S.optionalWith(BodyType, { nullable: true }),
  "storage": S.optionalWith(BodyType, { nullable: true }),
  "atlas_doc_format": S.optionalWith(BodyType, { nullable: true })
}) {}

export class CustomContentLinks extends S.Class<CustomContentLinks>("CustomContentLinks")({
  /**
* Web UI link of the content.
*/
"webui": S.optionalWith(S.String, { nullable: true })
}) {}

export class CustomContentBulk extends S.Class<CustomContentBulk>("CustomContentBulk")({
  /**
* ID of the custom content.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* The type of custom content.
*/
"type": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the custom content.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the space the custom content is in.
* 
* Note: This is always returned, regardless of if the custom content has a container that is a space.
*/
"spaceId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the containing page.
* 
* Note: This is only returned if the custom content has a container that is a page.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the containing blog post.
* 
* Note: This is only returned if the custom content has a container that is a blog post.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the containing custom content.
* 
* Note: This is only returned if the custom content has a container that is custom content.
*/
"customContentId": S.optionalWith(S.String, { nullable: true }),
  /**
* The account ID of the user who created this custom content originally.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(CustomContentBodyBulk, { nullable: true }),
  "_links": S.optionalWith(CustomContentLinks, { nullable: true })
}) {}

export class GetCustomContentByTypeInBlogPost200 extends S.Struct({
  "results": S.optionalWith(S.Array(CustomContentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetBlogPostLabelsParamsPrefix extends S.Literal("my", "team", "global", "system") {}

export class GetBlogPostLabelsParams extends S.Struct({
  "prefix": S.optionalWith(GetBlogPostLabelsParamsPrefix, { nullable: true }),
  "sort": S.optionalWith(S.String, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetBlogPostLabels200 extends S.Struct({
  "results": S.optionalWith(S.Array(Label), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetBlogPostLikeCount200 extends S.Struct({
  /**
* The count number
*/
"count": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetBlogPostLikeUsersParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetBlogPostLikeUsers200 extends S.Struct({
  "results": S.optionalWith(S.Array(Like), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetBlogpostContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetBlogpostContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetBlogPostVersionsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(VersionSortOrder, { nullable: true })
}) {}

export class BlogPostVersion extends S.Class<BlogPostVersion>("BlogPostVersion")({
  /**
* Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Message associated with the current version.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* The version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
*/
"minorEdit": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The account ID of the user who created this version.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  "blogpost": S.optionalWith(VersionedEntity, { nullable: true })
}) {}

export class GetBlogPostVersions200 extends S.Struct({
  "results": S.optionalWith(S.Array(BlogPostVersion), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class ContentIdToContentTypeResponse extends S.Class<ContentIdToContentTypeResponse>("ContentIdToContentTypeResponse")({
  /**
* JSON object containing all requested content ids as keys and their associated content types as the values.
* Duplicate content ids in the request will be returned under a single key in the response. For built-in content
* types, the enumerations are as specified. Custom content ids will be mapped to their associated type.
*/
"results": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}) {}

export class GetCustomContentByTypeParams extends S.Struct({
  "type": S.String,
  "id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "space-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(100)), { nullable: true }),
  "sort": S.optionalWith(CustomContentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "body-format": S.optionalWith(CustomContentBodyRepresentation, { nullable: true })
}) {}

export class GetCustomContentByType200 extends S.Struct({
  "results": S.optionalWith(S.Array(CustomContentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

/**
* Contains fields for each representation type requested.
*/
export class CustomContentBodySingle extends S.Class<CustomContentBodySingle>("CustomContentBodySingle")({
  "raw": S.optionalWith(BodyType, { nullable: true }),
  "storage": S.optionalWith(BodyType, { nullable: true }),
  "atlas_doc_format": S.optionalWith(BodyType, { nullable: true }),
  "view": S.optionalWith(BodyType, { nullable: true })
}) {}

export class CreateCustomContent201 extends S.Struct({}) {}

/**
* The formats a custom content body can be represented as. A subset of BodyRepresentation.
*/
export class CustomContentBodyRepresentationSingle extends S.Literal("raw", "storage", "atlas_doc_format", "view", "export_view", "anonymous_export_view") {}

export class GetCustomContentByIdParams extends S.Struct({
  "body-format": S.optionalWith(CustomContentBodyRepresentationSingle, { nullable: true }),
  "version": S.optionalWith(S.Int, { nullable: true }),
  "include-labels": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-versions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-version": S.optionalWith(S.Boolean, { nullable: true, default: () => true as const }),
  "include-collaborators": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetCustomContentById200 extends S.Struct({}) {}

export class UpdateCustomContent200 extends S.Struct({}) {}

export class DeleteCustomContentParams extends S.Struct({
  "purge": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetCustomContentAttachmentsParams extends S.Struct({
  "sort": S.optionalWith(AttachmentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "trashed")), { nullable: true }),
  "mediaType": S.optionalWith(S.String, { nullable: true }),
  "filename": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 50 as const })
}) {}

export class GetCustomContentAttachments200 extends S.Struct({
  "results": S.optionalWith(S.Array(AttachmentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetCustomContentCommentsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true })
}) {}

export class CustomContentCommentModel extends S.Class<CustomContentCommentModel>("CustomContentCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the custom content containing the comment.
*/
"customContentId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodySingle, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetCustomContentComments200 extends S.Struct({
  "results": S.optionalWith(S.Array(CustomContentCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetCustomContentLabelsParamsPrefix extends S.Literal("my", "team", "global", "system") {}

export class GetCustomContentLabelsParams extends S.Struct({
  "prefix": S.optionalWith(GetCustomContentLabelsParamsPrefix, { nullable: true }),
  "sort": S.optionalWith(S.String, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetCustomContentLabels200 extends S.Struct({
  "results": S.optionalWith(S.Array(Label), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetCustomContentContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetCustomContentContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetLabelsParams extends S.Struct({
  "label-id": S.optionalWith(S.Array(S.Int), { nullable: true }),
  "prefix": S.optionalWith(S.Array(S.String), { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetLabels200 extends S.Struct({
  "results": S.optionalWith(S.Array(Label), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetLabelAttachmentsParams extends S.Struct({
  "sort": S.optionalWith(AttachmentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetLabelAttachments200 extends S.Struct({
  "results": S.optionalWith(S.Array(AttachmentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetLabelBlogPostsParams extends S.Struct({
  "space-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(100)), { nullable: true }),
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "sort": S.optionalWith(BlogPostSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetLabelBlogPosts200 extends S.Struct({
  "results": S.optionalWith(S.Array(BlogPostBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

/**
* The sort fields for pages. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
*/
export class PageSortOrder extends S.Literal("id", "-id", "created-date", "-created-date", "modified-date", "-modified-date", "title", "-title") {}

export class GetLabelPagesParams extends S.Struct({
  "space-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(100)), { nullable: true }),
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "sort": S.optionalWith(PageSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

/**
* Content type of the parent, or null if there is no parent.
*/
export class ParentContentType extends S.Literal("page", "whiteboard", "database", "embed", "folder") {}

export class PageBulk extends S.Class<PageBulk>("PageBulk")({
  /**
* ID of the page.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the page.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the space the page is in.
*/
"spaceId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the parent page, or null if there is no parent page.
*/
"parentId": S.optionalWith(S.String, { nullable: true }),
  "parentType": S.optionalWith(ParentContentType, { nullable: true }),
  /**
* Position of child page within the given parent page tree.
*/
"position": S.optionalWith(S.Int, { nullable: true }),
  /**
* The account ID of the user who created this page originally.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  /**
* The account ID of the user who owns this page.
*/
"ownerId": S.optionalWith(S.String, { nullable: true }),
  /**
* The account ID of the user who owned this page previously, or null if there is no previous owner.
*/
"lastOwnerId": S.optionalWith(S.String, { nullable: true }),
  /**
* The subtype of the page.
*/
"subtype": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true }),
  "_links": S.optionalWith(AbstractPageLinks, { nullable: true })
}) {}

export class GetLabelPages200 extends S.Struct({
  "results": S.optionalWith(S.Array(PageBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPagesParamsSubtype extends S.Literal("live", "page") {}

export class GetPagesParams extends S.Struct({
  "id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "space-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(100)), { nullable: true }),
  "sort": S.optionalWith(PageSortOrder, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "deleted", "trashed")), { nullable: true }),
  "title": S.optionalWith(S.String, { nullable: true }),
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "subtype": S.optionalWith(GetPagesParamsSubtype, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetPages200 extends S.Struct({
  "results": S.optionalWith(S.Array(PageBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class CreatePageParams extends S.Struct({
  "embedded": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "private": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "root-level": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class CreatePage200 extends S.Struct({}) {}

export class GetPageByIdParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentationSingle, { nullable: true }),
  "get-draft": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "trashed", "deleted", "historical", "draft")), { nullable: true }),
  "version": S.optionalWith(S.Int, { nullable: true }),
  "include-labels": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-likes": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-versions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-version": S.optionalWith(S.Boolean, { nullable: true, default: () => true as const }),
  "include-favorited-by-current-user-status": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-webresources": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-collaborators": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-direct-children": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetPageById200 extends S.Struct({}) {}

export class UpdatePage200 extends S.Struct({}) {}

export class DeletePageParams extends S.Struct({
  "purge": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "draft": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetPageAttachmentsParams extends S.Struct({
  "sort": S.optionalWith(AttachmentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "trashed")), { nullable: true }),
  "mediaType": S.optionalWith(S.String, { nullable: true }),
  "filename": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 50 as const })
}) {}

export class GetPageAttachments200 extends S.Struct({
  "results": S.optionalWith(S.Array(AttachmentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetCustomContentByTypeInPageParams extends S.Struct({
  "type": S.String,
  "sort": S.optionalWith(CustomContentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "body-format": S.optionalWith(CustomContentBodyRepresentation, { nullable: true })
}) {}

export class GetCustomContentByTypeInPage200 extends S.Struct({
  "results": S.optionalWith(S.Array(CustomContentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPageLabelsParamsPrefix extends S.Literal("my", "team", "global", "system") {}

export class GetPageLabelsParams extends S.Struct({
  "prefix": S.optionalWith(GetPageLabelsParamsPrefix, { nullable: true }),
  "sort": S.optionalWith(S.String, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetPageLabels200 extends S.Struct({
  "results": S.optionalWith(S.Array(Label), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPageLikeCount200 extends S.Struct({
  /**
* The count number
*/
"count": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetPageLikeUsersParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetPageLikeUsers200 extends S.Struct({
  "results": S.optionalWith(S.Array(Like), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPageContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetPageContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class RedactionPointerResponse extends S.Class<RedactionPointerResponse>("RedactionPointerResponse")({
  /**
* JSON pointer indicating where the redaction was applied
*/
"pointer": S.optionalWith(S.String, { nullable: true }),
  /**
* Starting character index where redaction was applied
*/
"from": S.optionalWith(S.Int, { nullable: true }),
  /**
* Ending character index where redaction was applied
*/
"to": S.optionalWith(S.Int, { nullable: true }),
  /**
* Reason for the redaction
*/
"reason": S.optionalWith(S.String, { nullable: true }),
  /**
* Unique identifier for this redaction. Can be used to restore the redacted content later.
*/
"redactionId": S.optionalWith(S.String, { nullable: true })
}) {}

export class RedactionSectionResponse extends S.Class<RedactionSectionResponse>("RedactionSectionResponse")({
  /**
* List of redactions that were applied to this section
*/
"redactions": S.optionalWith(S.Array(RedactionPointerResponse), { nullable: true })
}) {}

/**
* Response containing details of all redactions that were applied to the content.
* Each redaction includes a unique ID for restoration, except that code block redactions cannot be restored.
*/
export class RedactionResponse extends S.Class<RedactionResponse>("RedactionResponse")({
  "body": S.optionalWith(RedactionSectionResponse, { nullable: true }),
  "title": S.optionalWith(RedactionSectionResponse, { nullable: true })
}) {}

export class UpdatePageTitle200 extends S.Struct({}) {}

export class GetPageVersionsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(VersionSortOrder, { nullable: true })
}) {}

export class PageVersion extends S.Class<PageVersion>("PageVersion")({
  /**
* Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Message associated with the current version.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* The version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
*/
"minorEdit": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The account ID of the user who created this version.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  "page": S.optionalWith(VersionedEntity, { nullable: true })
}) {}

export class GetPageVersions200 extends S.Struct({
  "results": S.optionalWith(S.Array(PageVersion), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class CreateWhiteboardParams extends S.Struct({
  "private": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class WhiteboardLinks extends S.Class<WhiteboardLinks>("WhiteboardLinks")({
  /**
* Web UI link of the content.
*/
"webui": S.optionalWith(S.String, { nullable: true }),
  /**
* Edit UI link of the content.
*/
"editui": S.optionalWith(S.String, { nullable: true })
}) {}

export class CreateWhiteboard200 extends S.Struct({}) {}

export class GetWhiteboardByIdParams extends S.Struct({
  "include-collaborators": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-direct-children": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetWhiteboardById200 extends S.Struct({}) {}

export class GetWhiteboardContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetWhiteboardContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetWhiteboardDirectChildrenParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* The status of the content.
*/
export class OnlyArchivedAndCurrentContentStatus extends S.Literal("current", "archived") {}

export class ChildrenResponse extends S.Class<ChildrenResponse>("ChildrenResponse")({
  /**
* ID of the child content.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(OnlyArchivedAndCurrentContentStatus, { nullable: true }),
  /**
* Title of the child content.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* Hierarchical content type (database/embed/folder/page/whiteboard).
*/
"type": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the space the content is in.
*/
"spaceId": S.optionalWith(S.String, { nullable: true }),
  /**
* Numerical value indicating position of the content relative to its siblings (with the same parentId) within the content tree.
* If the content is sorted by childPosition, it will reflect the default content ordering within the content tree.
*/
"childPosition": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetWhiteboardDirectChildren200 extends S.Struct({
  "results": S.optionalWith(S.Array(ChildrenResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetWhiteboardDescendantsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "depth": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(5)), { nullable: true, default: () => 2 as const }),
  "cursor": S.optionalWith(S.String, { nullable: true })
}) {}

export class DescendantsResponse extends S.Class<DescendantsResponse>("DescendantsResponse")({
  /**
* ID of the descendant.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(OnlyArchivedAndCurrentContentStatus, { nullable: true }),
  /**
* Title of the descendant.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* Hierarchical content type (database/embed/folder/page/whiteboard).
*/
"type": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the parent content.
*/
"parentId": S.optionalWith(S.String, { nullable: true }),
  /**
* Depth of the descendant in the content tree relative to the content specified in the request.
*/
"depth": S.optionalWith(S.Int, { nullable: true }),
  /**
* Numerical value indicating position of the content relative to its siblings (with the same parentId) within the content tree.
* If the content is sorted by childPosition, it will reflect the default content ordering within the content tree.
*/
"childPosition": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetWhiteboardDescendants200 extends S.Struct({
  "results": S.optionalWith(S.Array(DescendantsResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetWhiteboardAncestorsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

/**
* The type of ancestor.
*/
export class AncestorType extends S.Literal("page", "whiteboard", "database", "embed", "folder") {}

export class Ancestor extends S.Class<Ancestor>("Ancestor")({
  /**
* ID of the ancestor
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "type": S.optionalWith(AncestorType, { nullable: true })
}) {}

export class GetWhiteboardAncestors200 extends S.Struct({
  "results": S.optionalWith(S.Array(Ancestor), { nullable: true })
}) {}

export class CreateDatabaseParams extends S.Struct({
  "private": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class DatabaseLinks extends S.Class<DatabaseLinks>("DatabaseLinks")({
  /**
* Web UI link of the content.
*/
"webui": S.optionalWith(S.String, { nullable: true })
}) {}

export class CreateDatabase200 extends S.Struct({}) {}

export class GetDatabaseByIdParams extends S.Struct({
  "include-collaborators": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-direct-children": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetDatabaseById200 extends S.Struct({}) {}

export class GetDatabaseContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetDatabaseContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetDatabaseDirectChildrenParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetDatabaseDirectChildren200 extends S.Struct({
  "results": S.optionalWith(S.Array(ChildrenResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetDatabaseDescendantsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "depth": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(5)), { nullable: true, default: () => 2 as const }),
  "cursor": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetDatabaseDescendants200 extends S.Struct({
  "results": S.optionalWith(S.Array(DescendantsResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetDatabaseAncestorsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetDatabaseAncestors200 extends S.Struct({
  "results": S.optionalWith(S.Array(Ancestor), { nullable: true })
}) {}

export class SmartLinkLinks extends S.Class<SmartLinkLinks>("SmartLinkLinks")({
  /**
* Web UI link of the content.
*/
"webui": S.optionalWith(S.String, { nullable: true })
}) {}

export class CreateSmartLink200 extends S.Struct({}) {}

export class GetSmartLinkByIdParams extends S.Struct({
  "include-collaborators": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-direct-children": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetSmartLinkById200 extends S.Struct({}) {}

export class GetSmartLinkContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetSmartLinkContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetSmartLinkDirectChildrenParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetSmartLinkDirectChildren200 extends S.Struct({
  "results": S.optionalWith(S.Array(ChildrenResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetSmartLinkDescendantsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "depth": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(5)), { nullable: true, default: () => 2 as const }),
  "cursor": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetSmartLinkDescendants200 extends S.Struct({
  "results": S.optionalWith(S.Array(DescendantsResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetSmartLinkAncestorsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetSmartLinkAncestors200 extends S.Struct({
  "results": S.optionalWith(S.Array(Ancestor), { nullable: true })
}) {}

export class FolderLinks extends S.Class<FolderLinks>("FolderLinks")({
  /**
* Web UI link of the content.
*/
"webui": S.optionalWith(S.String, { nullable: true })
}) {}

export class CreateFolder200 extends S.Struct({}) {}

export class GetFolderByIdParams extends S.Struct({
  "include-collaborators": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-direct-children": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetFolderById200 extends S.Struct({}) {}

export class GetFolderContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetFolderContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetFolderDirectChildrenParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetFolderDirectChildren200 extends S.Struct({
  "results": S.optionalWith(S.Array(ChildrenResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetFolderDescendantsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "depth": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(5)), { nullable: true, default: () => 2 as const }),
  "cursor": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetFolderDescendants200 extends S.Struct({
  "results": S.optionalWith(S.Array(DescendantsResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetFolderAncestorsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetFolderAncestors200 extends S.Struct({
  "results": S.optionalWith(S.Array(Ancestor), { nullable: true })
}) {}

export class GetCustomContentVersionsParams extends S.Struct({
  "body-format": S.optionalWith(CustomContentBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(VersionSortOrder, { nullable: true })
}) {}

export class CustomContentVersion extends S.Class<CustomContentVersion>("CustomContentVersion")({
  /**
* Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Message associated with the current version.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* The version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
*/
"minorEdit": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The account ID of the user who created this version.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  "custom": S.optionalWith(VersionedEntity, { nullable: true })
}) {}

export class GetCustomContentVersions200 extends S.Struct({
  "results": S.optionalWith(S.Array(CustomContentVersion), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetSpacesParamsType extends S.Literal("global", "collaboration", "knowledge_base", "personal", "system", "onboarding", "xflow_sample_space") {}

export class GetSpacesParamsStatus extends S.Literal("current", "archived") {}

/**
* The sort fields for spaces. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
*/
export class SpaceSortOrder extends S.Literal("id", "-id", "key", "-key", "name", "-name") {}

/**
* The formats a space description can be represented as. A subset of BodyRepresentation.
*/
export class SpaceDescriptionBodyRepresentation extends S.Literal("plain", "view") {}

export class GetSpacesParams extends S.Struct({
  "ids": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "keys": S.optionalWith(S.Array(S.String).pipe(S.maxItems(250)), { nullable: true }),
  "type": S.optionalWith(GetSpacesParamsType, { nullable: true }),
  "status": S.optionalWith(GetSpacesParamsStatus, { nullable: true }),
  "labels": S.optionalWith(S.Array(S.String), { nullable: true }),
  "favorited-by": S.optionalWith(S.String, { nullable: true }),
  "not-favorited-by": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(SpaceSortOrder, { nullable: true }),
  "description-format": S.optionalWith(SpaceDescriptionBodyRepresentation, { nullable: true }),
  "include-icon": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

/**
* The type of space.
*/
export class SpaceType extends S.Literal("global", "collaboration", "knowledge_base", "personal", "system", "onboarding", "xflow_sample_space") {}

/**
* The status of the space.
*/
export class SpaceStatus extends S.Literal("current", "archived") {}

/**
* Contains fields for each representation type requested.
*/
export class SpaceDescription extends S.Class<SpaceDescription>("SpaceDescription")({
  "plain": S.optionalWith(BodyType, { nullable: true }),
  "view": S.optionalWith(BodyType, { nullable: true })
}) {}

/**
* The icon of the space
*/
export class SpaceIcon extends S.Class<SpaceIcon>("SpaceIcon")({
  /**
* The path (relative to base URL) at which the space's icon can be retrieved. The format should be like `/wiki/download/...` or `/wiki/aa-avatar/...`
*/
"path": S.optionalWith(S.String, { nullable: true }),
  /**
* The path (relative to base URL) that can be used to retrieve a link to download the space icon. 3LO apps should use this link instead of the value provided
* in the `path` property to retrieve the icon.
* 
* Currently this field is only returned for `global` spaces and not `personal` spaces.
*/
"apiDownloadLink": S.optionalWith(S.String, { nullable: true })
}) {}

export class SpaceLinks extends S.Class<SpaceLinks>("SpaceLinks")({
  /**
* Web UI link of the space.
*/
"webui": S.optionalWith(S.String, { nullable: true })
}) {}

export class SpaceBulk extends S.Class<SpaceBulk>("SpaceBulk")({
  /**
* ID of the space.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Key of the space.
*/
"key": S.optionalWith(S.String, { nullable: true }),
  /**
* Name of the space.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  "type": S.optionalWith(SpaceType, { nullable: true }),
  "status": S.optionalWith(SpaceStatus, { nullable: true }),
  /**
* The account ID of the user who created this space originally.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  /**
* Currently active alias for a Confluence space.
*/
"currentActiveAlias": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the space was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the space's homepage.
*/
"homepageId": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(SpaceDescription, { nullable: true }),
  "icon": S.optionalWith(SpaceIcon, { nullable: true }),
  "_links": S.optionalWith(SpaceLinks, { nullable: true })
}) {}

export class GetSpaces200 extends S.Struct({
  "results": S.optionalWith(S.Array(SpaceBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class CreateSpace201 extends S.Struct({}) {}

export class GetSpaceByIdParams extends S.Struct({
  "description-format": S.optionalWith(SpaceDescriptionBodyRepresentation, { nullable: true }),
  "include-icon": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-permissions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-role-assignments": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-labels": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class SpaceProperty extends S.Class<SpaceProperty>("SpaceProperty")({
  /**
* ID of the space property.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Key of the space property.
*/
"key": S.optionalWith(S.String, { nullable: true }),
  /**
* RFC3339 compliant date time at which the property was created.
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Atlassian account ID of the user that created the space property.
*/
"createdBy": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(S.Struct({
  /**
* RFC3339 compliant date time at which the property's current version was created.
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Atlassian account ID of the user that created the space property's current version.
*/
"createdBy": S.optionalWith(S.String, { nullable: true }),
  /**
* Message associated with the current version.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* The space property's current version number.
*/
"number": S.optionalWith(S.Int, { nullable: true })
}), { nullable: true })
}) {}

export class SpacePermissionAssignmentPrincipalType extends S.Literal("user", "group", "role") {}

/**
* The type of operation.
*/
export class SpacePermissionAssignmentOperationKey extends S.Literal("use", "create", "read", "update", "delete", "copy", "move", "export", "purge", "purge_version", "administer", "restore", "create_space", "restrict_content", "archive") {}

/**
* The type of entity the operation type targets.
*/
export class SpacePermissionAssignmentOperationTargetType extends S.Literal("page", "blogpost", "comment", "attachment", "whiteboard", "database", "embed", "folder", "space", "application", "userProfile") {}

export class SpacePermissionAssignment extends S.Class<SpacePermissionAssignment>("SpacePermissionAssignment")({
  /**
* ID of the space permission.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* The entity the space permissions corresponds to.
*/
"principal": S.optionalWith(S.Struct({
  "type": S.optionalWith(SpacePermissionAssignmentPrincipalType, { nullable: true }),
  /**
* ID of the entity.
*/
"id": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  /**
* The operation the space permission corresponds to.
*/
"operation": S.optionalWith(S.Struct({
  /**
* The type of operation.
*/
"key": S.optionalWith(SpacePermissionAssignmentOperationKey, { nullable: true }),
  /**
* The type of entity the operation type targets.
*/
"targetType": S.optionalWith(SpacePermissionAssignmentOperationTargetType, { nullable: true })
}), { nullable: true })
}) {}

export class GetSpaceById200 extends S.Struct({}) {}

export class GetBlogPostsInSpaceParams extends S.Struct({
  "sort": S.optionalWith(BlogPostSortOrder, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "deleted", "trashed")), { nullable: true }),
  "title": S.optionalWith(S.String, { nullable: true }),
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetBlogPostsInSpace200 extends S.Struct({
  "results": S.optionalWith(S.Array(BlogPostBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetSpaceLabelsParamsPrefix extends S.Literal("my", "team") {}

export class GetSpaceLabelsParams extends S.Struct({
  "prefix": S.optionalWith(GetSpaceLabelsParamsPrefix, { nullable: true, default: () => "my, team" as const }),
  "sort": S.optionalWith(S.String, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetSpaceLabels200 extends S.Struct({
  "results": S.optionalWith(S.Array(Label), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetSpaceContentLabelsParamsPrefix extends S.Literal("my", "team") {}

export class GetSpaceContentLabelsParams extends S.Struct({
  "prefix": S.optionalWith(GetSpaceContentLabelsParamsPrefix, { nullable: true, default: () => "my, team" as const }),
  "sort": S.optionalWith(S.String, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetSpaceContentLabels200 extends S.Struct({
  "results": S.optionalWith(S.Array(Label), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetCustomContentByTypeInSpaceParams extends S.Struct({
  "type": S.String,
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "body-format": S.optionalWith(CustomContentBodyRepresentation, { nullable: true })
}) {}

export class GetCustomContentByTypeInSpace200 extends S.Struct({
  "results": S.optionalWith(S.Array(CustomContentBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPagesInSpaceParamsDepth extends S.Literal("all", "root") {}

export class GetPagesInSpaceParams extends S.Struct({
  "depth": S.optionalWith(GetPagesInSpaceParamsDepth, { nullable: true, default: () => "all" as const }),
  "sort": S.optionalWith(PageSortOrder, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "deleted", "trashed")), { nullable: true }),
  "title": S.optionalWith(S.String, { nullable: true }),
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetPagesInSpace200 extends S.Struct({
  "results": S.optionalWith(S.Array(PageBulk), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetSpacePropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetSpaceProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(SpaceProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class SpacePropertyCreateRequest extends S.Class<SpacePropertyCreateRequest>("SpacePropertyCreateRequest")({
  /**
* Key of the space property
*/
"key": S.optionalWith(S.String, { nullable: true })
}) {}

export class SpacePropertyUpdateRequest extends S.Class<SpacePropertyUpdateRequest>("SpacePropertyUpdateRequest")({
  /**
* Key of the space property
*/
"key": S.optionalWith(S.String, { nullable: true }),
  /**
* New version number and associated message
*/
"version": S.optionalWith(S.Struct({
  /**
* Version number of the new version. Should be 1 more than the current version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Message to be associated with the new version.
*/
"message": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}) {}

export class GetSpacePermissionsAssignmentsParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetSpacePermissionsAssignments200 extends S.Struct({
  "results": S.optionalWith(S.Array(SpacePermissionAssignment), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetAvailableSpacePermissionsParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class SpacePermission extends S.Class<SpacePermission>("SpacePermission")({
  /**
* The identifier for the space permission.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* The display name for the space permission.
*/
"displayName": S.optionalWith(S.String, { nullable: true }),
  /**
* Describes the space permissions usage.
*/
"description": S.optionalWith(S.String, { nullable: true }),
  /**
* The permissions required for this permission to be enabled.
*/
"requiredPermissionIds": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

export class GetAvailableSpacePermissions200 extends S.Struct({
  "results": S.optionalWith(S.Array(SpacePermission), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

/**
* The principal type.
*/
export class PrincipalType extends S.Literal("USER", "GROUP", "ACCESS_CLASS") {}

export class GetAvailableSpaceRolesParams extends S.Struct({
  "space-id": S.optionalWith(S.String, { nullable: true }),
  "role-type": S.optionalWith(S.String, { nullable: true }),
  "principal-id": S.optionalWith(S.String, { nullable: true }),
  "principal-type": S.optionalWith(PrincipalType, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

/**
* The role type.
*/
export class RoleType extends S.Literal("SYSTEM", "CUSTOM") {}

export class SpaceRole extends S.Class<SpaceRole>("SpaceRole")({
  /**
* The identifier for the space role.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "type": S.optionalWith(RoleType, { nullable: true }),
  /**
* The name for the space role.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* The description for the space roles usage.
*/
"description": S.optionalWith(S.String, { nullable: true }),
  /**
* The space permissions the space role is comprised of.
*/
"spacePermissions": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

export class GetAvailableSpaceRoles200 extends S.Struct({
  "results": S.optionalWith(S.Array(SpaceRole), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class CreateSpaceRoleRequest extends S.Class<CreateSpaceRoleRequest>("CreateSpaceRoleRequest")({
  /**
* Name of the space role
*/
"name": S.String,
  /**
* Description for the space role
*/
"description": S.String,
  /**
* The ids of the space permissions associated with the space role. Sample value "read/space"; retrieve ids from responses returned by [GET /space-permissions](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-space-permissions/#api-space-permissions-get) endpoint
*/
"spacePermissions": S.Array(S.String)
}) {}

export class GetSpaceRolesById200 extends S.Struct({}) {}

export class UpdateSpaceRoleRequest extends S.Class<UpdateSpaceRoleRequest>("UpdateSpaceRoleRequest")({
  /**
* Name of the space role
*/
"name": S.String,
  /**
* Description for the space role
*/
"description": S.String,
  /**
* The ids of the space permissions associated with the space role. Sample value "read/space"; retrieve ids from responses returned by [GET /space-permissions](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-space-permissions/#api-space-permissions-get) endpoint
*/
"spacePermissions": S.Array(S.String),
  /**
* If space anonymous access is assigned to the role being modified, the Id of a role to migrate those assignments to can be specified. Anonymous access role assignments left unchanged if unspecified.
*/
"anonymousReassignmentRoleId": S.optionalWith(S.String, { nullable: true }),
  /**
* If guests are assigned to the role being modified, the Id of a role to migrate those assignments to can be specified. Guest role assignments left unchanged if unspecified.
*/
"guestReassignmentRoleId": S.optionalWith(S.String, { nullable: true })
}) {}

export class UpdateSpaceRoleResponse extends S.Class<UpdateSpaceRoleResponse>("UpdateSpaceRoleResponse")({
  /**
* Id of the space role
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "type": S.optionalWith(RoleType, { nullable: true }),
  /**
* Name of the space role
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Description for the space role
*/
"description": S.optionalWith(S.String, { nullable: true }),
  /**
* Id of the task to update the space permissions associated with the space role
*/
"taskId": S.optionalWith(S.String, { nullable: true })
}) {}

export class DeleteSpaceRoleResponse extends S.Class<DeleteSpaceRoleResponse>("DeleteSpaceRoleResponse")({
  /**
* Id of the task to update the space permissions associated with the space role
*/
"taskId": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* The space role mode.
*/
export class GetSpaceRoleMode200Mode extends S.Literal("PRE_ROLES", "ROLES_TRANSITION", "ROLES") {}

export class GetSpaceRoleMode200 extends S.Struct({
  /**
* The space role mode.
*/
"mode": S.optionalWith(GetSpaceRoleMode200Mode, { nullable: true })
}) {}

export class GetSpaceRoleAssignmentsParams extends S.Struct({
  "role-id": S.optionalWith(S.String, { nullable: true }),
  "role-type": S.optionalWith(S.String, { nullable: true }),
  "principal-id": S.optionalWith(S.String, { nullable: true }),
  "principal-type": S.optionalWith(PrincipalType, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

/**
* The principal of the role assignment.
*/
export class Principal extends S.Class<Principal>("Principal")({
  "principalType": S.optionalWith(PrincipalType, { nullable: true }),
  /**
* The principal ID.
*/
"principalId": S.optionalWith(S.String, { nullable: true })
}) {}

export class SpaceRoleAssignment extends S.Class<SpaceRoleAssignment>("SpaceRoleAssignment")({
  "principal": S.optionalWith(Principal, { nullable: true }),
  /**
* The role to which the principal is assigned.
*/
"roleId": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetSpaceRoleAssignments200 extends S.Struct({
  "results": S.optionalWith(S.Array(SpaceRoleAssignment), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class SetSpaceRoleAssignments200 extends S.Struct({
  "results": S.optionalWith(S.Array(SpaceRoleAssignment), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPageFooterCommentsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "trashed", "deleted", "historical", "draft")), { nullable: true }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class PageCommentModel extends S.Class<PageCommentModel>("PageCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the page the comment is in.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetPageFooterComments200 extends S.Struct({
  "results": S.optionalWith(S.Array(PageCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPageInlineCommentsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "archived", "trashed", "deleted", "historical", "draft")), { nullable: true }),
  "resolution-status": S.optionalWith(S.Array(S.Literal("resolved", "open", "dangling", "reopened")), { nullable: true }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

/**
* Inline comment resolution status
*/
export class InlineCommentResolutionStatus extends S.Literal("open", "reopened", "resolved", "dangling") {}

export class InlineCommentProperties extends S.Class<InlineCommentProperties>("InlineCommentProperties")({
  /**
* Property value used to reference the highlighted element in DOM.
*/
"inlineMarkerRef": S.optionalWith(S.String, { nullable: true }),
  /**
* Text that is highlighted.
*/
"inlineOriginalSelection": S.optionalWith(S.String, { nullable: true })
}) {}

export class PageInlineCommentModel extends S.Class<PageInlineCommentModel>("PageInlineCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the page the comment is in.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true }),
  "resolutionStatus": S.optionalWith(InlineCommentResolutionStatus, { nullable: true }),
  "properties": S.optionalWith(InlineCommentProperties, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetPageInlineComments200 extends S.Struct({
  "results": S.optionalWith(S.Array(PageInlineCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetBlogPostFooterCommentsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "deleted", "trashed", "historical", "draft")), { nullable: true }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class BlogPostCommentModel extends S.Class<BlogPostCommentModel>("BlogPostCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the blog post the comment is in.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetBlogPostFooterComments200 extends S.Struct({
  "results": S.optionalWith(S.Array(BlogPostCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetBlogPostInlineCommentsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "status": S.optionalWith(S.Array(S.Literal("current", "deleted", "trashed", "historical", "draft")), { nullable: true }),
  "resolution-status": S.optionalWith(S.Array(S.Literal("resolved", "open", "dangling", "reopened")), { nullable: true }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class BlogPostInlineCommentModel extends S.Class<BlogPostInlineCommentModel>("BlogPostInlineCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the blog post the comment is in.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true }),
  "resolutionStatus": S.optionalWith(InlineCommentResolutionStatus, { nullable: true }),
  "properties": S.optionalWith(InlineCommentProperties, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetBlogPostInlineComments200 extends S.Struct({
  "results": S.optionalWith(S.Array(BlogPostInlineCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetFooterCommentsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class FooterCommentModel extends S.Class<FooterCommentModel>("FooterCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the blog post containing the comment if the comment is on a blog post.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the page containing the comment if the comment is on a page.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the attachment containing the comment if the comment is on an attachment.
*/
"attachmentId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the custom content containing the comment if the comment is on a custom content.
*/
"customContentId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the parent comment if the comment is a reply.
*/
"parentCommentId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "properties": S.optionalWith(S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "meta": S.optionalWith(OptionalFieldMeta, { nullable: true }),
  "_links": S.optionalWith(OptionalFieldLinks, { nullable: true })
}), { nullable: true }),
  "operations": S.optionalWith(S.Struct({
  "results": S.optionalWith(S.Array(Operation), { nullable: true }),
  "meta": S.optionalWith(OptionalFieldMeta, { nullable: true }),
  "_links": S.optionalWith(OptionalFieldLinks, { nullable: true })
}), { nullable: true }),
  "likes": S.optionalWith(S.Struct({
  "results": S.optionalWith(S.Array(Like), { nullable: true }),
  "meta": S.optionalWith(OptionalFieldMeta, { nullable: true }),
  "_links": S.optionalWith(OptionalFieldLinks, { nullable: true })
}), { nullable: true }),
  "versions": S.optionalWith(S.Struct({
  "results": S.optionalWith(S.Array(Version), { nullable: true }),
  "meta": S.optionalWith(OptionalFieldMeta, { nullable: true }),
  "_links": S.optionalWith(OptionalFieldLinks, { nullable: true })
}), { nullable: true }),
  "body": S.optionalWith(BodySingle, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetFooterComments200 extends S.Struct({
  "results": S.optionalWith(S.Array(FooterCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

/**
* Type of content representation used for the value field.
*/
export class CommentBodyWriteRepresentation extends S.Literal("storage", "atlas_doc_format", "wiki") {}

export class CommentBodyWrite extends S.Class<CommentBodyWrite>("CommentBodyWrite")({
  /**
* Type of content representation used for the value field.
*/
"representation": S.optionalWith(CommentBodyWriteRepresentation, { nullable: true }),
  /**
* Body of the comment, in the format found in the representation field.
*/
"value": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* Body of the comment. Only one body format should be specified as the property
* for this object, e.g. `storage`.
*/
export class CommentNestedBodyWrite extends S.Class<CommentNestedBodyWrite>("CommentNestedBodyWrite")({
  "storage": S.optionalWith(CommentBodyWrite, { nullable: true }),
  "atlas_doc_format": S.optionalWith(CommentBodyWrite, { nullable: true }),
  "wiki": S.optionalWith(CommentBodyWrite, { nullable: true })
}) {}

export class CreateFooterCommentModel extends S.Class<CreateFooterCommentModel>("CreateFooterCommentModel")({
  /**
* ID of the containing blog post, if intending to create a top level footer comment. Do not provide if creating a reply.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the containing page, if intending to create a top level footer comment. Do not provide if creating a reply.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the parent comment, if intending to create a reply. Do not provide if creating a top level comment.
*/
"parentCommentId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the attachment, if intending to create a comment against an attachment.
*/
"attachmentId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the custom content, if intending to create a comment against a custom content.
*/
"customContentId": S.optionalWith(S.String, { nullable: true }),
  "body": S.optionalWith(S.Union(CommentBodyWrite,
CommentNestedBodyWrite), { nullable: true })
}) {}

export class CreateFooterComment201 extends S.Struct({}) {}

export class GetFooterCommentByIdParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentationSingle, { nullable: true }),
  "version": S.optionalWith(S.Int, { nullable: true }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-likes": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-versions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-version": S.optionalWith(S.Boolean, { nullable: true, default: () => true as const })
}) {}

export class GetFooterCommentById200 extends S.Struct({}) {}

export class UpdateFooterCommentRequest extends S.Struct({}) {}

export class GetFooterCommentChildrenParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class ChildrenCommentModel extends S.Class<ChildrenCommentModel>("ChildrenCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the parent comment the child comment is in.
*/
"parentCommentId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetFooterCommentChildren200 extends S.Struct({
  "results": S.optionalWith(S.Array(ChildrenCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetFooterLikeCount200 extends S.Struct({
  /**
* The count number
*/
"count": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetFooterLikeUsersParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetFooterLikeUsers200 extends S.Struct({
  "results": S.optionalWith(S.Array(Like), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetFooterCommentVersionsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(VersionSortOrder, { nullable: true })
}) {}

export class CommentVersion extends S.Class<CommentVersion>("CommentVersion")({
  /**
* Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Message associated with the current version.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* The version number.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
*/
"minorEdit": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The account ID of the user who created this version.
*/
"authorId": S.optionalWith(S.String, { nullable: true }),
  "comment": S.optionalWith(VersionedEntity, { nullable: true })
}) {}

export class GetFooterCommentVersions200 extends S.Struct({
  "results": S.optionalWith(S.Array(CommentVersion), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetInlineCommentsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class InlineCommentModel extends S.Class<InlineCommentModel>("InlineCommentModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the blog post containing the comment if the comment is on a blog post.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the page containing the comment if the comment is on a page.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the parent comment if the comment is a reply.
*/
"parentCommentId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodySingle, { nullable: true }),
  /**
* Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened.
*/
"resolutionLastModifierId": S.optionalWith(S.String, { nullable: true }),
  /**
* Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
*/
"resolutionLastModifiedAt": S.optionalWith(S.String, { nullable: true }),
  "resolutionStatus": S.optionalWith(InlineCommentResolutionStatus, { nullable: true }),
  "properties": S.optionalWith(S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "meta": S.optionalWith(OptionalFieldMeta, { nullable: true }),
  "_links": S.optionalWith(OptionalFieldLinks, { nullable: true }),
  /**
* Property value used to reference the highlighted element in DOM.
*/
"inlineMarkerRef": S.optionalWith(S.String, { nullable: true }),
  /**
* Text that is highlighted.
*/
"inlineOriginalSelection": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "operations": S.optionalWith(S.Struct({
  "results": S.optionalWith(S.Array(Operation), { nullable: true }),
  "meta": S.optionalWith(OptionalFieldMeta, { nullable: true }),
  "_links": S.optionalWith(OptionalFieldLinks, { nullable: true })
}), { nullable: true }),
  "likes": S.optionalWith(S.Struct({
  "results": S.optionalWith(S.Array(Like), { nullable: true }),
  "meta": S.optionalWith(OptionalFieldMeta, { nullable: true }),
  "_links": S.optionalWith(OptionalFieldLinks, { nullable: true })
}), { nullable: true }),
  "versions": S.optionalWith(S.Struct({
  "results": S.optionalWith(S.Array(Version), { nullable: true }),
  "meta": S.optionalWith(OptionalFieldMeta, { nullable: true }),
  "_links": S.optionalWith(OptionalFieldLinks, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetInlineComments200 extends S.Struct({
  "results": S.optionalWith(S.Array(InlineCommentModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class CreateInlineCommentModel extends S.Class<CreateInlineCommentModel>("CreateInlineCommentModel")({
  /**
* ID of the containing blog post, if intending to create a top level footer comment. Do not provide if creating a reply.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the containing page, if intending to create a top level footer comment. Do not provide if creating a reply.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the parent comment, if intending to create a reply. Do not provide if creating a top level comment.
*/
"parentCommentId": S.optionalWith(S.String, { nullable: true }),
  "body": S.optionalWith(S.Union(CommentBodyWrite,
CommentNestedBodyWrite), { nullable: true }),
  /**
* Object describing the text to highlight on the page/blog post. Only applicable for top level inline comments (not replies) and required in that case.
*/
"inlineCommentProperties": S.optionalWith(S.Struct({
  /**
* The text to highlight
*/
"textSelection": S.optionalWith(S.String, { nullable: true }),
  /**
* The number of matches for the selected text on the page (should be strictly greater than textSelectionMatchIndex)
*/
"textSelectionMatchCount": S.optionalWith(S.Int, { nullable: true }),
  /**
* The match index to highlight. This is zero-based. E.g. if you have 3 occurrences of "hello world" on a page 
* and you want to highlight the second occurrence, you should pass 1 for textSelectionMatchIndex and 3 for textSelectionMatchCount.
*/
"textSelectionMatchIndex": S.optionalWith(S.Int, { nullable: true })
}), { nullable: true })
}) {}

export class CreateInlineComment201 extends S.Struct({}) {}

export class GetInlineCommentByIdParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentationSingle, { nullable: true }),
  "version": S.optionalWith(S.Int, { nullable: true }),
  "include-properties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-operations": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-likes": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-versions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "include-version": S.optionalWith(S.Boolean, { nullable: true, default: () => true as const })
}) {}

export class GetInlineCommentById200 extends S.Struct({}) {}

export class UpdateInlineCommentModel extends S.Class<UpdateInlineCommentModel>("UpdateInlineCommentModel")({
  "version": S.optionalWith(S.Struct({
  /**
* Number of new version. Should be 1 higher than current version of the comment.
*/
"number": S.optionalWith(S.Int, { nullable: true }),
  /**
* Optional message store for the new version.
*/
"message": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "body": S.optionalWith(S.Union(CommentBodyWrite,
CommentNestedBodyWrite), { nullable: true }),
  /**
* Resolved state of the comment. Set to true to resolve the comment, set to false to reopen it. If
* matching the existing state (i.e. true -> resolved or false -> open/reopened) , no change will occur. A dangling
* comment cannot be updated.
*/
"resolved": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class UpdateInlineComment200 extends S.Struct({}) {}

export class GetInlineCommentChildrenParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "sort": S.optionalWith(CommentSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class InlineCommentChildrenModel extends S.Class<InlineCommentChildrenModel>("InlineCommentChildrenModel")({
  /**
* ID of the comment.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(ContentStatus, { nullable: true }),
  /**
* Title of the comment.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the parent comment the child comment is in.
*/
"parentCommentId": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(Version, { nullable: true }),
  "body": S.optionalWith(BodyBulk, { nullable: true }),
  "resolutionStatus": S.optionalWith(InlineCommentResolutionStatus, { nullable: true }),
  "properties": S.optionalWith(InlineCommentProperties, { nullable: true }),
  "_links": S.optionalWith(CommentLinks, { nullable: true })
}) {}

export class GetInlineCommentChildren200 extends S.Struct({
  "results": S.optionalWith(S.Array(InlineCommentChildrenModel), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetInlineLikeCount200 extends S.Struct({
  /**
* The count number
*/
"count": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetInlineLikeUsersParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetInlineLikeUsers200 extends S.Struct({
  "results": S.optionalWith(S.Array(Like), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetInlineCommentVersionsParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(VersionSortOrder, { nullable: true })
}) {}

export class GetInlineCommentVersions200 extends S.Struct({
  "results": S.optionalWith(S.Array(CommentVersion), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetCommentContentPropertiesParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "sort": S.optionalWith(ContentPropertySortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetCommentContentProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(ContentProperty), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetTasksParamsStatus extends S.Literal("complete", "incomplete") {}

export class GetTasksParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true }),
  "include-blank-tasks": S.optionalWith(S.Boolean, { nullable: true }),
  "status": S.optionalWith(GetTasksParamsStatus, { nullable: true }),
  "task-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "space-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "page-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "blogpost-id": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "created-by": S.optionalWith(S.Array(S.String).pipe(S.maxItems(250)), { nullable: true }),
  "assigned-to": S.optionalWith(S.Array(S.String).pipe(S.maxItems(250)), { nullable: true }),
  "completed-by": S.optionalWith(S.Array(S.String).pipe(S.maxItems(250)), { nullable: true }),
  "created-at-from": S.optionalWith(S.Int, { nullable: true }),
  "created-at-to": S.optionalWith(S.Int, { nullable: true }),
  "due-at-from": S.optionalWith(S.Int, { nullable: true }),
  "due-at-to": S.optionalWith(S.Int, { nullable: true }),
  "completed-at-from": S.optionalWith(S.Int, { nullable: true }),
  "completed-at-to": S.optionalWith(S.Int, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

/**
* Status of the task.
*/
export class TaskStatus extends S.Literal("complete", "incomplete") {}

/**
* Contains fields for each representation type requested.
*/
export class TaskBodySingle extends S.Class<TaskBodySingle>("TaskBodySingle")({
  "storage": S.optionalWith(BodyType, { nullable: true }),
  "atlas_doc_format": S.optionalWith(BodyType, { nullable: true })
}) {}

export class Task extends S.Class<Task>("Task")({
  /**
* ID of the task.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Local ID of the task. This ID is local to the corresponding page or blog post.
*/
"localId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the space the task is in.
*/
"spaceId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the page the task is in.
*/
"pageId": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the blog post the task is in.
*/
"blogPostId": S.optionalWith(S.String, { nullable: true }),
  /**
* Status of the task.
*/
"status": S.optionalWith(TaskStatus, { nullable: true }),
  "body": S.optionalWith(TaskBodySingle, { nullable: true }),
  /**
* Account ID of the user who created this task.
*/
"createdBy": S.optionalWith(S.String, { nullable: true }),
  /**
* Account ID of the user to whom this task is assigned.
*/
"assignedTo": S.optionalWith(S.String, { nullable: true }),
  /**
* Account ID of the user who completed this task.
*/
"completedBy": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the task was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"createdAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the task was updated. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"updatedAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the task is due. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"dueAt": S.optionalWith(S.String, { nullable: true }),
  /**
* Date and time when the task was completed. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
*/
"completedAt": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetTasks200 extends S.Struct({
  "results": S.optionalWith(S.Array(Task), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetTaskByIdParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true })
}) {}

export class UpdateTaskParams extends S.Struct({
  "body-format": S.optionalWith(PrimaryBodyRepresentation, { nullable: true })
}) {}

export class GetChildPagesParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(S.String, { nullable: true })
}) {}

export class ChildPage extends S.Class<ChildPage>("ChildPage")({
  /**
* ID of the page.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(OnlyArchivedAndCurrentContentStatus, { nullable: true }),
  /**
* Title of the page.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the space the page is in.
*/
"spaceId": S.optionalWith(S.String, { nullable: true }),
  /**
* Position of child page within the given parent page tree.
*/
"childPosition": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetChildPages200 extends S.Struct({
  "results": S.optionalWith(S.Array(ChildPage), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetChildCustomContentParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(S.String, { nullable: true })
}) {}

export class ChildCustomContent extends S.Class<ChildCustomContent>("ChildCustomContent")({
  /**
* ID of the child custom content.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(OnlyArchivedAndCurrentContentStatus, { nullable: true }),
  /**
* Title of the custom content.
*/
"title": S.optionalWith(S.String, { nullable: true }),
  /**
* Custom content type.
*/
"type": S.optionalWith(S.String, { nullable: true }),
  /**
* ID of the space the custom content is in.
*/
"spaceId": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetChildCustomContent200 extends S.Struct({
  "results": S.optionalWith(S.Array(ChildCustomContent), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPageDirectChildrenParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "sort": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetPageDirectChildren200 extends S.Struct({
  "results": S.optionalWith(S.Array(ChildrenResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPageAncestorsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class GetPageAncestors200 extends S.Struct({
  "results": S.optionalWith(S.Array(Ancestor), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetPageDescendantsParams extends S.Struct({
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const }),
  "depth": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(5)), { nullable: true, default: () => 2 as const }),
  "cursor": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetPageDescendants200 extends S.Struct({
  "results": S.optionalWith(S.Array(DescendantsResponse), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

/**
* The account status of the user.
*/
export class AccountStatus extends S.Literal("active", "inactive", "closed", "unknown") {}

/**
* The account type of the user.
*/
export class AccountType extends S.Literal("atlassian", "app", "customer", "unknown") {}

/**
* This object represents an icon. If used as a profilePicture, this may be returned as null, depending on the user's privacy setting.
*/
export class Icon extends S.Class<Icon>("Icon")({
  "path": S.String,
  "isDefault": S.Boolean
}) {}

export class User extends S.Class<User>("User")({
  /**
* Display name of the user.
*/
"displayName": S.optionalWith(S.String, { nullable: true }),
  /**
* Time zone of the user. Depending on the user's privacy
* setting, this may return null.
*/
"timeZone": S.optionalWith(S.String, { nullable: true }),
  /**
* Space ID of the user's personal space. Returns null, if no personal space for the user.
*/
"personalSpaceId": S.optionalWith(S.String, { nullable: true }),
  /**
* Whether the user is an external collaborator.
*/
"isExternalCollaborator": S.optionalWith(S.Boolean, { nullable: true }),
  "accountStatus": S.optionalWith(AccountStatus, { nullable: true }),
  /**
* Account ID of the user.
*/
"accountId": S.optionalWith(S.String, { nullable: true }),
  /**
* The email address of the user. Depending on the user's privacy setting, this may return an empty string.
*/
"email": S.optionalWith(S.String, { nullable: true }),
  "accountType": S.optionalWith(AccountType, { nullable: true }),
  /**
* Public name of the user.
*/
"publicName": S.optionalWith(S.String, { nullable: true }),
  "profilePicture": S.optionalWith(Icon, { nullable: true })
}) {}

export class CreateBulkUserLookup200 extends S.Struct({
  "results": S.optionalWith(S.Array(User), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class CheckAccessByEmail200 extends S.Struct({
  /**
* List of emails that do not have access to site.
*/
"emailsWithoutAccess": S.optionalWith(S.Array(S.String), { nullable: true }),
  /**
* List of invalid emails provided in the request.
*/
"invalidEmails": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

/**
* Details about data policies.
*/
export class DataPolicyMetadata extends S.Class<DataPolicyMetadata>("DataPolicyMetadata")({
  /**
* Whether the workspace contains any content blocked for (inaccessible to) the requesting client application.
*/
"anyContentBlocked": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class GetDataPolicySpacesParams extends S.Struct({
  "ids": S.optionalWith(S.Array(S.Int).pipe(S.maxItems(250)), { nullable: true }),
  "keys": S.optionalWith(S.Array(S.String).pipe(S.maxItems(250)), { nullable: true }),
  "sort": S.optionalWith(SpaceSortOrder, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 25 as const })
}) {}

export class DataPolicySpace extends S.Class<DataPolicySpace>("DataPolicySpace")({
  /**
* ID of the space.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Key of the space.
*/
"key": S.optionalWith(S.String, { nullable: true }),
  /**
* Name of the space.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(SpaceDescription, { nullable: true }),
  "dataPolicy": S.optionalWith(S.Struct({
  /**
* Whether the space contains any content blocked for (inaccessible to) the requesting client application.
*/
"anyContentBlocked": S.optionalWith(S.Boolean, { nullable: true })
}), { nullable: true }),
  "icon": S.optionalWith(SpaceIcon, { nullable: true }),
  "_links": S.optionalWith(SpaceLinks, { nullable: true })
}) {}

export class GetDataPolicySpaces200 extends S.Struct({
  "results": S.optionalWith(S.Array(DataPolicySpace), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class ClassificationLevelStatus extends S.Literal("DRAFT", "PUBLISHED", "ARCHIVED") {}

export class ClassificationLevelColor extends S.Literal("RED", "RED_BOLD", "ORANGE", "YELLOW", "GREEN", "BLUE", "NAVY", "TEAL", "PURPLE", "GREY", "LIME") {}

/**
* A unit of [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/) defined by an organiation. 
* A classification level may be associated with specific storage and handling requirements or expectations.
*/
export class ClassificationLevel extends S.Class<ClassificationLevel>("ClassificationLevel")({
  /**
* The ID of the classification level.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* The status of the classification level.
*/
"status": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  /**
* The order of the classification level object.
*/
"order": S.optionalWith(S.Number, { nullable: true }),
  /**
* The name of the classification level object.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* The description of the classification level object.
*/
"description": S.optionalWith(S.String, { nullable: true }),
  /**
* The guideline of the classification level object.
*/
"guideline": S.optionalWith(S.String, { nullable: true }),
  /**
* The color of the classification level object.
*/
"color": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}) {}

export class GetClassificationLevels200 extends S.Array(ClassificationLevel) {}

export class GetPageClassificationLevelParamsStatus extends S.Literal("current", "draft", "archived") {}

export class GetPageClassificationLevelParams extends S.Struct({
  "status": S.optionalWith(GetPageClassificationLevelParamsStatus, { nullable: true, default: () => "current" as const })
}) {}

export class GetBlogPostClassificationLevelParamsStatus extends S.Literal("current", "draft", "archived") {}

export class GetBlogPostClassificationLevelParams extends S.Struct({
  "status": S.optionalWith(GetBlogPostClassificationLevelParamsStatus, { nullable: true, default: () => "current" as const })
}) {}

export class GetForgeAppPropertiesParams extends S.Struct({
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(1), S.lessThanOrEqualTo(250)), { nullable: true, default: () => 50 as const })
}) {}

export class GetForgeAppProperties200 extends S.Struct({
  "results": S.optionalWith(S.Array(S.Struct({
  /**
* The key of the property
*/
"key": S.optionalWith(S.String, { nullable: true }),
  /**
* The value of the property
*/
"value": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
})), { nullable: true }),
  "_links": S.optionalWith(MultiEntityLinks, { nullable: true })
}) {}

export class GetForgeAppProperty200 extends S.Struct({
  /**
* The key of the property
*/
"key": S.optionalWith(S.String, { nullable: true }),
  /**
* The value of the property
*/
"value": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}) {}

export class PutForgeAppPropertyRequest extends S.Record({ key: S.String, value: S.Unknown }) {}

export const make = (
  httpClient: HttpClient.HttpClient, 
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): ConfluenceV2Client => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse: <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ) => (
    request: HttpClientRequest.HttpClientRequest,
  ) => Effect.Effect<any, any> = options.transformClient
    ? (f) => (request) =>
        Effect.flatMap(
          Effect.flatMap(options.transformClient!(httpClient), (client) =>
            client.execute(request),
          ),
          f,
        )
    : (f) => (request) => Effect.flatMap(httpClient.execute(request), f)
  const decodeSuccess =
    <A, I, R>(schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, A, I, R>(tag: Tag, schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(ConfluenceV2ClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "getAdminKey": () => HttpClientRequest.get(`/admin-key`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AdminKeyResponse),
      orElse: unexpectedStatus
    }))
  ),
  "enableAdminKey": () => HttpClientRequest.post(`/admin-key`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AdminKeyResponse),
      orElse: unexpectedStatus
    }))
  ),
  "disableAdminKey": () => HttpClientRequest.del(`/admin-key`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getAttachments": (options) => HttpClientRequest.get(`/attachments`).pipe(
    HttpClientRequest.setUrlParams({ "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "status": options?.["status"] as any, "mediaType": options?.["mediaType"] as any, "filename": options?.["filename"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAttachments200),
      orElse: unexpectedStatus
    }))
  ),
  "getAttachmentById": (id, options) => HttpClientRequest.get(`/attachments/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "version": options?.["version"] as any, "include-labels": options?.["include-labels"] as any, "include-properties": options?.["include-properties"] as any, "include-operations": options?.["include-operations"] as any, "include-versions": options?.["include-versions"] as any, "include-version": options?.["include-version"] as any, "include-collaborators": options?.["include-collaborators"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAttachmentById200),
      orElse: unexpectedStatus
    }))
  ),
  "deleteAttachment": (id, options) => HttpClientRequest.del(`/attachments/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "purge": options?.["purge"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getAttachmentLabels": (id, options) => HttpClientRequest.get(`/attachments/${id}/labels`).pipe(
    HttpClientRequest.setUrlParams({ "prefix": options?.["prefix"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAttachmentLabels200),
      orElse: unexpectedStatus
    }))
  ),
  "getAttachmentOperations": (id) => HttpClientRequest.get(`/attachments/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getAttachmentContentProperties": (attachmentId, options) => HttpClientRequest.get(`/attachments/${attachmentId}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAttachmentContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createAttachmentProperty": (attachmentId, options) => HttpClientRequest.post(`/attachments/${attachmentId}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getAttachmentContentPropertiesById": (attachmentId, propertyId) => HttpClientRequest.get(`/attachments/${attachmentId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateAttachmentPropertyById": (attachmentId, propertyId, options) => HttpClientRequest.put(`/attachments/${attachmentId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteAttachmentPropertyById": (attachmentId, propertyId) => HttpClientRequest.del(`/attachments/${attachmentId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getAttachmentVersions": (id, options) => HttpClientRequest.get(`/attachments/${id}/versions`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAttachmentVersions200),
      orElse: unexpectedStatus
    }))
  ),
  "getAttachmentVersionDetails": (attachmentId, versionNumber) => HttpClientRequest.get(`/attachments/${attachmentId}/versions/${versionNumber}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DetailedVersion),
      orElse: unexpectedStatus
    }))
  ),
  "getAttachmentComments": (id, options) => HttpClientRequest.get(`/attachments/${id}/footer-comments`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any, "version": options?.["version"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAttachmentComments200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPosts": (options) => HttpClientRequest.get(`/blogposts`).pipe(
    HttpClientRequest.setUrlParams({ "id": options?.["id"] as any, "space-id": options?.["space-id"] as any, "sort": options?.["sort"] as any, "status": options?.["status"] as any, "title": options?.["title"] as any, "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPosts200),
      orElse: unexpectedStatus
    }))
  ),
  "createBlogPost": (options) => HttpClientRequest.post(`/blogposts`).pipe(
    HttpClientRequest.setUrlParams({ "private": options?.["private"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateBlogPost200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostById": (id, options) => HttpClientRequest.get(`/blogposts/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "get-draft": options?.["get-draft"] as any, "status": options?.["status"] as any, "version": options?.["version"] as any, "include-labels": options?.["include-labels"] as any, "include-properties": options?.["include-properties"] as any, "include-operations": options?.["include-operations"] as any, "include-likes": options?.["include-likes"] as any, "include-versions": options?.["include-versions"] as any, "include-version": options?.["include-version"] as any, "include-favorited-by-current-user-status": options?.["include-favorited-by-current-user-status"] as any, "include-webresources": options?.["include-webresources"] as any, "include-collaborators": options?.["include-collaborators"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPostById200),
      orElse: unexpectedStatus
    }))
  ),
  "updateBlogPost": (id) => HttpClientRequest.put(`/blogposts/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UpdateBlogPost200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "deleteBlogPost": (id, options) => HttpClientRequest.del(`/blogposts/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "purge": options?.["purge"] as any, "draft": options?.["draft"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getBlogpostAttachments": (id, options) => HttpClientRequest.get(`/blogposts/${id}/attachments`).pipe(
    HttpClientRequest.setUrlParams({ "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "status": options?.["status"] as any, "mediaType": options?.["mediaType"] as any, "filename": options?.["filename"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogpostAttachments200),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentByTypeInBlogPost": (id, options) => HttpClientRequest.get(`/blogposts/${id}/custom-content`).pipe(
    HttpClientRequest.setUrlParams({ "type": options?.["type"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "body-format": options?.["body-format"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentByTypeInBlogPost200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostLabels": (id, options) => HttpClientRequest.get(`/blogposts/${id}/labels`).pipe(
    HttpClientRequest.setUrlParams({ "prefix": options?.["prefix"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPostLabels200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostLikeCount": (id) => HttpClientRequest.get(`/blogposts/${id}/likes/count`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPostLikeCount200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostLikeUsers": (id, options) => HttpClientRequest.get(`/blogposts/${id}/likes/users`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPostLikeUsers200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogpostContentProperties": (blogpostId, options) => HttpClientRequest.get(`/blogposts/${blogpostId}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogpostContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createBlogpostProperty": (blogpostId, options) => HttpClientRequest.post(`/blogposts/${blogpostId}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogpostContentPropertiesById": (blogpostId, propertyId) => HttpClientRequest.get(`/blogposts/${blogpostId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateBlogpostPropertyById": (blogpostId, propertyId, options) => HttpClientRequest.put(`/blogposts/${blogpostId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteBlogpostPropertyById": (blogpostId, propertyId) => HttpClientRequest.del(`/blogposts/${blogpostId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostOperations": (id) => HttpClientRequest.get(`/blogposts/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostVersions": (id, options) => HttpClientRequest.get(`/blogposts/${id}/versions`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPostVersions200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostVersionDetails": (blogpostId, versionNumber) => HttpClientRequest.get(`/blogposts/${blogpostId}/versions/${versionNumber}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DetailedVersion),
      orElse: unexpectedStatus
    }))
  ),
  "convertContentIdsToContentTypes": () => HttpClientRequest.post(`/content/convert-ids-to-types`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentIdToContentTypeResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentByType": (options) => HttpClientRequest.get(`/custom-content`).pipe(
    HttpClientRequest.setUrlParams({ "type": options?.["type"] as any, "id": options?.["id"] as any, "space-id": options?.["space-id"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "body-format": options?.["body-format"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentByType200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "createCustomContent": () => HttpClientRequest.post(`/custom-content`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateCustomContent201),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentById": (id, options) => HttpClientRequest.get(`/custom-content/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "version": options?.["version"] as any, "include-labels": options?.["include-labels"] as any, "include-properties": options?.["include-properties"] as any, "include-operations": options?.["include-operations"] as any, "include-versions": options?.["include-versions"] as any, "include-version": options?.["include-version"] as any, "include-collaborators": options?.["include-collaborators"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentById200),
      orElse: unexpectedStatus
    }))
  ),
  "updateCustomContent": (id) => HttpClientRequest.put(`/custom-content/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UpdateCustomContent200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "deleteCustomContent": (id, options) => HttpClientRequest.del(`/custom-content/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "purge": options?.["purge"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentAttachments": (id, options) => HttpClientRequest.get(`/custom-content/${id}/attachments`).pipe(
    HttpClientRequest.setUrlParams({ "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "status": options?.["status"] as any, "mediaType": options?.["mediaType"] as any, "filename": options?.["filename"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentAttachments200),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentComments": (id, options) => HttpClientRequest.get(`/custom-content/${id}/footer-comments`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentComments200),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentLabels": (id, options) => HttpClientRequest.get(`/custom-content/${id}/labels`).pipe(
    HttpClientRequest.setUrlParams({ "prefix": options?.["prefix"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentLabels200),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentOperations": (id) => HttpClientRequest.get(`/custom-content/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentContentProperties": (customContentId, options) => HttpClientRequest.get(`/custom-content/${customContentId}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createCustomContentProperty": (customContentId, options) => HttpClientRequest.post(`/custom-content/${customContentId}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentContentPropertiesById": (customContentId, propertyId) => HttpClientRequest.get(`/custom-content/${customContentId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateCustomContentPropertyById": (customContentId, propertyId, options) => HttpClientRequest.put(`/custom-content/${customContentId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteCustomContentPropertyById": (customContentId, propertyId) => HttpClientRequest.del(`/custom-content/${customContentId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getLabels": (options) => HttpClientRequest.get(`/labels`).pipe(
    HttpClientRequest.setUrlParams({ "label-id": options?.["label-id"] as any, "prefix": options?.["prefix"] as any, "cursor": options?.["cursor"] as any, "sort": options?.["sort"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetLabels200),
      orElse: unexpectedStatus
    }))
  ),
  "getLabelAttachments": (id, options) => HttpClientRequest.get(`/labels/${id}/attachments`).pipe(
    HttpClientRequest.setUrlParams({ "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetLabelAttachments200),
      orElse: unexpectedStatus
    }))
  ),
  "getLabelBlogPosts": (id, options) => HttpClientRequest.get(`/labels/${id}/blogposts`).pipe(
    HttpClientRequest.setUrlParams({ "space-id": options?.["space-id"] as any, "body-format": options?.["body-format"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetLabelBlogPosts200),
      orElse: unexpectedStatus
    }))
  ),
  "getLabelPages": (id, options) => HttpClientRequest.get(`/labels/${id}/pages`).pipe(
    HttpClientRequest.setUrlParams({ "space-id": options?.["space-id"] as any, "body-format": options?.["body-format"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetLabelPages200),
      orElse: unexpectedStatus
    }))
  ),
  "getPages": (options) => HttpClientRequest.get(`/pages`).pipe(
    HttpClientRequest.setUrlParams({ "id": options?.["id"] as any, "space-id": options?.["space-id"] as any, "sort": options?.["sort"] as any, "status": options?.["status"] as any, "title": options?.["title"] as any, "body-format": options?.["body-format"] as any, "subtype": options?.["subtype"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPages200),
      orElse: unexpectedStatus
    }))
  ),
  "createPage": (options) => HttpClientRequest.post(`/pages`).pipe(
    HttpClientRequest.setUrlParams({ "embedded": options?.["embedded"] as any, "private": options?.["private"] as any, "root-level": options?.["root-level"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreatePage200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getPageById": (id, options) => HttpClientRequest.get(`/pages/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "get-draft": options?.["get-draft"] as any, "status": options?.["status"] as any, "version": options?.["version"] as any, "include-labels": options?.["include-labels"] as any, "include-properties": options?.["include-properties"] as any, "include-operations": options?.["include-operations"] as any, "include-likes": options?.["include-likes"] as any, "include-versions": options?.["include-versions"] as any, "include-version": options?.["include-version"] as any, "include-favorited-by-current-user-status": options?.["include-favorited-by-current-user-status"] as any, "include-webresources": options?.["include-webresources"] as any, "include-collaborators": options?.["include-collaborators"] as any, "include-direct-children": options?.["include-direct-children"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageById200),
      orElse: unexpectedStatus
    }))
  ),
  "updatePage": (id) => HttpClientRequest.put(`/pages/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UpdatePage200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "deletePage": (id, options) => HttpClientRequest.del(`/pages/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "purge": options?.["purge"] as any, "draft": options?.["draft"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getPageAttachments": (id, options) => HttpClientRequest.get(`/pages/${id}/attachments`).pipe(
    HttpClientRequest.setUrlParams({ "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "status": options?.["status"] as any, "mediaType": options?.["mediaType"] as any, "filename": options?.["filename"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageAttachments200),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentByTypeInPage": (id, options) => HttpClientRequest.get(`/pages/${id}/custom-content`).pipe(
    HttpClientRequest.setUrlParams({ "type": options?.["type"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "body-format": options?.["body-format"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentByTypeInPage200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getPageLabels": (id, options) => HttpClientRequest.get(`/pages/${id}/labels`).pipe(
    HttpClientRequest.setUrlParams({ "prefix": options?.["prefix"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageLabels200),
      orElse: unexpectedStatus
    }))
  ),
  "getPageLikeCount": (id) => HttpClientRequest.get(`/pages/${id}/likes/count`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageLikeCount200),
      orElse: unexpectedStatus
    }))
  ),
  "getPageLikeUsers": (id, options) => HttpClientRequest.get(`/pages/${id}/likes/users`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageLikeUsers200),
      orElse: unexpectedStatus
    }))
  ),
  "getPageOperations": (id) => HttpClientRequest.get(`/pages/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getPageContentProperties": (pageId, options) => HttpClientRequest.get(`/pages/${pageId}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createPageProperty": (pageId, options) => HttpClientRequest.post(`/pages/${pageId}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getPageContentPropertiesById": (pageId, propertyId) => HttpClientRequest.get(`/pages/${pageId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updatePagePropertyById": (pageId, propertyId, options) => HttpClientRequest.put(`/pages/${pageId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deletePagePropertyById": (pageId, propertyId) => HttpClientRequest.del(`/pages/${pageId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "postRedactPage": (id) => HttpClientRequest.post(`/pages/${id}/redact`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RedactionResponse),
      "400": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "postRedactBlog": (id) => HttpClientRequest.post(`/blogposts/${id}/redact`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RedactionResponse),
      "400": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "updatePageTitle": (id) => HttpClientRequest.put(`/pages/${id}/title`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UpdatePageTitle200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getPageVersions": (id, options) => HttpClientRequest.get(`/pages/${id}/versions`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageVersions200),
      orElse: unexpectedStatus
    }))
  ),
  "createWhiteboard": (options) => HttpClientRequest.post(`/whiteboards`).pipe(
    HttpClientRequest.setUrlParams({ "private": options?.["private"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateWhiteboard200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getWhiteboardById": (id, options) => HttpClientRequest.get(`/whiteboards/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "include-collaborators": options?.["include-collaborators"] as any, "include-direct-children": options?.["include-direct-children"] as any, "include-operations": options?.["include-operations"] as any, "include-properties": options?.["include-properties"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetWhiteboardById200),
      orElse: unexpectedStatus
    }))
  ),
  "deleteWhiteboard": (id) => HttpClientRequest.del(`/whiteboards/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getWhiteboardContentProperties": (id, options) => HttpClientRequest.get(`/whiteboards/${id}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetWhiteboardContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createWhiteboardProperty": (id, options) => HttpClientRequest.post(`/whiteboards/${id}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getWhiteboardContentPropertiesById": (whiteboardId, propertyId) => HttpClientRequest.get(`/whiteboards/${whiteboardId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateWhiteboardPropertyById": (whiteboardId, propertyId, options) => HttpClientRequest.put(`/whiteboards/${whiteboardId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteWhiteboardPropertyById": (whiteboardId, propertyId) => HttpClientRequest.del(`/whiteboards/${whiteboardId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getWhiteboardOperations": (id) => HttpClientRequest.get(`/whiteboards/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getWhiteboardDirectChildren": (id, options) => HttpClientRequest.get(`/whiteboards/${id}/direct-children`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetWhiteboardDirectChildren200),
      orElse: unexpectedStatus
    }))
  ),
  "getWhiteboardDescendants": (id, options) => HttpClientRequest.get(`/whiteboards/${id}/descendants`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any, "depth": options?.["depth"] as any, "cursor": options?.["cursor"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetWhiteboardDescendants200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getWhiteboardAncestors": (id, options) => HttpClientRequest.get(`/whiteboards/${id}/ancestors`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetWhiteboardAncestors200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "createDatabase": (options) => HttpClientRequest.post(`/databases`).pipe(
    HttpClientRequest.setUrlParams({ "private": options?.["private"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateDatabase200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getDatabaseById": (id, options) => HttpClientRequest.get(`/databases/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "include-collaborators": options?.["include-collaborators"] as any, "include-direct-children": options?.["include-direct-children"] as any, "include-operations": options?.["include-operations"] as any, "include-properties": options?.["include-properties"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetDatabaseById200),
      orElse: unexpectedStatus
    }))
  ),
  "deleteDatabase": (id) => HttpClientRequest.del(`/databases/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getDatabaseContentProperties": (id, options) => HttpClientRequest.get(`/databases/${id}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetDatabaseContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createDatabaseProperty": (id, options) => HttpClientRequest.post(`/databases/${id}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getDatabaseContentPropertiesById": (databaseId, propertyId) => HttpClientRequest.get(`/databases/${databaseId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateDatabasePropertyById": (databaseId, propertyId, options) => HttpClientRequest.put(`/databases/${databaseId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteDatabasePropertyById": (databaseId, propertyId) => HttpClientRequest.del(`/databases/${databaseId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getDatabaseOperations": (id) => HttpClientRequest.get(`/databases/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getDatabaseDirectChildren": (id, options) => HttpClientRequest.get(`/databases/${id}/direct-children`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetDatabaseDirectChildren200),
      orElse: unexpectedStatus
    }))
  ),
  "getDatabaseDescendants": (id, options) => HttpClientRequest.get(`/databases/${id}/descendants`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any, "depth": options?.["depth"] as any, "cursor": options?.["cursor"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetDatabaseDescendants200),
      orElse: unexpectedStatus
    }))
  ),
  "getDatabaseAncestors": (id, options) => HttpClientRequest.get(`/databases/${id}/ancestors`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetDatabaseAncestors200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "createSmartLink": () => HttpClientRequest.post(`/embeds`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateSmartLink200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getSmartLinkById": (id, options) => HttpClientRequest.get(`/embeds/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "include-collaborators": options?.["include-collaborators"] as any, "include-direct-children": options?.["include-direct-children"] as any, "include-operations": options?.["include-operations"] as any, "include-properties": options?.["include-properties"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSmartLinkById200),
      orElse: unexpectedStatus
    }))
  ),
  "deleteSmartLink": (id) => HttpClientRequest.del(`/embeds/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getSmartLinkContentProperties": (id, options) => HttpClientRequest.get(`/embeds/${id}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSmartLinkContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createSmartLinkProperty": (id, options) => HttpClientRequest.post(`/embeds/${id}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getSmartLinkContentPropertiesById": (embedId, propertyId) => HttpClientRequest.get(`/embeds/${embedId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateSmartLinkPropertyById": (embedId, propertyId, options) => HttpClientRequest.put(`/embeds/${embedId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteSmartLinkPropertyById": (embedId, propertyId) => HttpClientRequest.del(`/embeds/${embedId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getSmartLinkOperations": (id) => HttpClientRequest.get(`/embeds/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getSmartLinkDirectChildren": (id, options) => HttpClientRequest.get(`/embeds/${id}/direct-children`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSmartLinkDirectChildren200),
      orElse: unexpectedStatus
    }))
  ),
  "getSmartLinkDescendants": (id, options) => HttpClientRequest.get(`/embeds/${id}/descendants`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any, "depth": options?.["depth"] as any, "cursor": options?.["cursor"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSmartLinkDescendants200),
      orElse: unexpectedStatus
    }))
  ),
  "getSmartLinkAncestors": (id, options) => HttpClientRequest.get(`/embeds/${id}/ancestors`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSmartLinkAncestors200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "createFolder": () => HttpClientRequest.post(`/folders`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateFolder200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getFolderById": (id, options) => HttpClientRequest.get(`/folders/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "include-collaborators": options?.["include-collaborators"] as any, "include-direct-children": options?.["include-direct-children"] as any, "include-operations": options?.["include-operations"] as any, "include-properties": options?.["include-properties"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFolderById200),
      orElse: unexpectedStatus
    }))
  ),
  "deleteFolder": (id) => HttpClientRequest.del(`/folders/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getFolderContentProperties": (id, options) => HttpClientRequest.get(`/folders/${id}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFolderContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createFolderProperty": (id, options) => HttpClientRequest.post(`/folders/${id}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getFolderContentPropertiesById": (folderId, propertyId) => HttpClientRequest.get(`/folders/${folderId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateFolderPropertyById": (folderId, propertyId, options) => HttpClientRequest.put(`/folders/${folderId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteFolderPropertyById": (folderId, propertyId) => HttpClientRequest.del(`/folders/${folderId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getFolderOperations": (id) => HttpClientRequest.get(`/folders/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getFolderDirectChildren": (id, options) => HttpClientRequest.get(`/folders/${id}/direct-children`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFolderDirectChildren200),
      orElse: unexpectedStatus
    }))
  ),
  "getFolderDescendants": (id, options) => HttpClientRequest.get(`/folders/${id}/descendants`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any, "depth": options?.["depth"] as any, "cursor": options?.["cursor"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFolderDescendants200),
      orElse: unexpectedStatus
    }))
  ),
  "getFolderAncestors": (id, options) => HttpClientRequest.get(`/folders/${id}/ancestors`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFolderAncestors200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getPageVersionDetails": (pageId, versionNumber) => HttpClientRequest.get(`/pages/${pageId}/versions/${versionNumber}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DetailedVersion),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentVersions": (customContentId, options) => HttpClientRequest.get(`/custom-content/${customContentId}/versions`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentVersions200),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentVersionDetails": (customContentId, versionNumber) => HttpClientRequest.get(`/custom-content/${customContentId}/versions/${versionNumber}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DetailedVersion),
      orElse: unexpectedStatus
    }))
  ),
  "getSpaces": (options) => HttpClientRequest.get(`/spaces`).pipe(
    HttpClientRequest.setUrlParams({ "ids": options?.["ids"] as any, "keys": options?.["keys"] as any, "type": options?.["type"] as any, "status": options?.["status"] as any, "labels": options?.["labels"] as any, "favorited-by": options?.["favorited-by"] as any, "not-favorited-by": options?.["not-favorited-by"] as any, "sort": options?.["sort"] as any, "description-format": options?.["description-format"] as any, "include-icon": options?.["include-icon"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaces200),
      orElse: unexpectedStatus
    }))
  ),
  "createSpace": () => HttpClientRequest.post(`/spaces`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateSpace201),
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceById": (id, options) => HttpClientRequest.get(`/spaces/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "description-format": options?.["description-format"] as any, "include-icon": options?.["include-icon"] as any, "include-operations": options?.["include-operations"] as any, "include-properties": options?.["include-properties"] as any, "include-permissions": options?.["include-permissions"] as any, "include-role-assignments": options?.["include-role-assignments"] as any, "include-labels": options?.["include-labels"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaceById200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostsInSpace": (id, options) => HttpClientRequest.get(`/spaces/${id}/blogposts`).pipe(
    HttpClientRequest.setUrlParams({ "sort": options?.["sort"] as any, "status": options?.["status"] as any, "title": options?.["title"] as any, "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPostsInSpace200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceLabels": (id, options) => HttpClientRequest.get(`/spaces/${id}/labels`).pipe(
    HttpClientRequest.setUrlParams({ "prefix": options?.["prefix"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaceLabels200),
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceContentLabels": (id, options) => HttpClientRequest.get(`/spaces/${id}/content/labels`).pipe(
    HttpClientRequest.setUrlParams({ "prefix": options?.["prefix"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaceContentLabels200),
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentByTypeInSpace": (id, options) => HttpClientRequest.get(`/spaces/${id}/custom-content`).pipe(
    HttpClientRequest.setUrlParams({ "type": options?.["type"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "body-format": options?.["body-format"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentByTypeInSpace200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceOperations": (id) => HttpClientRequest.get(`/spaces/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getPagesInSpace": (id, options) => HttpClientRequest.get(`/spaces/${id}/pages`).pipe(
    HttpClientRequest.setUrlParams({ "depth": options?.["depth"] as any, "sort": options?.["sort"] as any, "status": options?.["status"] as any, "title": options?.["title"] as any, "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPagesInSpace200),
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceProperties": (spaceId, options) => HttpClientRequest.get(`/spaces/${spaceId}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaceProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createSpaceProperty": (spaceId, options) => HttpClientRequest.post(`/spaces/${spaceId}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpaceProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getSpacePropertyById": (spaceId, propertyId) => HttpClientRequest.get(`/spaces/${spaceId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpaceProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateSpacePropertyById": (spaceId, propertyId, options) => HttpClientRequest.put(`/spaces/${spaceId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpaceProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteSpacePropertyById": (spaceId, propertyId) => HttpClientRequest.del(`/spaces/${spaceId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getSpacePermissionsAssignments": (id, options) => HttpClientRequest.get(`/spaces/${id}/permissions`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpacePermissionsAssignments200),
      orElse: unexpectedStatus
    }))
  ),
  "getAvailableSpacePermissions": (options) => HttpClientRequest.get(`/space-permissions`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAvailableSpacePermissions200),
      orElse: unexpectedStatus
    }))
  ),
  "getAvailableSpaceRoles": (options) => HttpClientRequest.get(`/space-roles`).pipe(
    HttpClientRequest.setUrlParams({ "space-id": options?.["space-id"] as any, "role-type": options?.["role-type"] as any, "principal-id": options?.["principal-id"] as any, "principal-type": options?.["principal-type"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAvailableSpaceRoles200),
      orElse: unexpectedStatus
    }))
  ),
  "createSpaceRole": (options) => HttpClientRequest.post(`/space-roles`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpaceRole),
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceRolesById": (id) => HttpClientRequest.get(`/space-roles/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaceRolesById200),
      orElse: unexpectedStatus
    }))
  ),
  "updateSpaceRole": (id, options) => HttpClientRequest.put(`/space-roles/${id}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UpdateSpaceRoleResponse),
      orElse: unexpectedStatus
    }))
  ),
  "deleteSpaceRole": (id) => HttpClientRequest.del(`/space-roles/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DeleteSpaceRoleResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceRoleMode": () => HttpClientRequest.get(`/space-role-mode`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaceRoleMode200),
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceRoleAssignments": (id, options) => HttpClientRequest.get(`/spaces/${id}/role-assignments`).pipe(
    HttpClientRequest.setUrlParams({ "role-id": options?.["role-id"] as any, "role-type": options?.["role-type"] as any, "principal-id": options?.["principal-id"] as any, "principal-type": options?.["principal-type"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaceRoleAssignments200),
      orElse: unexpectedStatus
    }))
  ),
  "setSpaceRoleAssignments": (id) => HttpClientRequest.post(`/spaces/${id}/role-assignments`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SetSpaceRoleAssignments200),
      orElse: unexpectedStatus
    }))
  ),
  "getPageFooterComments": (id, options) => HttpClientRequest.get(`/pages/${id}/footer-comments`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "status": options?.["status"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageFooterComments200),
      orElse: unexpectedStatus
    }))
  ),
  "getPageInlineComments": (id, options) => HttpClientRequest.get(`/pages/${id}/inline-comments`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "status": options?.["status"] as any, "resolution-status": options?.["resolution-status"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageInlineComments200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostFooterComments": (id, options) => HttpClientRequest.get(`/blogposts/${id}/footer-comments`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "status": options?.["status"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPostFooterComments200),
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostInlineComments": (id, options) => HttpClientRequest.get(`/blogposts/${id}/inline-comments`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "status": options?.["status"] as any, "resolution-status": options?.["resolution-status"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetBlogPostInlineComments200),
      orElse: unexpectedStatus
    }))
  ),
  "getFooterComments": (options) => HttpClientRequest.get(`/footer-comments`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFooterComments200),
      orElse: unexpectedStatus
    }))
  ),
  "createFooterComment": (options) => HttpClientRequest.post(`/footer-comments`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateFooterComment201),
      orElse: unexpectedStatus
    }))
  ),
  "getFooterCommentById": (commentId, options) => HttpClientRequest.get(`/footer-comments/${commentId}`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "version": options?.["version"] as any, "include-properties": options?.["include-properties"] as any, "include-operations": options?.["include-operations"] as any, "include-likes": options?.["include-likes"] as any, "include-versions": options?.["include-versions"] as any, "include-version": options?.["include-version"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFooterCommentById200),
      orElse: unexpectedStatus
    }))
  ),
  "updateFooterComment": (commentId, options) => HttpClientRequest.put(`/footer-comments/${commentId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(FooterCommentModel),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "deleteFooterComment": (commentId) => HttpClientRequest.del(`/footer-comments/${commentId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getFooterCommentChildren": (id, options) => HttpClientRequest.get(`/footer-comments/${id}/children`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFooterCommentChildren200),
      orElse: unexpectedStatus
    }))
  ),
  "getFooterLikeCount": (id) => HttpClientRequest.get(`/footer-comments/${id}/likes/count`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFooterLikeCount200),
      orElse: unexpectedStatus
    }))
  ),
  "getFooterLikeUsers": (id, options) => HttpClientRequest.get(`/footer-comments/${id}/likes/users`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFooterLikeUsers200),
      orElse: unexpectedStatus
    }))
  ),
  "getFooterCommentOperations": (id) => HttpClientRequest.get(`/footer-comments/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getFooterCommentVersions": (id, options) => HttpClientRequest.get(`/footer-comments/${id}/versions`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetFooterCommentVersions200),
      orElse: unexpectedStatus
    }))
  ),
  "getFooterCommentVersionDetails": (id, versionNumber) => HttpClientRequest.get(`/footer-comments/${id}/versions/${versionNumber}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DetailedVersion),
      orElse: unexpectedStatus
    }))
  ),
  "getInlineComments": (options) => HttpClientRequest.get(`/inline-comments`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetInlineComments200),
      orElse: unexpectedStatus
    }))
  ),
  "createInlineComment": (options) => HttpClientRequest.post(`/inline-comments`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateInlineComment201),
      orElse: unexpectedStatus
    }))
  ),
  "getInlineCommentById": (commentId, options) => HttpClientRequest.get(`/inline-comments/${commentId}`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "version": options?.["version"] as any, "include-properties": options?.["include-properties"] as any, "include-operations": options?.["include-operations"] as any, "include-likes": options?.["include-likes"] as any, "include-versions": options?.["include-versions"] as any, "include-version": options?.["include-version"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetInlineCommentById200),
      orElse: unexpectedStatus
    }))
  ),
  "updateInlineComment": (commentId, options) => HttpClientRequest.put(`/inline-comments/${commentId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UpdateInlineComment200),
      orElse: unexpectedStatus
    }))
  ),
  "deleteInlineComment": (commentId) => HttpClientRequest.del(`/inline-comments/${commentId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getInlineCommentChildren": (id, options) => HttpClientRequest.get(`/inline-comments/${id}/children`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetInlineCommentChildren200),
      orElse: unexpectedStatus
    }))
  ),
  "getInlineLikeCount": (id) => HttpClientRequest.get(`/inline-comments/${id}/likes/count`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetInlineLikeCount200),
      orElse: unexpectedStatus
    }))
  ),
  "getInlineLikeUsers": (id, options) => HttpClientRequest.get(`/inline-comments/${id}/likes/users`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetInlineLikeUsers200),
      orElse: unexpectedStatus
    }))
  ),
  "getInlineCommentOperations": (id) => HttpClientRequest.get(`/inline-comments/${id}/operations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermittedOperationsResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getInlineCommentVersions": (id, options) => HttpClientRequest.get(`/inline-comments/${id}/versions`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetInlineCommentVersions200),
      orElse: unexpectedStatus
    }))
  ),
  "getInlineCommentVersionDetails": (id, versionNumber) => HttpClientRequest.get(`/inline-comments/${id}/versions/${versionNumber}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DetailedVersion),
      orElse: unexpectedStatus
    }))
  ),
  "getCommentContentProperties": (commentId, options) => HttpClientRequest.get(`/comments/${commentId}/properties`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCommentContentProperties200),
      orElse: unexpectedStatus
    }))
  ),
  "createCommentProperty": (commentId, options) => HttpClientRequest.post(`/comments/${commentId}/properties`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "getCommentContentPropertiesById": (commentId, propertyId) => HttpClientRequest.get(`/comments/${commentId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateCommentPropertyById": (commentId, propertyId, options) => HttpClientRequest.put(`/comments/${commentId}/properties/${propertyId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentProperty),
      orElse: unexpectedStatus
    }))
  ),
  "deleteCommentPropertyById": (commentId, propertyId) => HttpClientRequest.del(`/comments/${commentId}/properties/${propertyId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getTasks": (options) => HttpClientRequest.get(`/tasks`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any, "include-blank-tasks": options?.["include-blank-tasks"] as any, "status": options?.["status"] as any, "task-id": options?.["task-id"] as any, "space-id": options?.["space-id"] as any, "page-id": options?.["page-id"] as any, "blogpost-id": options?.["blogpost-id"] as any, "created-by": options?.["created-by"] as any, "assigned-to": options?.["assigned-to"] as any, "completed-by": options?.["completed-by"] as any, "created-at-from": options?.["created-at-from"] as any, "created-at-to": options?.["created-at-to"] as any, "due-at-from": options?.["due-at-from"] as any, "due-at-to": options?.["due-at-to"] as any, "completed-at-from": options?.["completed-at-from"] as any, "completed-at-to": options?.["completed-at-to"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetTasks200),
      orElse: unexpectedStatus
    }))
  ),
  "getTaskById": (id, options) => HttpClientRequest.get(`/tasks/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Task),
      orElse: unexpectedStatus
    }))
  ),
  "updateTask": (id, options) => HttpClientRequest.put(`/tasks/${id}`).pipe(
    HttpClientRequest.setUrlParams({ "body-format": options?.["body-format"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Task),
      orElse: unexpectedStatus
    }))
  ),
  "getChildPages": (id, options) => HttpClientRequest.get(`/pages/${id}/children`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetChildPages200),
      orElse: unexpectedStatus
    }))
  ),
  "getChildCustomContent": (id, options) => HttpClientRequest.get(`/custom-content/${id}/children`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetChildCustomContent200),
      orElse: unexpectedStatus
    }))
  ),
  "getPageDirectChildren": (id, options) => HttpClientRequest.get(`/pages/${id}/direct-children`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any, "sort": options?.["sort"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageDirectChildren200),
      orElse: unexpectedStatus
    }))
  ),
  "getPageAncestors": (id, options) => HttpClientRequest.get(`/pages/${id}/ancestors`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageAncestors200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getPageDescendants": (id, options) => HttpClientRequest.get(`/pages/${id}/descendants`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.["limit"] as any, "depth": options?.["depth"] as any, "cursor": options?.["cursor"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetPageDescendants200),
      orElse: unexpectedStatus
    }))
  ),
  "createBulkUserLookup": () => HttpClientRequest.post(`/users-bulk`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CreateBulkUserLookup200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "checkAccessByEmail": () => HttpClientRequest.post(`/user/access/check-access-by-email`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CheckAccessByEmail200),
      "404": () => Effect.void,
      "503": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "inviteByEmail": () => HttpClientRequest.post(`/user/access/invite-by-email`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "404": () => Effect.void,
      "503": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getDataPolicyMetadata": () => HttpClientRequest.get(`/data-policies/metadata`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DataPolicyMetadata),
      "400": () => Effect.void,
      "401": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getDataPolicySpaces": (options) => HttpClientRequest.get(`/data-policies/spaces`).pipe(
    HttpClientRequest.setUrlParams({ "ids": options?.["ids"] as any, "keys": options?.["keys"] as any, "sort": options?.["sort"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetDataPolicySpaces200),
      orElse: unexpectedStatus
    }))
  ),
  "getClassificationLevels": () => HttpClientRequest.get(`/classification-levels`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetClassificationLevels200),
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceDefaultClassificationLevel": (id) => HttpClientRequest.get(`/spaces/${id}/classification-level/default`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ClassificationLevel),
      orElse: unexpectedStatus
    }))
  ),
  "putSpaceDefaultClassificationLevel": (id) => HttpClientRequest.put(`/spaces/${id}/classification-level/default`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "deleteSpaceDefaultClassificationLevel": (id) => HttpClientRequest.del(`/spaces/${id}/classification-level/default`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getPageClassificationLevel": (id, options) => HttpClientRequest.get(`/pages/${id}/classification-level`).pipe(
    HttpClientRequest.setUrlParams({ "status": options?.["status"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ClassificationLevel),
      orElse: unexpectedStatus
    }))
  ),
  "putPageClassificationLevel": (id) => HttpClientRequest.put(`/pages/${id}/classification-level`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "postPageClassificationLevel": (id) => HttpClientRequest.post(`/pages/${id}/classification-level/reset`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getBlogPostClassificationLevel": (id, options) => HttpClientRequest.get(`/blogposts/${id}/classification-level`).pipe(
    HttpClientRequest.setUrlParams({ "status": options?.["status"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ClassificationLevel),
      orElse: unexpectedStatus
    }))
  ),
  "putBlogPostClassificationLevel": (id) => HttpClientRequest.put(`/blogposts/${id}/classification-level`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "postBlogPostClassificationLevel": (id) => HttpClientRequest.post(`/blogposts/${id}/classification-level/reset`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getWhiteboardClassificationLevel": (id) => HttpClientRequest.get(`/whiteboards/${id}/classification-level`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ClassificationLevel),
      orElse: unexpectedStatus
    }))
  ),
  "putWhiteboardClassificationLevel": (id) => HttpClientRequest.put(`/whiteboards/${id}/classification-level`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "postWhiteboardClassificationLevel": (id) => HttpClientRequest.post(`/whiteboards/${id}/classification-level/reset`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getDatabaseClassificationLevel": (id) => HttpClientRequest.get(`/databases/${id}/classification-level`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ClassificationLevel),
      orElse: unexpectedStatus
    }))
  ),
  "putDatabaseClassificationLevel": (id) => HttpClientRequest.put(`/databases/${id}/classification-level`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "postDatabaseClassificationLevel": (id) => HttpClientRequest.post(`/databases/${id}/classification-level/reset`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getForgeAppProperties": (options) => HttpClientRequest.get(`/app/properties`).pipe(
    HttpClientRequest.setUrlParams({ "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetForgeAppProperties200),
      "401": () => Effect.void,
      "403": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getForgeAppProperty": (propertyKey) => HttpClientRequest.get(`/app/properties/${propertyKey}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetForgeAppProperty200),
      "400": () => Effect.void,
      "401": () => Effect.void,
      "403": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "putForgeAppProperty": (propertyKey, options) => HttpClientRequest.put(`/app/properties/${propertyKey}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "200": () => Effect.void,
      "201": () => Effect.void,
      "400": () => Effect.void,
      "401": () => Effect.void,
      "403": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "deleteForgeAppProperty": (propertyKey) => HttpClientRequest.del(`/app/properties/${propertyKey}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      "400": () => Effect.void,
      "401": () => Effect.void,
      "403": () => Effect.void,
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface ConfluenceV2Client {
  readonly httpClient: HttpClient.HttpClient
  /**
* Returns information about the admin key if one is currently enabled for the calling user within the site.
* 
* **[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
* User must be an organization or site admin.
*/
readonly "getAdminKey": () => Effect.Effect<typeof AdminKeyResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Enables admin key access for the calling user within the site. If an admin key already exists for the user, a new one will be issued with an updated expiration time.
* 
* **Note:** The `durationInMinutes` field within the request body is optional. If the request body is empty or if the `durationInMinutes` is set to 0 minutes, a new admin key will be issued to the calling user with a default duration of 10 minutes.
* 
* **[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
* User must be an organization or site admin.
*/
readonly "enableAdminKey": () => Effect.Effect<typeof AdminKeyResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Disables admin key access for the calling user within the site.
* 
* **[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
* User must be an organization or site admin.
*/
readonly "disableAdminKey": () => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all attachments. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the container of the attachment.
*/
readonly "getAttachments": (options?: typeof GetAttachmentsParams.Encoded | undefined) => Effect.Effect<typeof GetAttachments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific attachment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the attachment's container.
*/
readonly "getAttachmentById": (id: string, options?: typeof GetAttachmentByIdParams.Encoded | undefined) => Effect.Effect<typeof GetAttachmentById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete an attachment by id.
* 
* Deleting an attachment moves the attachment to the trash, where it can be restored later. To permanently delete an attachment (or "purge" it),
* the endpoint must be called on a **trashed** attachment with the following param `purge=true`.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the container of the attachment.
* Permission to delete attachments in the space.
* Permission to administer the space (if attempting to purge).
*/
readonly "deleteAttachment": (id: string, options?: typeof DeleteAttachmentParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the labels of specific attachment. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the parent content of the attachment and its corresponding space.
* Only labels that the user has permission to view will be returned.
*/
readonly "getAttachmentLabels": (id: string, options?: typeof GetAttachmentLabelsParams.Encoded | undefined) => Effect.Effect<typeof GetAttachmentLabels200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific attachment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the parent content of the attachment and its corresponding space.
*/
readonly "getAttachmentOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves all Content Properties tied to a specified attachment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the attachment.
*/
readonly "getAttachmentContentProperties": (attachmentId: string, options?: typeof GetAttachmentContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetAttachmentContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content property for an attachment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the attachment.
*/
readonly "createAttachmentProperty": (attachmentId: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified attachment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the attachment.
*/
readonly "getAttachmentContentPropertiesById": (attachmentId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for attachment by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the attachment.
*/
readonly "updateAttachmentPropertyById": (attachmentId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for an attachment by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to attachment the page.
*/
readonly "deleteAttachmentPropertyById": (attachmentId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the versions of specific attachment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the attachment and its corresponding space.
*/
readonly "getAttachmentVersions": (id: string, options?: typeof GetAttachmentVersionsParams.Encoded | undefined) => Effect.Effect<typeof GetAttachmentVersions200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves version details for the specified attachment and version number.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the attachment.
*/
readonly "getAttachmentVersionDetails": (attachmentId: string, versionNumber: string) => Effect.Effect<typeof DetailedVersion.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the comments of the specific attachment.
* The number of results is limited by the `limit` parameter and additional results (if available) will be available through
* the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the attachment and its corresponding containers.
*/
readonly "getAttachmentComments": (id: string, options?: typeof GetAttachmentCommentsParams.Encoded | undefined) => Effect.Effect<typeof GetAttachmentComments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all blog posts. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only blog posts that the user has permission to view will be returned.
*/
readonly "getBlogPosts": (options?: typeof GetBlogPostsParams.Encoded | undefined) => Effect.Effect<typeof GetBlogPosts200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new blog post in the space specified by the spaceId.
* 
* By default this will create the blog post as a non-draft, unless the status is specified as draft.
* If creating a non-draft, the title must not be empty.
* 
* Currently only supports the storage representation specified in the body.representation enums below
*/
readonly "createBlogPost": (options?: typeof CreateBlogPostParams.Encoded | undefined) => Effect.Effect<typeof CreateBlogPost200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific blog post.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the blog post and its corresponding space.
*/
readonly "getBlogPostById": (id: string, options?: typeof GetBlogPostByIdParams.Encoded | undefined) => Effect.Effect<typeof GetBlogPostById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a blog post by id.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the blog post and its corresponding space. Permission to update blog posts in the space.
*/
readonly "updateBlogPost": (id: string) => Effect.Effect<typeof UpdateBlogPost200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a blog post by id.
* 
* By default this will delete blog posts that are non-drafts. To delete a blog post that is a draft, the endpoint must be called on a 
* draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.
* 
* Deleting a blog post that is not a draft moves the blog post to the trash, where it can be restored later.
* To permanently delete a blog post (or "purge" it), the endpoint must be called on a **trashed** blog post with the following param `purge=true`.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the blog post and its corresponding space.
* Permission to delete blog posts in the space.
* Permission to administer the space (if attempting to purge).
*/
readonly "deleteBlogPost": (id: string, options?: typeof DeleteBlogPostParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the attachments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the blog post and its corresponding space.
*/
readonly "getBlogpostAttachments": (id: string, options?: typeof GetBlogpostAttachmentsParams.Encoded | undefined) => Effect.Effect<typeof GetBlogpostAttachments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all custom content for a given type within a given blogpost. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content, the container of the custom content (blog post), and the corresponding space.
*/
readonly "getCustomContentByTypeInBlogPost": (id: string, options: typeof GetCustomContentByTypeInBlogPostParams.Encoded) => Effect.Effect<typeof GetCustomContentByTypeInBlogPost200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the labels of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the blog post and its corresponding space.
* Only labels that the user has permission to view will be returned.
*/
readonly "getBlogPostLabels": (id: string, options?: typeof GetBlogPostLabelsParams.Encoded | undefined) => Effect.Effect<typeof GetBlogPostLabels200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the count of likes of specific blog post.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the blog post and its corresponding space.
*/
readonly "getBlogPostLikeCount": (id: string) => Effect.Effect<typeof GetBlogPostLikeCount200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the account IDs of likes of specific blog post.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the blog post and its corresponding space.
*/
readonly "getBlogPostLikeUsers": (id: string, options?: typeof GetBlogPostLikeUsersParams.Encoded | undefined) => Effect.Effect<typeof GetBlogPostLikeUsers200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves all Content Properties tied to a specified blog post.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the blog post.
*/
readonly "getBlogpostContentProperties": (blogpostId: string, options?: typeof GetBlogpostContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetBlogpostContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new property for a blogpost.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the blog post.
*/
readonly "createBlogpostProperty": (blogpostId: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified blog post.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the blog post.
*/
readonly "getBlogpostContentPropertiesById": (blogpostId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for blog post by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the blog post.
*/
readonly "updateBlogpostPropertyById": (blogpostId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for a blogpost by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the blog post.
*/
readonly "deleteBlogpostPropertyById": (blogpostId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific blog post.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the parent content of the blog post and its corresponding space.
*/
readonly "getBlogPostOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the versions of specific blog post. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the blog post and its corresponding space.
*/
readonly "getBlogPostVersions": (id: string, options?: typeof GetBlogPostVersionsParams.Encoded | undefined) => Effect.Effect<typeof GetBlogPostVersions200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves version details for the specified blog post and version number.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the blog post.
*/
readonly "getBlogPostVersionDetails": (blogpostId: string, versionNumber: string) => Effect.Effect<typeof DetailedVersion.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Converts a list of content ids into their associated content types. This is useful for users migrating from v1 to v2
* who may have stored just content ids without their associated type. This will return types as they should be used in v2.
* Notably, this will return `inline-comment` for inline comments and `footer-comment` for footer comments, which is distinct from them
* both being represented by `comment` in v1.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the requested content. Any content that the user does not have permission to view or does not exist will map to `null` in the response.
*/
readonly "convertContentIdsToContentTypes": () => Effect.Effect<typeof ContentIdToContentTypeResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all custom content for a given type. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
*/
readonly "getCustomContentByType": (options: typeof GetCustomContentByTypeParams.Encoded) => Effect.Effect<typeof GetCustomContentByType200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new custom content in the given space, page, blogpost or other custom content.
* 
* Only one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is required in the request body.
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space. Permission to create custom content in the space.
*/
readonly "createCustomContent": () => Effect.Effect<typeof CreateCustomContent201.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific piece of custom content. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
*/
readonly "getCustomContentById": (id: string, options?: typeof GetCustomContentByIdParams.Encoded | undefined) => Effect.Effect<typeof GetCustomContentById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a custom content by id.
* At most one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is allowed in the request body.
* Note that if `spaceId` is specified, it must be the same as the `spaceId` used for creating the custom content
* as moving custom content to a different space is not supported.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space. Permission to update custom content in the space.
*/
readonly "updateCustomContent": (id: string) => Effect.Effect<typeof UpdateCustomContent200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a custom content by id.
* 
* Deleting a custom content will either move it to the trash or permanently delete it (purge it), depending on the apiSupport.
* To permanently delete a **trashed** custom content, the endpoint must be called with the following param `purge=true`.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space.
* Permission to delete custom content in the space.
* Permission to administer the space (if attempting to purge).
*/
readonly "deleteCustomContent": (id: string, options?: typeof DeleteCustomContentParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the attachments of specific custom content. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the custom content and its corresponding space.
*/
readonly "getCustomContentAttachments": (id: string, options?: typeof GetCustomContentAttachmentsParams.Encoded | undefined) => Effect.Effect<typeof GetCustomContentAttachments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the comments of the specific custom content.
* The number of results is limited by the `limit` parameter and additional results (if available) will be available through
* the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content and its corresponding containers.
*/
readonly "getCustomContentComments": (id: string, options?: typeof GetCustomContentCommentsParams.Encoded | undefined) => Effect.Effect<typeof GetCustomContentComments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the labels for a specific piece of custom content. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content and its corresponding space.
* Only labels that the user has permission to view will be returned.
*/
readonly "getCustomContentLabels": (id: string, options?: typeof GetCustomContentLabelsParams.Encoded | undefined) => Effect.Effect<typeof GetCustomContentLabels200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific custom content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the parent content of the custom content and its corresponding space.
*/
readonly "getCustomContentOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves Content Properties tied to a specified custom content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content.
*/
readonly "getCustomContentContentProperties": (customContentId: string, options?: typeof GetCustomContentContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetCustomContentContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content property for a piece of custom content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the custom content.
*/
readonly "createCustomContentProperty": (customContentId: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified custom content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page.
*/
readonly "getCustomContentContentPropertiesById": (customContentId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for a piece of custom content by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the custom content.
*/
readonly "updateCustomContentPropertyById": (customContentId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for a piece of custom content by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the custom content.
*/
readonly "deleteCustomContentPropertyById": (customContentId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all labels. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only labels that the user has permission to view will be returned.
*/
readonly "getLabels": (options?: typeof GetLabelsParams.Encoded | undefined) => Effect.Effect<typeof GetLabels200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the attachments of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the attachment and its corresponding space.
*/
readonly "getLabelAttachments": (id: string, options?: typeof GetLabelAttachmentsParams.Encoded | undefined) => Effect.Effect<typeof GetLabelAttachments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the blogposts of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getLabelBlogPosts": (id: string, options?: typeof GetLabelBlogPostsParams.Encoded | undefined) => Effect.Effect<typeof GetLabelBlogPosts200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getLabelPages": (id: string, options?: typeof GetLabelPagesParams.Encoded | undefined) => Effect.Effect<typeof GetLabelPages200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only pages that the user has permission to view will be returned.
*/
readonly "getPages": (options?: typeof GetPagesParams.Encoded | undefined) => Effect.Effect<typeof GetPages200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a page in the space.
* 
* Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the corresponding space. Permission to create a page in the space.
*/
readonly "createPage": (options?: typeof CreatePageParams.Encoded | undefined) => Effect.Effect<typeof CreatePage200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page and its corresponding space.
*/
readonly "getPageById": (id: string, options?: typeof GetPageByIdParams.Encoded | undefined) => Effect.Effect<typeof GetPageById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a page by id.
* 
* When the "current" version is updated, the provided body content is considered as the latest version. This latest body content
* will be attempted to be merged into the draft version through a content reconciliation algorithm. If two versions are significantly diverged, 
* the latest provided content may entirely override what was previously in the draft. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page and its corresponding space. Permission to update pages in the space.
*/
readonly "updatePage": (id: string) => Effect.Effect<typeof UpdatePage200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a page by id.
* 
* By default this will delete pages that are non-drafts. To delete a page that is a draft, the endpoint must be called on a 
* draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.
* 
* Deleting a page moves the page to the trash, where it can be restored later. To permanently delete a page (or "purge" it),
* the endpoint must be called on a **trashed** page with the following param `purge=true`.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page and its corresponding space.
* Permission to delete pages in the space.
* Permission to administer the space (if attempting to purge).
*/
readonly "deletePage": (id: string, options?: typeof DeletePageParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the attachments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getPageAttachments": (id: string, options?: typeof GetPageAttachmentsParams.Encoded | undefined) => Effect.Effect<typeof GetPageAttachments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all custom content for a given type within a given page. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content, the container of the custom content (page), and the corresponding space.
*/
readonly "getCustomContentByTypeInPage": (id: string, options: typeof GetCustomContentByTypeInPageParams.Encoded) => Effect.Effect<typeof GetCustomContentByTypeInPage200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the labels of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
* Only labels that the user has permission to view will be returned.
*/
readonly "getPageLabels": (id: string, options?: typeof GetPageLabelsParams.Encoded | undefined) => Effect.Effect<typeof GetPageLabels200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the count of likes of specific page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getPageLikeCount": (id: string) => Effect.Effect<typeof GetPageLikeCount200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the account IDs of likes of specific page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getPageLikeUsers": (id: string, options?: typeof GetPageLikeUsersParams.Encoded | undefined) => Effect.Effect<typeof GetPageLikeUsers200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the parent content of the page and its corresponding space.
*/
readonly "getPageOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves Content Properties tied to a specified page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page.
*/
readonly "getPageContentProperties": (pageId: string, options?: typeof GetPageContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetPageContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content property for a page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the page.
*/
readonly "createPageProperty": (pageId: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page.
*/
readonly "getPageContentPropertiesById": (pageId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for a page by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the page.
*/
readonly "updatePagePropertyById": (pageId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for a page by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the page.
*/
readonly "deletePagePropertyById": (pageId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Redacts sensitive content in a Confluence page by replacing specified text ranges with redaction markers. 
* Each redaction in the response includes a unique UUID for restoration (except code block redactions). 
* The response metadata items maintain the same order as the input redaction pointers, and completely 
* overlapping redactions are merged into a single redaction with one UUID.
* 
* **Note**: This endpoint requires **Atlassian Guard Premium**.
*/
readonly "postRedactPage": (id: string) => Effect.Effect<typeof RedactionResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Redacts sensitive content in a Confluence blog post by replacing specified text ranges with redaction markers. 
* Each redaction in the response includes a unique UUID for restoration (except code block redactions). 
* The response metadata items maintain the same order as the input redaction pointers, and completely 
* overlapping redactions are merged into a single redaction with one UUID.
* 
* **Note**: This endpoint requires **Atlassian Guard Premium**.
*/
readonly "postRedactBlog": (id: string) => Effect.Effect<typeof RedactionResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the title of a specified page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page and its corresponding space. Permission to update pages in the space.
*/
readonly "updatePageTitle": (id: string) => Effect.Effect<typeof UpdatePageTitle200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the versions of specific page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page and its corresponding space.
*/
readonly "getPageVersions": (id: string, options?: typeof GetPageVersionsParams.Encoded | undefined) => Effect.Effect<typeof GetPageVersions200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a whiteboard in the space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the corresponding space. Permission to create a whiteboard in the space.
*/
readonly "createWhiteboard": (options?: typeof CreateWhiteboardParams.Encoded | undefined) => Effect.Effect<typeof CreateWhiteboard200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific whiteboard.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the whiteboard and its corresponding space.
*/
readonly "getWhiteboardById": (id: string, options?: typeof GetWhiteboardByIdParams.Encoded | undefined) => Effect.Effect<typeof GetWhiteboardById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a whiteboard by id.
* 
* Deleting a whiteboard moves the whiteboard to the trash, where it can be restored later
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the whiteboard and its corresponding space.
* Permission to delete whiteboards in the space.
*/
readonly "deleteWhiteboard": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves Content Properties tied to a specified whiteboard.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the whiteboard.
*/
readonly "getWhiteboardContentProperties": (id: string, options?: typeof GetWhiteboardContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetWhiteboardContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content property for a whiteboard.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the whiteboard.
*/
readonly "createWhiteboardProperty": (id: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified whiteboard.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the whiteboard.
*/
readonly "getWhiteboardContentPropertiesById": (whiteboardId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for a whiteboard by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the whiteboard.
*/
readonly "updateWhiteboardPropertyById": (whiteboardId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for a whiteboard by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the whiteboard.
*/
readonly "deleteWhiteboardPropertyById": (whiteboardId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific whiteboard.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the whiteboard and its corresponding space.
*/
readonly "getWhiteboardOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all children for given whiteboard id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only content that the user has permission to view will be returned.
*/
readonly "getWhiteboardDirectChildren": (id: string, options?: typeof GetWhiteboardDirectChildrenParams.Encoded | undefined) => Effect.Effect<typeof GetWhiteboardDirectChildren200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns descendants in the content tree for a given whiteboard by ID in top-to-bottom order (that is, the highest descendant is the first
* item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
* of descendants to be fetched.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the whiteboard and its corresponding space
*/
readonly "getWhiteboardDescendants": (id: string, options?: typeof GetWhiteboardDescendantsParams.Encoded | undefined) => Effect.Effect<typeof GetWhiteboardDescendants200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all ancestors for a given whiteboard by ID in top-to-bottom order (that is, the highest ancestor is the first
* item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available by calling this endpoint with the ID of first ancestor in the response payload.
* 
* This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
* as [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the whiteboard and its corresponding space
*/
readonly "getWhiteboardAncestors": (id: string, options?: typeof GetWhiteboardAncestorsParams.Encoded | undefined) => Effect.Effect<typeof GetWhiteboardAncestors200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a database in the space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the corresponding space. Permission to create a database in the space.
*/
readonly "createDatabase": (options?: typeof CreateDatabaseParams.Encoded | undefined) => Effect.Effect<typeof CreateDatabase200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific database.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the database and its corresponding space.
*/
readonly "getDatabaseById": (id: string, options?: typeof GetDatabaseByIdParams.Encoded | undefined) => Effect.Effect<typeof GetDatabaseById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a database by id.
* 
* Deleting a database moves the database to the trash, where it can be restored later
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the database and its corresponding space.
* Permission to delete databases in the space.
*/
readonly "deleteDatabase": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves Content Properties tied to a specified database.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the database.
*/
readonly "getDatabaseContentProperties": (id: string, options?: typeof GetDatabaseContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetDatabaseContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content property for a database.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the database.
*/
readonly "createDatabaseProperty": (id: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified database.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the database.
*/
readonly "getDatabaseContentPropertiesById": (databaseId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for a database by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the database.
*/
readonly "updateDatabasePropertyById": (databaseId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for a database by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the database.
*/
readonly "deleteDatabasePropertyById": (databaseId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific database.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the database and its corresponding space.
*/
readonly "getDatabaseOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all children for given database id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only content that the user has permission to view will be returned.
*/
readonly "getDatabaseDirectChildren": (id: string, options?: typeof GetDatabaseDirectChildrenParams.Encoded | undefined) => Effect.Effect<typeof GetDatabaseDirectChildren200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns descendants in the content tree for a given database by ID in top-to-bottom order (that is, the highest descendant is the first
* item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
* of descendants to be fetched.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the database and its corresponding space
*/
readonly "getDatabaseDescendants": (id: string, options?: typeof GetDatabaseDescendantsParams.Encoded | undefined) => Effect.Effect<typeof GetDatabaseDescendants200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all ancestors for a given database by ID in top-to-bottom order (that is, the highest ancestor is the first
* item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available by calling this endpoint with the ID of first ancestor in the response payload.
* 
* This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
* as [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the database and its corresponding space
*/
readonly "getDatabaseAncestors": (id: string, options?: typeof GetDatabaseAncestorsParams.Encoded | undefined) => Effect.Effect<typeof GetDatabaseAncestors200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a Smart Link in the content tree in the space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the corresponding space. Permission to create a Smart Link in the content tree in the space.
*/
readonly "createSmartLink": () => Effect.Effect<typeof CreateSmartLink200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific Smart Link in the content tree.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the Smart Link in the content tree and its corresponding space.
*/
readonly "getSmartLinkById": (id: string, options?: typeof GetSmartLinkByIdParams.Encoded | undefined) => Effect.Effect<typeof GetSmartLinkById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a Smart Link in the content tree by id.
* 
* Deleting a Smart Link in the content tree moves the Smart Link to the trash, where it can be restored later
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the Smart Link in the content tree and its corresponding space.
* Permission to delete Smart Links in the content tree in the space.
*/
readonly "deleteSmartLink": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves Content Properties tied to a specified Smart Link in the content tree.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the Smart Link in the content tree.
*/
readonly "getSmartLinkContentProperties": (id: string, options?: typeof GetSmartLinkContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetSmartLinkContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content property for a Smart Link in the content tree.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the Smart Link in the content tree.
*/
readonly "createSmartLinkProperty": (id: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified Smart Link in the content tree.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the Smart Link in the content tree.
*/
readonly "getSmartLinkContentPropertiesById": (embedId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for a Smart Link in the content tree by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the Smart Link in the content tree.
*/
readonly "updateSmartLinkPropertyById": (embedId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for a Smart Link in the content tree by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the Smart Link in the content tree.
*/
readonly "deleteSmartLinkPropertyById": (embedId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific Smart Link in the content tree.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the Smart Link in the content tree and its corresponding space.
*/
readonly "getSmartLinkOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all children for given smart link id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only content that the user has permission to view will be returned.
*/
readonly "getSmartLinkDirectChildren": (id: string, options?: typeof GetSmartLinkDirectChildrenParams.Encoded | undefined) => Effect.Effect<typeof GetSmartLinkDirectChildren200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns descendants in the content tree for a given smart link by ID in top-to-bottom order (that is, the highest descendant is the first
* item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
* of descendants to be fetched.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* 
* This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the smart link and its corresponding space
*/
readonly "getSmartLinkDescendants": (id: string, options?: typeof GetSmartLinkDescendantsParams.Encoded | undefined) => Effect.Effect<typeof GetSmartLinkDescendants200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all ancestors for a given Smart Link in the content tree by ID in top-to-bottom order (that is, the highest ancestor is
* the first item in the response payload). The number of results is limited by the `limit` parameter and additional results 
* (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.
* 
* This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
* as [Get Smart Link in the content tree by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the Smart Link in the content tree and its corresponding space
*/
readonly "getSmartLinkAncestors": (id: string, options?: typeof GetSmartLinkAncestorsParams.Encoded | undefined) => Effect.Effect<typeof GetSmartLinkAncestors200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a folder in the space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the corresponding space. Permission to create a folder in the space.
*/
readonly "createFolder": () => Effect.Effect<typeof CreateFolder200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific folder.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the folder and its corresponding space.
*/
readonly "getFolderById": (id: string, options?: typeof GetFolderByIdParams.Encoded | undefined) => Effect.Effect<typeof GetFolderById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a folder by id.
* 
* Deleting a folder moves the folder to the trash, where it can be restored later
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the folder and its corresponding space.
* Permission to delete folders in the space.
*/
readonly "deleteFolder": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves Content Properties tied to a specified folder.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the folder.
*/
readonly "getFolderContentProperties": (id: string, options?: typeof GetFolderContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetFolderContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content property for a folder.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the folder.
*/
readonly "createFolderProperty": (id: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified folder.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the folder.
*/
readonly "getFolderContentPropertiesById": (folderId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for a folder by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the folder.
*/
readonly "updateFolderPropertyById": (folderId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for a folder by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the folder.
*/
readonly "deleteFolderPropertyById": (folderId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific folder.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the folder and its corresponding space.
*/
readonly "getFolderOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all children for given folder id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only content that the user has permission to view will be returned.
*/
readonly "getFolderDirectChildren": (id: string, options?: typeof GetFolderDirectChildrenParams.Encoded | undefined) => Effect.Effect<typeof GetFolderDirectChildren200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns descendants in the content tree for a given folder by ID in top-to-bottom order (that is, the highest descendant is the first
* item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
* of descendants to be fetched.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the  and its corresponding space
*/
readonly "getFolderDescendants": (id: string, options?: typeof GetFolderDescendantsParams.Encoded | undefined) => Effect.Effect<typeof GetFolderDescendants200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all ancestors for a given folder by ID in top-to-bottom order (that is, the highest ancestor is
* the first item in the response payload). The number of results is limited by the `limit` parameter and additional results 
* (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.
* 
* This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
* as [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-folders-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the folder and its corresponding space
*/
readonly "getFolderAncestors": (id: string, options?: typeof GetFolderAncestorsParams.Encoded | undefined) => Effect.Effect<typeof GetFolderAncestors200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves version details for the specified page and version number.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page.
*/
readonly "getPageVersionDetails": (pageId: string, versionNumber: string) => Effect.Effect<typeof DetailedVersion.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the versions of specific custom content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content and its corresponding page and space.
*/
readonly "getCustomContentVersions": (customContentId: string, options?: typeof GetCustomContentVersionsParams.Encoded | undefined) => Effect.Effect<typeof GetCustomContentVersions200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves version details for the specified custom content and version number.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the page.
*/
readonly "getCustomContentVersionDetails": (customContentId: string, versionNumber: string) => Effect.Effect<typeof DetailedVersion.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
* additional results (if available) will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only spaces that the user has permission to view will be returned.
*/
readonly "getSpaces": (options?: typeof GetSpacesParams.Encoded | undefined) => Effect.Effect<typeof GetSpaces200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a Space as specified in the payload.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to create spaces.
*/
readonly "createSpace": () => Effect.Effect<typeof CreateSpace201.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the space.
*/
readonly "getSpaceById": (id: string, options?: typeof GetSpaceByIdParams.Encoded | undefined) => Effect.Effect<typeof GetSpaceById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all blog posts in a space. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission) and view the space.
* Only blog posts that the user has permission to view will be returned.
*/
readonly "getBlogPostsInSpace": (id: string, options?: typeof GetBlogPostsInSpaceParams.Encoded | undefined) => Effect.Effect<typeof GetBlogPostsInSpace200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the labels of specific space. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the space.
* Only labels that the user has permission to view will be returned.
*/
readonly "getSpaceLabels": (id: string, options?: typeof GetSpaceLabelsParams.Encoded | undefined) => Effect.Effect<typeof GetSpaceLabels200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the labels of space content (pages, blogposts etc). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the space.
* Only labels that the user has permission to view will be returned.
*/
readonly "getSpaceContentLabels": (id: string, options?: typeof GetSpaceContentLabelsParams.Encoded | undefined) => Effect.Effect<typeof GetSpaceContentLabels200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all custom content for a given type within a given space. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the custom content and the corresponding space.
*/
readonly "getCustomContentByTypeInSpace": (id: string, options: typeof GetCustomContentByTypeInSpaceParams.Encoded) => Effect.Effect<typeof GetCustomContentByTypeInSpace200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the corresponding space.
*/
readonly "getSpaceOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
* Only pages that the user has permission to view will be returned.
*/
readonly "getPagesInSpace": (id: string, options?: typeof GetPagesInSpaceParams.Encoded | undefined) => Effect.Effect<typeof GetPagesInSpace200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all properties for the given space. Space properties are a key-value storage associated with a space.
* The limit parameter specifies the maximum number of results returned in a single response. Use the `link` response header
* to paginate through additional results.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
*/
readonly "getSpaceProperties": (spaceId: string, options?: typeof GetSpacePropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetSpaceProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new space property.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
*/
readonly "createSpaceProperty": (spaceId: string, options: typeof SpacePropertyCreateRequest.Encoded) => Effect.Effect<typeof SpaceProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieve a space property by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
*/
readonly "getSpacePropertyById": (spaceId: string, propertyId: string) => Effect.Effect<typeof SpaceProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a space property by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
*/
readonly "updateSpacePropertyById": (spaceId: string, propertyId: string, options: typeof SpacePropertyUpdateRequest.Encoded) => Effect.Effect<typeof SpaceProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a space property by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
*/
readonly "deleteSpacePropertyById": (spaceId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns space permission assignments for a specific space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the space.
*/
readonly "getSpacePermissionsAssignments": (id: string, options?: typeof GetSpacePermissionsAssignmentsParams.Encoded | undefined) => Effect.Effect<typeof GetSpacePermissionsAssignments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves the available space permissions.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site.
*/
readonly "getAvailableSpacePermissions": (options?: typeof GetAvailableSpacePermissionsParams.Encoded | undefined) => Effect.Effect<typeof GetAvailableSpacePermissions200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves the available space roles.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site; if requesting a certain space's roles, permission to view the space.
*/
readonly "getAvailableSpaceRoles": (options?: typeof GetAvailableSpaceRolesParams.Encoded | undefined) => Effect.Effect<typeof GetAvailableSpaceRoles200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Create a space role.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* User must be an organization or site admin. Connect and Forge app users are not authorized to access this resource.
*/
readonly "createSpaceRole": (options: typeof CreateSpaceRoleRequest.Encoded) => Effect.Effect<typeof SpaceRole.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves the space role by ID.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site.
*/
readonly "getSpaceRolesById": (id: string) => Effect.Effect<typeof GetSpaceRolesById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a space role.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* User must be an organization or site admin. Connect and Forge app users are not authorized to access this resource.
*/
readonly "updateSpaceRole": (id: string, options: typeof UpdateSpaceRoleRequest.Encoded) => Effect.Effect<typeof UpdateSpaceRoleResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a space role
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* User must be an organization or site admin. Connect and Forge app users are not authorized to access this resource.
*/
readonly "deleteSpaceRole": (id: string) => Effect.Effect<typeof DeleteSpaceRoleResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves the space role mode.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getSpaceRoleMode": () => Effect.Effect<typeof GetSpaceRoleMode200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves the space role assignments.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the space.
*/
readonly "getSpaceRoleAssignments": (id: string, options?: typeof GetSpaceRoleAssignmentsParams.Encoded | undefined) => Effect.Effect<typeof GetSpaceRoleAssignments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Sets space role assignments as specified in the payload.
* 
* Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to manage roles in the space.
*/
readonly "setSpaceRoleAssignments": (id: string) => Effect.Effect<typeof SetSpaceRoleAssignments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getPageFooterComments": (id: string, options?: typeof GetPageFooterCommentsParams.Encoded | undefined) => Effect.Effect<typeof GetPageFooterComments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getPageInlineComments": (id: string, options?: typeof GetPageInlineCommentsParams.Encoded | undefined) => Effect.Effect<typeof GetPageInlineComments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the blog post and its corresponding space.
*/
readonly "getBlogPostFooterComments": (id: string, options?: typeof GetBlogPostFooterCommentsParams.Encoded | undefined) => Effect.Effect<typeof GetBlogPostFooterComments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the blog post and its corresponding space.
*/
readonly "getBlogPostInlineComments": (id: string, options?: typeof GetBlogPostInlineCommentsParams.Encoded | undefined) => Effect.Effect<typeof GetBlogPostInlineComments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all footer comments. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the container and its corresponding space.
*/
readonly "getFooterComments": (options?: typeof GetFooterCommentsParams.Encoded | undefined) => Effect.Effect<typeof GetFooterComments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Create a footer comment.
* 
* The footer comment can be made against several locations: 
* - at the top level (specifying pageId or blogPostId in the request body)
* - as a reply (specifying parentCommentId in the request body)
* - against an attachment (note: this is different than the comments added via the attachment properties page on the UI, which are referred to as version comments)
* - against a custom content
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
*/
readonly "createFooterComment": (options: typeof CreateFooterCommentModel.Encoded) => Effect.Effect<typeof CreateFooterComment201.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a footer comment by id
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the container and its corresponding space.
*/
readonly "getFooterCommentById": (commentId: string, options?: typeof GetFooterCommentByIdParams.Encoded | undefined) => Effect.Effect<typeof GetFooterCommentById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a footer comment. This can be used to update the body text of a comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
*/
readonly "updateFooterComment": (commentId: string, options: typeof UpdateFooterCommentRequest.Encoded) => Effect.Effect<typeof FooterCommentModel.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a footer comment. This is a permanent deletion and cannot be reverted.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
*/
readonly "deleteFooterComment": (commentId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getFooterCommentChildren": (id: string, options?: typeof GetFooterCommentChildrenParams.Encoded | undefined) => Effect.Effect<typeof GetFooterCommentChildren200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the count of likes of specific footer comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page/blogpost and its corresponding space.
*/
readonly "getFooterLikeCount": (id: string) => Effect.Effect<typeof GetFooterLikeCount200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the account IDs of likes of specific footer comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page/blogpost and its corresponding space.
*/
readonly "getFooterLikeUsers": (id: string, options?: typeof GetFooterLikeUsersParams.Encoded | undefined) => Effect.Effect<typeof GetFooterLikeUsers200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific footer comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the parent content of the footer comment and its corresponding space.
*/
readonly "getFooterCommentOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves the versions of the specified footer comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blog post and its corresponding space.
*/
readonly "getFooterCommentVersions": (id: string, options?: typeof GetFooterCommentVersionsParams.Encoded | undefined) => Effect.Effect<typeof GetFooterCommentVersions200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves version details for the specified footer comment version.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blog post and its corresponding space.
*/
readonly "getFooterCommentVersionDetails": (id: string, versionNumber: string) => Effect.Effect<typeof DetailedVersion.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all inline comments. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getInlineComments": (options?: typeof GetInlineCommentsParams.Encoded | undefined) => Effect.Effect<typeof GetInlineComments200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body)
* or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the
* request body is used to select the text the inline comment should be tied to. This is what determines the text 
* highlighting when viewing a page in Confluence.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
*/
readonly "createInlineComment": (options: typeof CreateInlineCommentModel.Encoded) => Effect.Effect<typeof CreateInlineComment201.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves an inline comment by id
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space.
*/
readonly "getInlineCommentById": (commentId: string, options?: typeof GetInlineCommentByIdParams.Encoded | undefined) => Effect.Effect<typeof GetInlineCommentById200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
*/
readonly "updateInlineComment": (commentId: string, options: typeof UpdateInlineCommentModel.Encoded) => Effect.Effect<typeof UpdateInlineComment200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes an inline comment. This is a permanent deletion and cannot be reverted.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
*/
readonly "deleteInlineComment": (commentId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page and its corresponding space.
*/
readonly "getInlineCommentChildren": (id: string, options?: typeof GetInlineCommentChildrenParams.Encoded | undefined) => Effect.Effect<typeof GetInlineCommentChildren200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the count of likes of specific inline comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page/blogpost and its corresponding space.
*/
readonly "getInlineLikeCount": (id: string) => Effect.Effect<typeof GetInlineLikeCount200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the account IDs of likes of specific inline comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page/blogpost and its corresponding space.
*/
readonly "getInlineLikeUsers": (id: string, options?: typeof GetInlineLikeUsersParams.Encoded | undefined) => Effect.Effect<typeof GetInlineLikeUsers200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the permitted operations on specific inline comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the parent content of the inline comment and its corresponding space.
*/
readonly "getInlineCommentOperations": (id: string) => Effect.Effect<typeof PermittedOperationsResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves the versions of the specified inline comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blog post and its corresponding space.
*/
readonly "getInlineCommentVersions": (id: string, options?: typeof GetInlineCommentVersionsParams.Encoded | undefined) => Effect.Effect<typeof GetInlineCommentVersions200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves version details for the specified inline comment version.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content of the page or blog post and its corresponding space.
*/
readonly "getInlineCommentVersionDetails": (id: string, versionNumber: string) => Effect.Effect<typeof DetailedVersion.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves Content Properties attached to a specified comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the comment.
*/
readonly "getCommentContentProperties": (commentId: string, options?: typeof GetCommentContentPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetCommentContentProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content property for a comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the comment.
*/
readonly "createCommentProperty": (commentId: string, options: typeof ContentPropertyCreateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Retrieves a specific Content Property by ID that is attached to a specified comment.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the comment.
*/
readonly "getCommentContentPropertiesById": (commentId: string, propertyId: string) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a content property for a comment by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the comment.
*/
readonly "updateCommentPropertyById": (commentId: string, propertyId: string, options: typeof ContentPropertyUpdateRequest.Encoded) => Effect.Effect<typeof ContentProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a content property for a comment by its id. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the comment.
*/
readonly "deleteCommentPropertyById": (commentId: string, propertyId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all tasks. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only tasks that the user has permission to view will be returned.
*/
readonly "getTasks": (options?: typeof GetTasksParams.Encoded | undefined) => Effect.Effect<typeof GetTasks200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a specific task. 
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the containing page or blog post and its corresponding space.
*/
readonly "getTaskById": (id: string, options?: typeof GetTaskByIdParams.Encoded | undefined) => Effect.Effect<typeof Task.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update a task by id. This endpoint currently only supports updating task status.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the containing page or blog post and view its corresponding space.
*/
readonly "updateTask": (id: string, options?: typeof UpdateTaskParams.Encoded | undefined) => Effect.Effect<typeof Task.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all child pages for given page id. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only pages that the user has permission to view will be returned.
*/
readonly "getChildPages": (id: string, options?: typeof GetChildPagesParams.Encoded | undefined) => Effect.Effect<typeof GetChildPages200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all child custom content for given custom content id. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only custom content that the user has permission to view will be returned.
*/
readonly "getChildCustomContent": (id: string, options?: typeof GetChildCustomContentParams.Encoded | undefined) => Effect.Effect<typeof GetChildCustomContent200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all children for given page id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
* will be available through the `next` URL present in the `Link` response header.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only content that the user has permission to view will be returned.
*/
readonly "getPageDirectChildren": (id: string, options?: typeof GetPageDirectChildrenParams.Encoded | undefined) => Effect.Effect<typeof GetPageDirectChildren200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all ancestors for a given page by ID in top-to-bottom order (that is, the highest ancestor is the first
* item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available by calling this endpoint with the ID of first ancestor in the response payload.
* 
* This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
* as [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getPageAncestors": (id: string, options?: typeof GetPageAncestorsParams.Encoded | undefined) => Effect.Effect<typeof GetPageAncestors200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns descendants in the content tree for a given page by ID in top-to-bottom order (that is, the highest descendant is the first
* item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
* will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
* of descendants to be fetched.
* 
* The following types of content will be returned:
* - Database
* - Embed
* - Folder
* - Page
* - Whiteboard
* 
* This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
* as:
* 
* - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
* - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
* - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
* - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
* - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Permission to view the page and its corresponding space
*/
readonly "getPageDescendants": (id: string, options?: typeof GetPageDescendantsParams.Encoded | undefined) => Effect.Effect<typeof GetPageDescendants200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns user details for the ids provided in the request body.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* The user must be able to view user profiles in the Confluence site.
*/
readonly "createBulkUserLookup": () => Effect.Effect<typeof CreateBulkUserLookup200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the list of emails from the input list that do not have access to site.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "checkAccessByEmail": () => Effect.Effect<typeof CheckAccessByEmail200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Invite a list of emails to the site.
* 
* Ignores all invalid emails and no action is taken for the emails that already have access to the site.
* 
* <b>NOTE:</b> This API is asynchronous and may take some time to complete.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "inviteByEmail": () => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns data policy metadata for the workspace.
* 
* **[Permissions](#permissions) required:**
* Only apps can make this request.
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getDataPolicyMetadata": () => Effect.Effect<typeof DataPolicyMetadata.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
* additional results (if available) will be available through the `next` URL present in the `Link` response header.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Only apps can make this request.
* Permission to access the Confluence site ('Can use' global permission).
* Only spaces that the app has permission to view will be returned.
*/
readonly "getDataPolicySpaces": (options?: typeof GetDataPolicySpacesParams.Encoded | undefined) => Effect.Effect<typeof GetDataPolicySpaces200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a list of [classification levels](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) 
* available.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getClassificationLevels": () => Effect.Effect<typeof GetClassificationLevels200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
* for a specific space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the space.
*/
readonly "getSpaceDefaultClassificationLevel": (id: string) => Effect.Effect<typeof ClassificationLevel.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Update the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
* for a specific space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
*/
readonly "putSpaceDefaultClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
* for a specific space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
*/
readonly "deleteSpaceDefaultClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the page.
* 'Permission to edit the page is required if trying to view classification level for a draft.
*/
readonly "getPageClassificationLevel": (id: string, options?: typeof GetPageClassificationLevelParams.Encoded | undefined) => Effect.Effect<typeof ClassificationLevel.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific page.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to edit the page.
*/
readonly "putPageClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific page for the space 
* [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the page.
*/
readonly "postPageClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific blog post.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the blog post.
* 'Permission to edit the blog post is required if trying to view classification level for a draft.
*/
readonly "getBlogPostClassificationLevel": (id: string, options?: typeof GetBlogPostClassificationLevelParams.Encoded | undefined) => Effect.Effect<typeof ClassificationLevel.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific blog post.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to edit the blog post.
*/
readonly "putBlogPostClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific blog post for the space  
* [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the blog post.
*/
readonly "postBlogPostClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific whiteboard.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the whiteboard.
*/
readonly "getWhiteboardClassificationLevel": (id: string) => Effect.Effect<typeof ClassificationLevel.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific whiteboard.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to edit the whiteboard.
*/
readonly "putWhiteboardClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific whiteboard for the space 
* [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the whiteboard.
*/
readonly "postWhiteboardClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific database.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the database.
*/
readonly "getDatabaseClassificationLevel": (id: string) => Effect.Effect<typeof ClassificationLevel.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific database.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to edit the database.
*/
readonly "putDatabaseClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
* for a specific database for the space 
* [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Permission to access the Confluence site ('Can use' global permission) and permission to view the database.
*/
readonly "postDatabaseClassificationLevel": (id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Gets Forge app properties. This API can only be accessed using **[asApp()](https://developer.atlassian.com/platform/forge/apis-reference/fetch-api-product.requestconfluence/#method-signature)** requests from Forge.
*/
readonly "getForgeAppProperties": (options?: typeof GetForgeAppPropertiesParams.Encoded | undefined) => Effect.Effect<typeof GetForgeAppProperties200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Gets a Forge app property by property key. This API can only be accessed using **[asApp()](https://developer.atlassian.com/platform/forge/apis-reference/fetch-api-product.requestconfluence/#method-signature)** requests from Forge.
*/
readonly "getForgeAppProperty": (propertyKey: string) => Effect.Effect<typeof GetForgeAppProperty200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates or updates a Forge app property. This API can only be accessed using **[asApp()](https://developer.atlassian.com/platform/forge/apis-reference/fetch-api-product.requestconfluence/#method-signature)** requests from Forge.
*/
readonly "putForgeAppProperty": (propertyKey: string, options: typeof PutForgeAppPropertyRequest.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a Forge app property. This API can only be accessed using **[asApp()](https://developer.atlassian.com/platform/forge/apis-reference/fetch-api-product.requestconfluence/#method-signature)** requests from Forge.
*/
readonly "deleteForgeAppProperty": (propertyKey: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
}

export interface ConfluenceV2ClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class ConfluenceV2ClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const ConfluenceV2ClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): ConfluenceV2ClientError<Tag, E> =>
  new ConfluenceV2ClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any
