// @ts-nocheck
/* eslint-disable */
/**
 * Auto-generated by @tim-smart/openapi-gen
 * DO NOT EDIT - changes will be overwritten
 */
import type * as HttpClient from "@effect/platform/HttpClient"
import * as HttpClientError from "@effect/platform/HttpClientError"
import * as HttpClientRequest from "@effect/platform/HttpClientRequest"
import * as HttpClientResponse from "@effect/platform/HttpClientResponse"
import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { ParseError } from "effect/ParseResult"
import * as S from "effect/Schema"

export class GetAuditRecordsParams extends S.Struct({
  "startDate": S.optionalWith(S.String, { nullable: true }),
  "endDate": S.optionalWith(S.String, { nullable: true }),
  "searchString": S.optionalWith(S.String, { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 1000 as const })
}) {}

export class AuditRecordAuthorType extends S.Literal("user") {}

/**
* The operation itself.
*/
export class OperationCheckResultOperation extends S.Literal("administer", "archive", "clear_permissions", "copy", "create", "create_space", "delete", "export", "move", "purge", "purge_version", "read", "restore", "restrict_content", "update", "use") {}

/**
* An operation and the target entity that it applies to, e.g. create page.
*/
export class OperationCheckResult extends S.Class<OperationCheckResult>("OperationCheckResult")({
  /**
* The operation itself.
*/
"operation": OperationCheckResultOperation,
  /**
* The space or content type that the operation applies to. Could be one of- - application - page - blogpost - comment - attachment - space
*/
"targetType": S.String
}) {}

/**
* This property is no longer available and will be removed from the documentation soon.
* Use `accountId` instead.
* See the [deprecation notice](/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/) for details.
*/
export class GenericUserName extends S.String {}

/**
* This property is no longer available and will be removed from the documentation soon.
* Use `accountId` instead.
* See the [deprecation notice](/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/) for details.
*/
export class GenericUserKey extends S.String {}

/**
* The account ID of the user, which uniquely identifies the user across all Atlassian products.
* For example, `384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192`.
*/
export class GenericAccountId extends S.String {}

export class AffectedObject extends S.Class<AffectedObject>("AffectedObject")({
  "name": S.String,
  "objectType": S.String
}) {}

export class ChangedValue extends S.Class<ChangedValue>("ChangedValue")({
  "name": S.String,
  "oldValue": S.String,
  "hiddenOldValue": S.optionalWith(S.String, { nullable: true }),
  "newValue": S.String,
  "hiddenNewValue": S.optionalWith(S.String, { nullable: true })
}) {}

export class AuditRecord extends S.Class<AuditRecord>("AuditRecord")({
  "author": S.Struct({
  "type": AuditRecordAuthorType.pipe(S.propertySignature, S.withConstructorDefault(() => "user" as const)),
  "displayName": S.String,
  "operations": S.optionalWith(S.Array(OperationCheckResult), { nullable: true }),
  "username": S.optionalWith(GenericUserName, { nullable: true }),
  "userKey": S.optionalWith(GenericUserKey, { nullable: true }),
  "accountId": S.optionalWith(GenericAccountId, { nullable: true }),
  "accountType": S.optionalWith(S.String, { nullable: true }),
  /**
* This is deprecated. Use `isGuest` instead.
*/
"externalCollaborator": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* This is deprecated. Use `isGuest` instead. Whether the user is an external collaborator user
*/
"isExternalCollaborator": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Whether the user is a guest user
*/
"isGuest": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The public name or nickname of the user. Will always contain a value.
*/
"publicName": S.optionalWith(S.String, { nullable: true })
}),
  "remoteAddress": S.String,
  /**
* The creation date-time of the audit record, as a timestamp.
*/
"creationDate": S.Int,
  "summary": S.String,
  "description": S.String,
  "category": S.String,
  "sysAdmin": S.Boolean,
  "superAdmin": S.optionalWith(S.Boolean, { nullable: true }),
  "affectedObject": AffectedObject,
  "changedValues": S.Array(ChangedValue),
  "associatedObjects": S.Array(AffectedObject)
}) {}

export class GenericLinks extends S.Record({ key: S.String, value: S.Unknown }) {}

export class AuditRecordArray extends S.Class<AuditRecordArray>("AuditRecordArray")({
  "results": S.Array(AuditRecord),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": GenericLinks
}) {}

/**
* Set to 'user'.
*/
export class AuditRecordCreateAuthorType extends S.Literal("user") {}

export class AuditRecordCreate extends S.Class<AuditRecordCreate>("AuditRecordCreate")({
  /**
* The user that actioned the event. If `author` is not specified, then all
* `author` properties will be set to null/empty, except for `type` which
* will be set to 'user'.
*/
"author": S.optionalWith(S.Struct({
  /**
* Set to 'user'.
*/
"type": AuditRecordCreateAuthorType.pipe(S.propertySignature, S.withConstructorDefault(() => "user" as const)),
  /**
* The name that is displayed on the audit log in the Confluence UI.
*/
"displayName": S.optionalWith(S.String, { nullable: true }),
  /**
* Always defaults to null.
*/
"operations": S.optionalWith(S.Array(OperationCheckResult), { nullable: true }),
  "username": S.optionalWith(GenericUserName, { nullable: true }),
  "userKey": S.optionalWith(GenericUserKey, { nullable: true })
}), { nullable: true }),
  /**
* The IP address of the computer where the event was initiated from.
*/
"remoteAddress": S.String,
  /**
* The creation date-time of the audit record, as a timestamp. This is converted
* to a date-time display in the Confluence UI. If the `creationDate` is not
* specified, then it will be set to the timestamp for the current date-time.
*/
"creationDate": S.optionalWith(S.Int, { nullable: true }),
  /**
* The summary of the event, which is displayed in the 'Change' column on
* the audit log in the Confluence UI.
*/
"summary": S.optionalWith(S.String, { nullable: true }),
  /**
* A long description of the event, which is displayed in the 'Description'
* field on the audit log in the Confluence UI.
*/
"description": S.optionalWith(S.String, { nullable: true }),
  /**
* The category of the event, which is displayed in the 'Event type' column
* on the audit log in the Confluence UI.
*/
"category": S.optionalWith(S.String, { nullable: true }),
  /**
* Indicates whether the event was actioned by a system administrator.
*/
"sysAdmin": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "affectedObject": S.optionalWith(AffectedObject, { nullable: true }),
  /**
* The values that were changed in the event.
*/
"changedValues": S.optionalWith(S.Array(ChangedValue), { nullable: true }),
  /**
* Objects that were associated with the event. For example, if the event
* was a space permission change then the associated object would be the
* space.
*/
"associatedObjects": S.optionalWith(S.Array(AffectedObject), { nullable: true })
}) {}

export class ExportAuditRecordsParamsFormat extends S.Literal("csv", "zip") {}

export class ExportAuditRecordsParams extends S.Struct({
  "startDate": S.optionalWith(S.String, { nullable: true }),
  "endDate": S.optionalWith(S.String, { nullable: true }),
  "searchString": S.optionalWith(S.String, { nullable: true }),
  "format": S.optionalWith(ExportAuditRecordsParamsFormat, { nullable: true, default: () => "csv" as const })
}) {}

/**
* The unit of time that the retention period is measured in.
*/
export class RetentionPeriodUnits extends S.Literal("NANOS", "MICROS", "MILLIS", "SECONDS", "MINUTES", "HOURS", "HALF_DAYS", "DAYS", "WEEKS", "MONTHS", "YEARS", "DECADES", "CENTURIES", "MILLENNIA", "ERAS", "FOREVER") {}

export class RetentionPeriod extends S.Class<RetentionPeriod>("RetentionPeriod")({
  /**
* The number of units for the retention period.
*/
"number": S.Int,
  /**
* The unit of time that the retention period is measured in.
*/
"units": RetentionPeriodUnits
}) {}

export class GetAuditRecordsForTimePeriodParamsUnits extends S.Literal("NANOS", "MICROS", "MILLIS", "SECONDS", "MINUTES", "HOURS", "HALF_DAYS", "DAYS", "WEEKS", "MONTHS", "YEARS", "DECADES", "CENTURIES") {}

export class GetAuditRecordsForTimePeriodParams extends S.Struct({
  "number": S.optionalWith(S.Int, { nullable: true, default: () => 3 as const }),
  "units": S.optionalWith(GetAuditRecordsForTimePeriodParamsUnits, { nullable: true, default: () => "MONTHS" as const }),
  "searchString": S.optionalWith(S.String, { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 1000 as const })
}) {}

export class ArchivePagesRequest extends S.Class<ArchivePagesRequest>("ArchivePagesRequest")({
  "pages": S.optionalWith(S.Array(S.Struct({
  /**
* The `id` of the page to be archived.
*/
"id": S.Int
})), { nullable: true })
}) {}

export class LongTask extends S.Class<LongTask>("LongTask")({
  /**
* the ARI for the long task, based on its ID
*/
"ari": S.optionalWith(S.String, { nullable: true }),
  /**
* a unique identifier for the long task
*/
"id": S.String,
  "links": S.Struct({
  /**
* The URL to retrive status of long task.
*/
"status": S.optionalWith(S.String, { nullable: true })
})
}) {}

export class PublishSharedDraftParams extends S.Struct({
  "status": S.optionalWith(S.String, { nullable: true, default: () => "draft" as const }),
  "expand": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

/**
* The type of content. Set this to `page`.
*/
export class ContentBlueprintDraftType extends S.Literal("page") {}

/**
* The status of the content. Set this to `current` or omit it altogether.
*/
export class ContentBlueprintDraftStatus extends S.Literal("current") {}

export class ContentBlueprintDraft extends S.Class<ContentBlueprintDraft>("ContentBlueprintDraft")({
  /**
* The version for the new content.
*/
"version": S.Struct({
  /**
* The version number. Set this to `1`.
*/
"number": S.Int
}),
  /**
* The title of the content. If you don't want to change the title,
* set this to the current title of the draft.
*/
"title": S.String.pipe(S.maxLength(255)),
  /**
* The type of content. Set this to `page`.
*/
"type": ContentBlueprintDraftType,
  /**
* The status of the content. Set this to `current` or omit it altogether.
*/
"status": S.optionalWith(ContentBlueprintDraftStatus, { nullable: true, default: () => "current" as const }),
  /**
* The space for the content.
*/
"space": S.optionalWith(S.Struct({
  /**
* The key of the space
*/
"key": S.String
}), { nullable: true }),
  /**
* The new ancestor (i.e. parent page) for the content. If you have
* specified an ancestor, you must also specify a `space` property
* in the request body for the space that the ancestor is in.
* 
* Note, if you specify more than one ancestor, the last ID in the array
* will be selected as the parent page for the content.
*/
"ancestors": S.optionalWith(S.Array(S.Struct({
  /**
* The content ID of the ancestor.
*/
"id": S.String
})), { nullable: true })
}) {}

/**
* This object represents an icon. If used as a profilePicture, this may be returned as null, depending on the user's privacy setting.
*/
export class Icon extends S.Class<Icon>("Icon")({
  "path": S.String,
  "width": S.Int,
  "height": S.Int,
  "isDefault": S.Boolean
}) {}

export class SpaceDescriptionRepresentation extends S.Literal("plain", "view") {}

export class SpaceDescription extends S.Class<SpaceDescription>("SpaceDescription")({
  "value": S.String,
  "representation": SpaceDescriptionRepresentation,
  "embeddedContent": S.Array(S.Struct({
  
}))
}) {}

export class Label extends S.Class<Label>("Label")({
  "prefix": S.String,
  "name": S.String,
  "id": S.String,
  "label": S.String
}) {}

export class LabelArray extends S.Class<LabelArray>("LabelArray")({
  "results": S.Array(Label),
  "start": S.optionalWith(S.Int, { nullable: true }),
  "limit": S.optionalWith(S.Int, { nullable: true }),
  "size": S.Int,
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class UserType extends S.Literal("known", "unknown", "anonymous", "user") {}

/**
* The account type of the user, may return empty string if unavailable. App is if the user is a bot user created on behalf of an Atlassian app.
*/
export class UserAccountType extends S.Literal("atlassian", "app", "") {}

export class UserDetails extends S.Class<UserDetails>("UserDetails")({
  "business": S.optionalWith(S.Struct({
  /**
* This property has been deprecated due to privacy changes. There is no replacement. See the
* [migration guide](https://developer.atlassian.com/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/)
* for details.
*/
"position": S.optionalWith(S.String, { nullable: true }),
  /**
* This property has been deprecated due to privacy changes. There is no replacement. See the
* [migration guide](https://developer.atlassian.com/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/)
* for details.
*/
"department": S.optionalWith(S.String, { nullable: true }),
  /**
* This property has been deprecated due to privacy changes. There is no replacement. See the
* [migration guide](https://developer.atlassian.com/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/)
* for details.
*/
"location": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "personal": S.optionalWith(S.Struct({
  /**
* This property has been deprecated due to privacy changes. There is no replacement. See the
* [migration guide](https://developer.atlassian.com/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/)
* for details.
*/
"phone": S.optionalWith(S.String, { nullable: true }),
  /**
* This property has been deprecated due to privacy changes. There is no replacement. See the
* [migration guide](https://developer.atlassian.com/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/)
* for details.
*/
"im": S.optionalWith(S.String, { nullable: true }),
  /**
* This property has been deprecated due to privacy changes. There is no replacement. See the
* [migration guide](https://developer.atlassian.com/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/)
* for details.
*/
"website": S.optionalWith(S.String, { nullable: true }),
  /**
* This property has been deprecated due to privacy changes. Use the `User.email` property instead. See the
* [migration guide](https://developer.atlassian.com/cloud/confluence/deprecation-notice-user-privacy-api-migration-guide/)
* for details.
*/
"email": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}) {}

export class User extends S.Class<User>("User")({
  "type": UserType,
  "username": S.optionalWith(GenericUserName, { nullable: true }),
  "userKey": S.optionalWith(GenericUserKey, { nullable: true }),
  "accountId": S.optionalWith(GenericAccountId, { nullable: true }),
  /**
* The account type of the user, may return empty string if unavailable. App is if the user is a bot user created on behalf of an Atlassian app.
*/
"accountType": S.optionalWith(UserAccountType, { nullable: true }),
  /**
* The email address of the user. Depending on the user's privacy setting, this may return an empty string.
*/
"email": S.optionalWith(S.String, { nullable: true }),
  /**
* The public name or nickname of the user. Will always contain a value.
*/
"publicName": S.optionalWith(S.String, { nullable: true }),
  "profilePicture": S.optionalWith(Icon, { nullable: true }),
  /**
* The displays name of the user. Depending on the user's privacy setting, this may be the same as publicName.
*/
"displayName": S.optionalWith(S.String, { nullable: true }),
  /**
* This displays user time zone. Depending on the user's privacy setting, this may return null.
*/
"timeZone": S.optionalWith(S.String, { nullable: true }),
  /**
* This is deprecated. Use `isGuest` instead to find out whether the user is a guest user.
*/
"externalCollaborator": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* This is deprecated. Use `isGuest` instead to find out whether the user is a guest user.
*/
"isExternalCollaborator": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Whether the user is a guest user
*/
"isGuest": S.optionalWith(S.Boolean, { nullable: true }),
  "operations": S.optionalWith(S.Array(OperationCheckResult), { nullable: true }),
  "details": S.optionalWith(UserDetails, { nullable: true }),
  "personalSpace": S.optionalWith(S.suspend(() => Space), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "operations": S.optionalWith(S.String, { nullable: true }),
  "details": S.optionalWith(S.String, { nullable: true }),
  "personalSpace": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class GroupType extends S.Literal("group") {}

export class Group extends S.Class<Group>("Group")({
  "type": GroupType.pipe(S.propertySignature, S.withConstructorDefault(() => "group" as const)),
  "name": S.String,
  "id": S.String,
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

/**
* This object represents a permission for given space. Permissions consist of
* at least one operation object with an accompanying subjects object.
* 
* The following combinations of `operation` and `targetType` values are
* valid for the `operation` object:
* 
*   - 'create': 'page', 'blogpost', 'comment', 'attachment'
*   - 'read': 'space'
*   - 'delete': 'page', 'blogpost', 'comment', 'attachment'
*   - 'export': 'space'
*   - 'administer': 'space'
*/
export class SpacePermission extends S.Class<SpacePermission>("SpacePermission")({
  "id": S.optionalWith(S.Int, { nullable: true }),
  /**
* The users and/or groups that the permission applies to.
*/
"subjects": S.optionalWith(S.Struct({
  "user": S.optionalWith(S.Struct({
  "results": S.Array(S.suspend(() => User)),
  "size": S.Int,
  "start": S.optionalWith(S.Int, { nullable: true }),
  "limit": S.optionalWith(S.Int, { nullable: true })
}), { nullable: true }),
  "group": S.optionalWith(S.Struct({
  "results": S.Array(Group),
  "size": S.Int,
  "start": S.optionalWith(S.Int, { nullable: true }),
  "limit": S.optionalWith(S.Int, { nullable: true })
}), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "user": S.optionalWith(S.String, { nullable: true }),
  "group": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}), { nullable: true }),
  "operation": OperationCheckResult,
  /**
* Grant anonymous users permission to use the operation.
*/
"anonymousAccess": S.Boolean.pipe(S.propertySignature, S.withConstructorDefault(() => false as const)),
  /**
* Grants access to unlicensed users from JIRA Service Desk when used
* with the 'read space' operation.
*/
"unlicensedAccess": S.Boolean.pipe(S.propertySignature, S.withConstructorDefault(() => false as const))
}) {}

export class SpaceSettings extends S.Class<SpaceSettings>("SpaceSettings")({
  /**
* Defines whether an override for the space home should be used. This is
* used in conjunction with a space theme provided by an app. For
* example, if this property is set to true, a theme can display a page
* other than the space homepage when users visit the root URL for a
* space. This property allows apps to provide content-only theming
* without overriding the space home.
*/
"routeOverrideEnabled": S.Boolean,
  "editor": S.optionalWith(S.Struct({
  "page": S.String,
  "blogpost": S.String,
  "default": S.String
}), { nullable: true }),
  "spaceKey": S.optionalWith(S.String, { nullable: true }),
  "_links": GenericLinks
}) {}

export class Theme extends S.Class<Theme>("Theme")({
  "themeKey": S.String,
  "name": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(S.String, { nullable: true }),
  "icon": S.optionalWith(Icon, { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class MenusLookAndFeel extends S.Class<MenusLookAndFeel>("MenusLookAndFeel")({
  "hoverOrFocus": S.Struct({
  "backgroundColor": S.String
}),
  "color": S.String
}) {}

export class ButtonLookAndFeel extends S.Class<ButtonLookAndFeel>("ButtonLookAndFeel")({
  "backgroundColor": S.String,
  "color": S.String
}) {}

export class NavigationLookAndFeel extends S.Class<NavigationLookAndFeel>("NavigationLookAndFeel")({
  "color": S.String,
  "highlightColor": S.optionalWith(S.String, { nullable: true }),
  "hoverOrFocus": S.Struct({
  "backgroundColor": S.String,
  "color": S.String
})
}) {}

export class SearchFieldLookAndFeel extends S.Class<SearchFieldLookAndFeel>("SearchFieldLookAndFeel")({
  "backgroundColor": S.String,
  "color": S.String
}) {}

export class HeaderLookAndFeel extends S.Class<HeaderLookAndFeel>("HeaderLookAndFeel")({
  "backgroundColor": S.String,
  "button": S.NullOr(ButtonLookAndFeel),
  "primaryNavigation": S.NullOr(NavigationLookAndFeel),
  "secondaryNavigation": S.NullOr(NavigationLookAndFeel),
  "search": S.NullOr(SearchFieldLookAndFeel)
}) {}

export class TopNavigationLookAndFeel extends S.Class<TopNavigationLookAndFeel>("TopNavigationLookAndFeel")({
  "color": S.optionalWith(S.String, { nullable: true }),
  "highlightColor": S.String,
  "hoverOrFocus": S.optionalWith(S.Struct({
  "backgroundColor": S.optionalWith(S.String, { nullable: true }),
  "color": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}) {}

export class HorizontalHeaderLookAndFeel extends S.Class<HorizontalHeaderLookAndFeel>("HorizontalHeaderLookAndFeel")({
  "backgroundColor": S.String,
  "button": S.optionalWith(ButtonLookAndFeel, { nullable: true }),
  "primaryNavigation": TopNavigationLookAndFeel,
  "secondaryNavigation": S.optionalWith(NavigationLookAndFeel, { nullable: true }),
  "search": S.optionalWith(SearchFieldLookAndFeel, { nullable: true })
}) {}

export class ScreenLookAndFeel extends S.Class<ScreenLookAndFeel>("ScreenLookAndFeel")({
  "background": S.String,
  "backgroundAttachment": S.optionalWith(S.String, { nullable: true }),
  "backgroundBlendMode": S.optionalWith(S.String, { nullable: true }),
  "backgroundClip": S.optionalWith(S.String, { nullable: true }),
  "backgroundColor": S.optionalWith(S.String, { nullable: true }),
  "backgroundImage": S.optionalWith(S.String, { nullable: true }),
  "backgroundOrigin": S.optionalWith(S.String, { nullable: true }),
  "backgroundPosition": S.optionalWith(S.String, { nullable: true }),
  "backgroundRepeat": S.optionalWith(S.String, { nullable: true }),
  "backgroundSize": S.optionalWith(S.String, { nullable: true }),
  "layer": S.optionalWith(S.Struct({
  "width": S.optionalWith(S.String, { nullable: true }),
  "height": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "gutterTop": S.optionalWith(S.String, { nullable: true }),
  "gutterRight": S.optionalWith(S.String, { nullable: true }),
  "gutterBottom": S.optionalWith(S.String, { nullable: true }),
  "gutterLeft": S.optionalWith(S.String, { nullable: true })
}) {}

export class ContainerLookAndFeel extends S.Class<ContainerLookAndFeel>("ContainerLookAndFeel")({
  "background": S.String,
  "backgroundAttachment": S.optionalWith(S.String, { nullable: true }),
  "backgroundBlendMode": S.optionalWith(S.String, { nullable: true }),
  "backgroundClip": S.optionalWith(S.String, { nullable: true }),
  "backgroundColor": S.NullOr(S.String),
  "backgroundImage": S.NullOr(S.String),
  "backgroundOrigin": S.optionalWith(S.String, { nullable: true }),
  "backgroundPosition": S.optionalWith(S.String, { nullable: true }),
  "backgroundRepeat": S.optionalWith(S.String, { nullable: true }),
  "backgroundSize": S.NullOr(S.String),
  "padding": S.String,
  "borderRadius": S.String
}) {}

export class ContentLookAndFeel extends S.Class<ContentLookAndFeel>("ContentLookAndFeel")({
  "screen": S.optionalWith(ScreenLookAndFeel, { nullable: true }),
  "container": S.optionalWith(ContainerLookAndFeel, { nullable: true }),
  "header": S.optionalWith(ContainerLookAndFeel, { nullable: true }),
  "body": S.optionalWith(ContainerLookAndFeel, { nullable: true })
}) {}

export class LookAndFeel extends S.Class<LookAndFeel>("LookAndFeel")({
  "headings": S.Struct({
  "color": S.String
}),
  "links": S.Struct({
  "color": S.String
}),
  "menus": MenusLookAndFeel,
  "header": HeaderLookAndFeel,
  "horizontalHeader": S.optionalWith(HorizontalHeaderLookAndFeel, { nullable: true }),
  "content": ContentLookAndFeel,
  "bordersAndDividers": S.Struct({
  "color": S.String
}),
  "spaceReference": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}) {}

export class Space extends S.Class<Space>("Space")({
  "id": S.optionalWith(S.Int, { nullable: true }),
  "key": S.String,
  "alias": S.optionalWith(S.String, { nullable: true }),
  "name": S.String,
  "icon": S.optionalWith(Icon, { nullable: true }),
  "description": S.optionalWith(S.Struct({
  "plain": S.optionalWith(SpaceDescription, { nullable: true }),
  "view": S.optionalWith(SpaceDescription, { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "view": S.optionalWith(S.String, { nullable: true }),
  "plain": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}), { nullable: true }),
  "homepage": S.optionalWith(S.suspend(() => Content), { nullable: true }),
  "type": S.String,
  "metadata": S.optionalWith(S.Struct({
  "labels": S.optionalWith(LabelArray, { nullable: true }),
  "_expandable": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}), { nullable: true }),
  "operations": S.optionalWith(S.Array(OperationCheckResult), { nullable: true }),
  "permissions": S.optionalWith(S.Array(SpacePermission), { nullable: true }),
  "status": S.String,
  "settings": S.optionalWith(SpaceSettings, { nullable: true }),
  "theme": S.optionalWith(Theme, { nullable: true }),
  "lookAndFeel": S.optionalWith(LookAndFeel, { nullable: true }),
  "history": S.optionalWith(S.Struct({
  "createdDate": S.String,
  "createdBy": S.optionalWith(S.suspend(() => User), { nullable: true })
}), { nullable: true }),
  "_expandable": S.Struct({
  "settings": S.optionalWith(S.String, { nullable: true }),
  "metadata": S.optionalWith(S.String, { nullable: true }),
  "operations": S.optionalWith(S.String, { nullable: true }),
  "lookAndFeel": S.optionalWith(S.String, { nullable: true }),
  "permissions": S.optionalWith(S.String, { nullable: true }),
  "icon": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(S.String, { nullable: true }),
  "theme": S.optionalWith(S.String, { nullable: true }),
  "history": S.optionalWith(S.String, { nullable: true }),
  "homepage": S.optionalWith(S.String, { nullable: true }),
  "identifiers": S.optionalWith(S.String, { nullable: true })
}),
  "_links": GenericLinks
}) {}

export class UsersUserKeys extends S.Class<UsersUserKeys>("UsersUserKeys")({
  "users": S.optionalWith(S.Array(S.suspend(() => User)), { nullable: true }),
  "userKeys": S.optionalWith(S.Array(S.String), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class Version extends S.Class<Version>("Version")({
  "by": S.optionalWith(S.suspend(() => User), { nullable: true }),
  "when": S.NullOr(S.String),
  "friendlyWhen": S.optionalWith(S.String, { nullable: true }),
  "message": S.optionalWith(S.String, { nullable: true }),
  /**
* Set this to the current version number incremented by one
*/
"number": S.Int,
  /**
* If `minorEdit` is set to 'true', no notification email or activity
* stream will be generated for the change.
*/
"minorEdit": S.Boolean,
  "content": S.optionalWith(S.suspend(() => Content), { nullable: true }),
  "collaborators": S.optionalWith(UsersUserKeys, { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "content": S.optionalWith(S.String, { nullable: true }),
  "collaborators": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true }),
  /**
* True if content type is modifed in this version (e.g. page to blog)
*/
"contentTypeModified": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The revision id provided by confluence to be used as a revision in Synchrony
*/
"confRev": S.optionalWith(S.String, { nullable: true }),
  /**
* The revision id provided by Synchrony
*/
"syncRev": S.optionalWith(S.String, { nullable: true }),
  /**
* Source of the synchrony revision
*/
"syncRevSource": S.optionalWith(S.String, { nullable: true })
}) {}

export class ContentHistory extends S.Class<ContentHistory>("ContentHistory")({
  "latest": S.Boolean,
  "createdBy": S.optionalWith(S.suspend(() => User), { nullable: true }),
  "ownedBy": S.optionalWith(S.suspend(() => User), { nullable: true }),
  "lastOwnedBy": S.optionalWith(S.suspend(() => User), { nullable: true }),
  "createdDate": S.optionalWith(S.String, { nullable: true }),
  "lastUpdated": S.optionalWith(S.suspend(() => Version), { nullable: true }),
  "previousVersion": S.optionalWith(S.suspend(() => Version), { nullable: true }),
  "contributors": S.optionalWith(S.Struct({
  "publishers": S.optionalWith(UsersUserKeys, { nullable: true })
}), { nullable: true }),
  "nextVersion": S.optionalWith(S.suspend(() => Version), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "lastUpdated": S.optionalWith(S.String, { nullable: true }),
  "previousVersion": S.optionalWith(S.String, { nullable: true }),
  "contributors": S.optionalWith(S.String, { nullable: true }),
  "nextVersion": S.optionalWith(S.String, { nullable: true }),
  "ownedBy": S.optionalWith(S.String, { nullable: true }),
  "lastOwnedBy": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class ContentArray extends S.Class<ContentArray>("ContentArray")({
  "results": S.Array(S.suspend(() => Content)),
  "start": S.optionalWith(S.Int, { nullable: true }),
  "limit": S.optionalWith(S.Int, { nullable: true }),
  "size": S.Int,
  "_links": GenericLinks
}) {}

export class ContentChildren extends S.Class<ContentChildren>("ContentChildren")({
  "attachment": S.optionalWith(ContentArray, { nullable: true }),
  "comment": S.optionalWith(ContentArray, { nullable: true }),
  "page": S.optionalWith(ContentArray, { nullable: true }),
  "whiteboard": S.optionalWith(ContentArray, { nullable: true }),
  "database": S.optionalWith(ContentArray, { nullable: true }),
  "embed": S.optionalWith(ContentArray, { nullable: true }),
  "folder": S.optionalWith(ContentArray, { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "attachment": S.optionalWith(S.String, { nullable: true }),
  "comment": S.optionalWith(S.String, { nullable: true }),
  "page": S.optionalWith(S.String, { nullable: true }),
  "whiteboard": S.optionalWith(S.String, { nullable: true }),
  "database": S.optionalWith(S.String, { nullable: true }),
  "embed": S.optionalWith(S.String, { nullable: true }),
  "folder": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

/**
* Shows whether a piece of content has attachments, comments, or child pages/whiteboards.
* Note, this doesn't actually contain the child objects.
*/
export class ContentChildType extends S.Class<ContentChildType>("ContentChildType")({
  "attachment": S.optionalWith(S.Struct({
  "value": S.Boolean,
  "_links": GenericLinks
}), { nullable: true }),
  "comment": S.optionalWith(S.Struct({
  "value": S.Boolean,
  "_links": GenericLinks
}), { nullable: true }),
  "page": S.optionalWith(S.Struct({
  "value": S.Boolean,
  "_links": GenericLinks
}), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "all": S.optionalWith(S.String, { nullable: true }),
  "attachment": S.optionalWith(S.String, { nullable: true }),
  "comment": S.optionalWith(S.String, { nullable: true }),
  "page": S.optionalWith(S.String, { nullable: true }),
  "whiteboard": S.optionalWith(S.String, { nullable: true }),
  "database": S.optionalWith(S.String, { nullable: true }),
  "embed": S.optionalWith(S.String, { nullable: true }),
  "folder": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}) {}

/**
* Container for content. This can be either a space (containing a page or blogpost)
* or a page/blog post (containing an attachment or comment)
*/
export class Container extends S.Record({ key: S.String, value: S.Unknown }) {}

export class ContentBodyRepresentation extends S.Literal("view", "export_view", "styled_view", "storage", "editor", "editor2", "anonymous_export_view", "wiki", "atlas_doc_format", "raw") {}

export class Embeddable extends S.Record({ key: S.String, value: S.Unknown }) {}

export class EmbeddedContent extends S.Class<EmbeddedContent>("EmbeddedContent")({
  "entityId": S.optionalWith(S.Int, { nullable: true }),
  "entityType": S.optionalWith(S.String, { nullable: true }),
  "entity": S.optionalWith(Embeddable, { nullable: true })
}) {}

export class SuperBatchWebResources extends S.Class<SuperBatchWebResources>("SuperBatchWebResources")({
  "uris": S.optionalWith(S.Struct({
  "all": S.optionalWith(S.Union(S.Array(S.String),
S.String), { nullable: true }),
  "css": S.optionalWith(S.Union(S.Array(S.String),
S.String), { nullable: true }),
  "js": S.optionalWith(S.Union(S.Array(S.String),
S.String), { nullable: true })
}), { nullable: true }),
  "tags": S.optionalWith(S.Struct({
  "all": S.optionalWith(S.String, { nullable: true }),
  "css": S.optionalWith(S.String, { nullable: true }),
  "data": S.optionalWith(S.String, { nullable: true }),
  "js": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "metatags": S.optionalWith(S.String, { nullable: true }),
  "_expandable": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}) {}

export class WebResourceDependencies extends S.Class<WebResourceDependencies>("WebResourceDependencies")({
  "_expandable": S.optionalWith(S.Struct({
  "uris": S.optionalWith(S.Union(S.String,
S.Record({ key: S.String, value: S.Unknown })), { nullable: true })
}), { nullable: true }),
  "keys": S.optionalWith(S.Array(S.String), { nullable: true }),
  "contexts": S.optionalWith(S.Array(S.String), { nullable: true }),
  "uris": S.optionalWith(S.Struct({
  "all": S.optionalWith(S.Union(S.Array(S.String),
S.String), { nullable: true }),
  "css": S.optionalWith(S.Union(S.Array(S.String),
S.String), { nullable: true }),
  "js": S.optionalWith(S.Union(S.Array(S.String),
S.String), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "css": S.optionalWith(S.Union(S.Array(S.String),
S.String), { nullable: true }),
  "js": S.optionalWith(S.Union(S.Array(S.String),
S.String), { nullable: true })
}), { nullable: true })
}), { nullable: true }),
  "tags": S.optionalWith(S.Struct({
  "all": S.optionalWith(S.String, { nullable: true }),
  "css": S.optionalWith(S.String, { nullable: true }),
  "data": S.optionalWith(S.String, { nullable: true }),
  "js": S.optionalWith(S.String, { nullable: true }),
  "_expandable": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}), { nullable: true }),
  "superbatch": S.optionalWith(SuperBatchWebResources, { nullable: true })
}) {}

export class ContentBody extends S.Class<ContentBody>("ContentBody")({
  "value": S.String,
  "representation": ContentBodyRepresentation,
  "embeddedContent": S.optionalWith(S.Array(EmbeddedContent), { nullable: true }),
  "webresource": S.optionalWith(WebResourceDependencies, { nullable: true }),
  "mediaToken": S.optionalWith(S.Struct({
  "collectionIds": S.optionalWith(S.Array(S.String), { nullable: true }),
  "contentId": S.optionalWith(S.String, { nullable: true }),
  "expiryDateTime": S.optionalWith(S.String, { nullable: true }),
  "fileIds": S.optionalWith(S.Array(S.String), { nullable: true }),
  "token": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "content": S.optionalWith(S.String, { nullable: true }),
  "embeddedContent": S.optionalWith(S.String, { nullable: true }),
  "webresource": S.optionalWith(S.String, { nullable: true }),
  "mediaToken": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class ContentRestrictionOperation extends S.Literal("administer", "copy", "create", "delete", "export", "move", "purge", "purge_version", "read", "restore", "update", "use") {}

export class UserArray extends S.Class<UserArray>("UserArray")({
  "results": S.Array(S.suspend(() => User)),
  "start": S.optionalWith(S.Int, { nullable: true }),
  "limit": S.optionalWith(S.Int, { nullable: true }),
  "size": S.optionalWith(S.Int, { nullable: true }),
  /**
* This property will return total count of the objects before pagination is applied.
* This value is returned if `shouldReturnTotalSize` is set to `true`.
*/
"totalSize": S.optionalWith(S.Int, { nullable: true, default: () => 0 as const }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class GroupArray extends S.Class<GroupArray>("GroupArray")({
  "results": S.Array(Group),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int
}) {}

export class ContentRestriction extends S.Class<ContentRestriction>("ContentRestriction")({
  "operation": ContentRestrictionOperation,
  "restrictions": S.optionalWith(S.Struct({
  "user": S.optionalWith(UserArray, { nullable: true }),
  "group": S.optionalWith(GroupArray, { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "user": S.optionalWith(S.String, { nullable: true }),
  "group": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}), { nullable: true }),
  "content": S.optionalWith(S.suspend(() => Content), { nullable: true }),
  "_expandable": S.Struct({
  "restrictions": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(S.String, { nullable: true })
}),
  "_links": GenericLinks
}) {}

/**
* Metadata object for page, blogpost, comment content
*/
export class ContentMetadata extends S.Class<ContentMetadata>("ContentMetadata")({
  "currentuser": S.optionalWith(S.Struct({
  "favourited": S.optionalWith(S.Struct({
  "isFavourite": S.optionalWith(S.Boolean, { nullable: true }),
  "favouritedDate": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "lastmodified": S.optionalWith(S.Struct({
  "version": S.optionalWith(S.suspend(() => Version), { nullable: true }),
  "friendlyLastModified": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "lastcontributed": S.optionalWith(S.Struct({
  "status": S.optionalWith(S.String, { nullable: true }),
  "when": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "viewed": S.optionalWith(S.Struct({
  "lastSeen": S.optionalWith(S.String, { nullable: true }),
  "friendlyLastSeen": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "scheduled": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "favourited": S.optionalWith(S.String, { nullable: true }),
  "lastmodified": S.optionalWith(S.String, { nullable: true }),
  "lastcontributed": S.optionalWith(S.String, { nullable: true }),
  "viewed": S.optionalWith(S.String, { nullable: true }),
  "scheduled": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}), { nullable: true }),
  "properties": S.optionalWith(GenericLinks, { nullable: true }),
  "frontend": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  "labels": S.optionalWith(S.Union(LabelArray,
S.Array(Label)), { nullable: true })
}) {}

/**
* Base object for all content types.
*/
export class Content extends S.Class<Content>("Content")({
  "id": S.optionalWith(S.String, { nullable: true }),
  /**
* Can be "page", "blogpost", "attachment" or "content"
*/
"type": S.String,
  "status": S.String,
  "title": S.optionalWith(S.String, { nullable: true }),
  "space": S.optionalWith(S.suspend(() => Space), { nullable: true }),
  "history": S.optionalWith(S.suspend(() => ContentHistory), { nullable: true }),
  "version": S.optionalWith(S.suspend(() => Version), { nullable: true }),
  "ancestors": S.optionalWith(S.Array(S.suspend(() => Content)), { nullable: true }),
  "operations": S.optionalWith(S.Array(OperationCheckResult), { nullable: true }),
  "children": S.optionalWith(ContentChildren, { nullable: true }),
  "childTypes": S.optionalWith(ContentChildType, { nullable: true }),
  "descendants": S.optionalWith(ContentChildren, { nullable: true }),
  "container": S.optionalWith(Container, { nullable: true }),
  "body": S.optionalWith(S.Struct({
  "view": S.optionalWith(ContentBody, { nullable: true }),
  "export_view": S.optionalWith(ContentBody, { nullable: true }),
  "styled_view": S.optionalWith(ContentBody, { nullable: true }),
  "storage": S.optionalWith(ContentBody, { nullable: true }),
  "wiki": S.optionalWith(ContentBody, { nullable: true }),
  "editor": S.optionalWith(ContentBody, { nullable: true }),
  "editor2": S.optionalWith(ContentBody, { nullable: true }),
  "anonymous_export_view": S.optionalWith(ContentBody, { nullable: true }),
  "atlas_doc_format": S.optionalWith(ContentBody, { nullable: true }),
  "dynamic": S.optionalWith(ContentBody, { nullable: true }),
  "raw": S.optionalWith(ContentBody, { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "editor": S.optionalWith(S.String, { nullable: true }),
  "view": S.optionalWith(S.String, { nullable: true }),
  "export_view": S.optionalWith(S.String, { nullable: true }),
  "styled_view": S.optionalWith(S.String, { nullable: true }),
  "storage": S.optionalWith(S.String, { nullable: true }),
  "editor2": S.optionalWith(S.String, { nullable: true }),
  "anonymous_export_view": S.optionalWith(S.String, { nullable: true }),
  "atlas_doc_format": S.optionalWith(S.String, { nullable: true }),
  "wiki": S.optionalWith(S.String, { nullable: true }),
  "dynamic": S.optionalWith(S.String, { nullable: true }),
  "raw": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}), { nullable: true }),
  "restrictions": S.optionalWith(S.Struct({
  "read": S.optionalWith(ContentRestriction, { nullable: true }),
  "update": S.optionalWith(ContentRestriction, { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "read": S.optionalWith(S.String, { nullable: true }),
  "update": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}), { nullable: true }),
  "metadata": S.optionalWith(ContentMetadata, { nullable: true }),
  "macroRenderedOutput": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  "extensions": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "childTypes": S.optionalWith(S.String, { nullable: true }),
  "container": S.optionalWith(S.String, { nullable: true }),
  "metadata": S.optionalWith(S.String, { nullable: true }),
  "operations": S.optionalWith(S.String, { nullable: true }),
  "children": S.optionalWith(S.String, { nullable: true }),
  "restrictions": S.optionalWith(S.String, { nullable: true }),
  "history": S.optionalWith(S.String, { nullable: true }),
  "ancestors": S.optionalWith(S.String, { nullable: true }),
  "body": S.optionalWith(S.String, { nullable: true }),
  "version": S.optionalWith(S.String, { nullable: true }),
  "descendants": S.optionalWith(S.String, { nullable: true }),
  "space": S.optionalWith(S.String, { nullable: true }),
  "extensions": S.optionalWith(S.String, { nullable: true }),
  "schedulePublishDate": S.optionalWith(S.String, { nullable: true }),
  "schedulePublishInfo": S.optionalWith(S.String, { nullable: true }),
  "macroRenderedOutput": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class PublishLegacyDraftParams extends S.Struct({
  "status": S.optionalWith(S.String, { nullable: true, default: () => "draft" as const }),
  "expand": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

export class SearchContentByCQLParams extends S.Struct({
  "cql": S.String,
  "cqlcontext": S.optionalWith(S.String, { nullable: true }),
  "expand": S.optionalWith(S.Array(S.String), { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 25 as const })
}) {}

export class ContentId extends S.String {}

export class MovePage200 extends S.Struct({
  "pageId": S.optionalWith(ContentId, { nullable: true })
}) {}

export class CreateOrUpdateAttachmentsParamsStatus extends S.Literal("current", "draft") {}

export class CreateOrUpdateAttachmentsParams extends S.Struct({
  "status": S.optionalWith(CreateOrUpdateAttachmentsParamsStatus, { nullable: true, default: () => "current" as const })
}) {}

export class CreateOrUpdateAttachmentsRequest extends S.Class<CreateOrUpdateAttachmentsRequest>("CreateOrUpdateAttachmentsRequest")({
  /**
* The relative location and name of the attachment to be added to
* the content.
*/
"file": S.instanceOf(globalThis.Blob),
  /**
* The comment for the attachment that is being added.
* If you specify a comment, then every file must have a comment and
* the comments must be in the same order as the files. Alternatively,
* don't specify any comments.
*/
"comment": S.optionalWith(S.instanceOf(globalThis.Blob), { nullable: true }),
  /**
* If `minorEdits` is set to 'true', no notification email or activity stream
* will be generated when the attachment is added to the content.
*/
"minorEdit": S.instanceOf(globalThis.Blob)
}) {}

export class CreateAttachmentParamsStatus extends S.Literal("current", "draft") {}

export class CreateAttachmentParams extends S.Struct({
  "status": S.optionalWith(CreateAttachmentParamsStatus, { nullable: true, default: () => "current" as const })
}) {}

export class CreateAttachmentRequest extends S.Class<CreateAttachmentRequest>("CreateAttachmentRequest")({
  /**
* The relative location and name of the attachment to be added to
* the content.
*/
"file": S.instanceOf(globalThis.Blob),
  /**
* The comment for the attachment that is being added.
* If you specify a comment, then every file must have a comment and
* the comments must be in the same order as the files. Alternatively,
* don't specify any comments.
*/
"comment": S.optionalWith(S.instanceOf(globalThis.Blob), { nullable: true }),
  /**
* If `minorEdits` is set to 'true', no notification email or activity stream
* will be generated when the attachment is added to the content.
*/
"minorEdit": S.instanceOf(globalThis.Blob)
}) {}

export class AttachmentPropertiesUpdateBody extends S.Class<AttachmentPropertiesUpdateBody>("AttachmentPropertiesUpdateBody")({
  "id": S.String,
  /**
* Set this to "attachment"
*/
"type": S.String,
  "status": S.optionalWith(S.String, { nullable: true }),
  "title": S.optionalWith(S.String, { nullable: true }),
  "container": S.optionalWith(Container, { nullable: true }),
  "metadata": S.optionalWith(S.Struct({
  "mediaType": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "extensions": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  "version": S.NullOr(Version)
}) {}

export class UpdateAttachmentDataRequest extends S.Class<UpdateAttachmentDataRequest>("UpdateAttachmentDataRequest")({
  /**
* The relative location and name of the attachment to be added to
* the content.
*/
"file": S.instanceOf(globalThis.Blob),
  /**
* The comment for the attachment that is being added.
* If you specify a comment, then every file must have a comment and
* the comments must be in the same order as the files. Alternatively,
* don't specify any comments.
*/
"comment": S.optionalWith(S.instanceOf(globalThis.Blob), { nullable: true }),
  /**
* If `minorEdits` is set to 'true', no notification email or activity stream
* will be generated when the attachment is added to the content.
*/
"minorEdit": S.instanceOf(globalThis.Blob)
}) {}

export class DownloadAttatchmentParams extends S.Struct({
  "version": S.optionalWith(S.Int, { nullable: true }),
  "status": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

export class GetContentDescendantsParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("attachment", "comment", "page")), { nullable: true })
}) {}

export class GetDescendantsOfTypeParamsDepth extends S.Literal("all", "root", "<any positive integer argument in the range of 1 and 100>") {}

export class GetDescendantsOfTypeParams extends S.Struct({
  "depth": S.optionalWith(GetDescendantsOfTypeParamsDepth, { nullable: true, default: () => "all" as const }),
  "expand": S.optionalWith(S.Array(S.String), { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 25 as const })
}) {}

export class MacroInstance extends S.Class<MacroInstance>("MacroInstance")({
  "name": S.optionalWith(S.String, { nullable: true }),
  "body": S.optionalWith(S.String, { nullable: true }),
  "parameters": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class GetAndConvertMacroBodyByMacroIdParamsEmbeddedContentRender extends S.Literal("current", "version-at-save") {}

export class GetAndConvertMacroBodyByMacroIdParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.String), { nullable: true }),
  "spaceKeyContext": S.optionalWith(S.String, { nullable: true }),
  "embeddedContentRender": S.optionalWith(GetAndConvertMacroBodyByMacroIdParamsEmbeddedContentRender, { nullable: true, default: () => "current" as const })
}) {}

export class GetAndAsyncConvertMacroBodyByMacroIdParamsEmbeddedContentRender extends S.Literal("current", "version-at-save") {}

export class GetAndAsyncConvertMacroBodyByMacroIdParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.String), { nullable: true }),
  "allowCache": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "spaceKeyContext": S.optionalWith(S.String, { nullable: true }),
  "embeddedContentRender": S.optionalWith(GetAndAsyncConvertMacroBodyByMacroIdParamsEmbeddedContentRender, { nullable: true, default: () => "current" as const })
}) {}

export class AsyncId extends S.Class<AsyncId>("AsyncId")({
  "asyncId": S.String
}) {}

export class LabelCreate extends S.Class<LabelCreate>("LabelCreate")({
  /**
* The prefix for the label. `global`, `my` `team`, etc.
*/
"prefix": S.String,
  /**
* The name of the label, which will be shown in the UI.
*/
"name": S.String
}) {}

export class LabelCreateArray extends S.Array(LabelCreate) {}

export class AddLabelsToContentRequest extends S.Union(LabelCreateArray,
LabelCreate) {}

export class RemoveLabelFromContentUsingQueryParameterParams extends S.Struct({
  "name": S.String
}) {}

export class GetWatchesForPageParams extends S.Struct({
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 200 as const })
}) {}

/**
* This essentially the same as the `User` object, but no `_links` property and
* no `_expandable` property (therefore, different required fields).
*/
export class WatchUser extends S.Class<WatchUser>("WatchUser")({
  "type": S.String,
  "username": S.optionalWith(GenericUserName, { nullable: true }),
  "userKey": S.optionalWith(GenericUserKey, { nullable: true }),
  "accountId": S.NullOr(GenericAccountId),
  "profilePicture": S.NullOr(Icon),
  "displayName": S.String,
  "timeZone": S.optionalWith(S.String, { nullable: true }),
  "operations": S.NullOr(S.Array(OperationCheckResult)),
  "externalCollaborator": S.Boolean,
  "isGuest": S.NullOr(S.Boolean),
  "isExternalCollaborator": S.Boolean,
  "details": S.optionalWith(UserDetails, { nullable: true }),
  "accountType": S.String,
  "email": S.String,
  "publicName": S.String,
  "personalSpace": S.NullOr(S.Record({ key: S.String, value: S.Unknown }))
}) {}

export class Watch extends S.Class<Watch>("Watch")({
  "type": S.String,
  "watcher": WatchUser,
  "contentId": S.Int
}) {}

export class WatchArray extends S.Class<WatchArray>("WatchArray")({
  "results": S.Array(Watch),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": GenericLinks
}) {}

export class GetWatchesForSpaceParams extends S.Struct({
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 200 as const })
}) {}

export class SpaceWatch extends S.Class<SpaceWatch>("SpaceWatch")({
  "type": S.String,
  "watcher": WatchUser,
  "spaceKey": S.optionalWith(S.String, { nullable: true }),
  "labelName": S.optionalWith(S.String, { nullable: true }),
  "prefix": S.optionalWith(S.String, { nullable: true })
}) {}

export class SpaceWatchArray extends S.Class<SpaceWatchArray>("SpaceWatchArray")({
  "results": S.Array(SpaceWatch),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

/**
* Required for copying page in the same space.
*/
export class CopyPageHierarchyTitleOptions extends S.Class<CopyPageHierarchyTitleOptions>("CopyPageHierarchyTitleOptions")({
  "prefix": S.optionalWith(S.String, { nullable: true }),
  "replace": S.optionalWith(S.String, { nullable: true }),
  "search": S.optionalWith(S.String, { nullable: true })
}) {}

export class CopyPageHierarchyRequest extends S.Class<CopyPageHierarchyRequest>("CopyPageHierarchyRequest")({
  /**
* If set to `true`, attachments are copied to the destination page.
*/
"copyAttachments": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, page permissions are copied to the destination page.
*/
"copyPermissions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, content properties are copied to the destination page.
*/
"copyProperties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, labels are copied to the destination page.
*/
"copyLabels": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, custom contents are copied to the destination page.
*/
"copyCustomContents": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, descendants are copied to the destination page.
*/
"copyDescendants": S.optionalWith(S.Boolean, { nullable: true, default: () => true as const }),
  "destinationPageId": ContentId,
  "titleOptions": S.optionalWith(CopyPageHierarchyTitleOptions, { nullable: true })
}) {}

export class CopyPageParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

export class CopyPageRequestDestinationType extends S.Literal("space", "existing_page", "parent_page", "parent_content") {}

/**
* Defines where the page will be copied to, and can be one of the following types.
* 
*   - `parent_page`: page will be copied as a child of the specified parent page
*   - `parent_content`: page will be copied as a child of the specified parent content
*   - `space`: page will be copied to the specified space as a root page on the space
*   - `existing_page`: page will be copied and replace the specified page
*/
export class CopyPageRequestDestination extends S.Class<CopyPageRequestDestination>("CopyPageRequestDestination")({
  "type": CopyPageRequestDestinationType,
  /**
* The space key for `space` type, and content id for `parent_page`, `parent_content`, and `existing_page`
*/
"value": S.String
}) {}

/**
* The content format type. Set the value of this property to
* the name of the format being used, e.g. 'storage'.
*/
export class ContentBodyCreateRepresentation extends S.Literal("view", "export_view", "styled_view", "storage", "editor", "editor2", "anonymous_export_view", "wiki", "atlas_doc_format", "plain", "raw") {}

/**
* This object is used when creating or updating content.
*/
export class ContentBodyCreate extends S.Class<ContentBodyCreate>("ContentBodyCreate")({
  /**
* The body of the content in the relevant format.
*/
"value": S.String,
  /**
* The content format type. Set the value of this property to
* the name of the format being used, e.g. 'storage'.
*/
"representation": ContentBodyCreateRepresentation
}) {}

export class CopyPageRequest extends S.Class<CopyPageRequest>("CopyPageRequest")({
  /**
* If set to `true`, attachments are copied to the destination page.
*/
"copyAttachments": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, page permissions are copied to the destination page.
*/
"copyPermissions": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, content properties are copied to the destination page.
*/
"copyProperties": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, labels are copied to the destination page.
*/
"copyLabels": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* If set to `true`, custom contents are copied to the destination page.
*/
"copyCustomContents": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "destination": CopyPageRequestDestination,
  /**
* If defined, this will replace the title of the destination page.
*/
"pageTitle": S.optionalWith(S.String, { nullable: true }),
  /**
* If defined, this will replace the body of the destination page.
*/
"body": S.optionalWith(S.Struct({
  "storage": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "editor2": S.optionalWith(ContentBodyCreate, { nullable: true })
}), { nullable: true })
}) {}

export class PermissionSubjectWithGroupIdType extends S.Literal("user", "group") {}

/**
* The user or group that the permission applies to.
*/
export class PermissionSubjectWithGroupId extends S.Class<PermissionSubjectWithGroupId>("PermissionSubjectWithGroupId")({
  "type": PermissionSubjectWithGroupIdType,
  /**
* for `type=user`, identifier should be user's accountId or `anonymous` for anonymous users
* 
* for `type=group`, identifier should be ID of the group
*/
"identifier": S.String
}) {}

/**
* The content permission operation to check.
*/
export class ContentPermissionRequestOperation extends S.Literal("read", "update", "delete") {}

/**
* This object represents the request for the content permission check API.
*/
export class ContentPermissionRequest extends S.Class<ContentPermissionRequest>("ContentPermissionRequest")({
  "subject": PermissionSubjectWithGroupId,
  /**
* The content permission operation to check.
*/
"operation": ContentPermissionRequestOperation
}) {}

export class Message extends S.Class<Message>("Message")({
  "translation": S.optionalWith(S.String, { nullable: true }),
  "args": S.Array(S.Union(S.String,
S.Record({ key: S.String, value: S.Unknown })))
}) {}

/**
* This object represents the response for the content permission check API. If the user or group does not have
* permissions, the following errors may be returned:
* 
* - Group does not have permission to the space
* - Group does not have permission to the content
* - User is not allowed to use Confluence
* - User does not have permission to the space
* - User does not have permission to the content
* - Anonymous users are not allowed to use Confluence
* - Anonymous user does not have permission to the space
* - Anonymous user does not have permission to the content
*/
export class PermissionCheckResponse extends S.Class<PermissionCheckResponse>("PermissionCheckResponse")({
  "hasPermission": S.Boolean,
  "errors": S.optionalWith(S.Array(Message), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class GetRestrictionsParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("restrictions.user", "read.restrictions.user", "update.restrictions.user", "restrictions.group", "read.restrictions.group", "update.restrictions.group", "content")), { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 100 as const })
}) {}

export class ContentRestrictionArray extends S.Class<ContentRestrictionArray>("ContentRestrictionArray")({
  "results": S.Array(ContentRestriction),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  /**
* This property is used by the UI to figure out whether a set of restrictions
* has changed.
*/
"restrictionsHash": S.String,
  "_links": GenericLinks
}) {}

export class UpdateRestrictionsParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("restrictions.user", "read.restrictions.user", "update.restrictions.user", "restrictions.group", "read.restrictions.group", "update.restrictions.group", "content")), { nullable: true })
}) {}

/**
* The restriction operation applied to content.
*/
export class ContentRestrictionUpdateOperation extends S.Literal("administer", "copy", "create", "delete", "export", "move", "purge", "purge_version", "read", "restore", "update", "use") {}

export class ContentRestrictionUpdate extends S.Class<ContentRestrictionUpdate>("ContentRestrictionUpdate")({
  /**
* The restriction operation applied to content.
*/
"operation": ContentRestrictionUpdateOperation,
  /**
* The users/groups that the restrictions will be applied to. At least one of
* `user` or `group` must be specified for this object.
*/
"restrictions": S.Struct({
  /**
* The groups that the restrictions will be applied to. This array must
* have at least one item, otherwise it should be omitted.
*/
"group": S.optionalWith(S.Array(S.Struct({
  /**
* Set to 'group'.
*/
"type": S.Literal("group"),
  /**
* The id of the group.
*/
"id": S.optionalWith(S.String, { nullable: true })
})), { nullable: true }),
  "user": S.optionalWith(S.Union(S.Array(S.suspend(() => User)),
UserArray), { nullable: true })
}),
  "content": S.optionalWith(S.suspend(() => Content), { nullable: true })
}) {}

export class ContentRestrictionAddOrUpdateArray extends S.Union(S.Struct({
  "results": S.Array(ContentRestrictionUpdate),
  "start": S.optionalWith(S.Int, { nullable: true }),
  "limit": S.optionalWith(S.Int, { nullable: true }),
  "size": S.optionalWith(S.Int, { nullable: true }),
  /**
* This property is used by the UI to figure out whether a set of restrictions
* has changed.
*/
"restrictionsHash": S.optionalWith(S.String, { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}),
S.Array(ContentRestrictionUpdate)) {}

export class AddRestrictionsParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("restrictions.user", "read.restrictions.user", "update.restrictions.user", "restrictions.group", "read.restrictions.group", "update.restrictions.group", "content")), { nullable: true })
}) {}

export class DeleteRestrictionsParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("restrictions.user", "read.restrictions.user", "update.restrictions.user", "restrictions.group", "read.restrictions.group", "update.restrictions.group", "content")), { nullable: true })
}) {}

export class GetRestrictionsByOperationParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("restrictions.user", "restrictions.group", "content")), { nullable: true })
}) {}

export class GetRestrictionsByOperation200 extends S.Record({ key: S.String, value: S.Unknown }) {}

export class GetRestrictionsForOperationParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("restrictions.user", "restrictions.group", "content")), { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 100 as const })
}) {}

export class GetContentRestrictionStatusForUserParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class AddUserToContentRestrictionParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class RemoveUserFromContentRestrictionParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetContentStateParamsStatus extends S.Literal("current", "draft", "archived") {}

export class GetContentStateParams extends S.Struct({
  "status": S.optionalWith(GetContentStateParamsStatus, { nullable: true, default: () => "current" as const })
}) {}

export class ContentState extends S.Class<ContentState>("ContentState")({
  /**
* identifier of content state. If 0, 1, or 2, this is a default space state
*/
"id": S.Int,
  /**
* name of content state.
*/
"name": S.String,
  /**
* hex string representing color of state
*/
"color": S.String
}) {}

export class ContentStateResponse extends S.Class<ContentStateResponse>("ContentStateResponse")({
  /**
* Null or content state
*/
"contentState": S.optionalWith(ContentState, { nullable: true }),
  /**
* Timestamp of last publish event where content state changed
*/
"lastUpdated": S.optionalWith(S.String, { nullable: true })
}) {}

export class SetContentStateParamsStatus extends S.Literal("current", "draft") {}

export class SetContentStateParams extends S.Struct({
  "status": SetContentStateParamsStatus
}) {}

export class ContentStateRestInput extends S.Class<ContentStateRestInput>("ContentStateRestInput")({
  /**
* Name of content state. Maximum 20 characters.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Color of state. Must be in 6 digit hex form (#FFFFFF). The default colors offered in the UI are:
*  #ff7452 (red),
*  #2684ff (blue),
*  #ffc400 (yellow),
*  #57d9a3 (green), and
*  #8777d9 (purple)
*/
"color": S.optionalWith(S.String, { nullable: true }),
  /**
* id of state. This can be 0,1, or 2 if you wish to specify a default space state.
*/
"id": S.optionalWith(S.Int, { nullable: true })
}) {}

export class RemoveContentStateParamsStatus extends S.Literal("current", "draft") {}

export class RemoveContentStateParams extends S.Struct({
  "status": S.optionalWith(RemoveContentStateParamsStatus, { nullable: true })
}) {}

export class AvailableContentStates extends S.Class<AvailableContentStates>("AvailableContentStates")({
  /**
* Space suggested content states that can be used in the space.
* This list can be empty if there are no space content states defined in the space or if space content states are disabled in the space.
* All spaces start with 4 default space content states, and this can be modified in the UI under space settings.
*/
"spaceContentStates": S.Array(S.Record({ key: S.String, value: S.Unknown })),
  /**
* Custom content states that can be used by the user on the content of this call.
* This list can be empty if there are no custom content states defined by the user or if custom content states are disabled in the space of the content.
* This will at most have 3 of the most recently published content states. 
* Only the calling user has access to place these states on content, but all users can see these states once they are placed.
*/
"customContentStates": S.Array(S.Record({ key: S.String, value: S.Unknown }))
}) {}

export class RestoreContentVersionParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

/**
* Set to 'restore'.
*/
export class VersionRestoreOperationKey extends S.Literal("restore") {}

export class VersionRestore extends S.Class<VersionRestore>("VersionRestore")({
  /**
* Set to 'restore'.
*/
"operationKey": VersionRestoreOperationKey,
  "params": S.Struct({
  /**
* The version number to be restored.
*/
"versionNumber": S.Int,
  /**
* Description for the version.
*/
"message": S.String,
  /**
* If true, the content title will be the same as the title from the version restored. Defaults to `false`.
*/
"restoreTitle": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
})
}) {}

export class GetCustomContentStates200 extends S.Array(ContentState) {}

export class AsyncConvertContentBodyRequestParamsEmbeddedContentRender extends S.Literal("current", "version-at-save") {}

export class AsyncConvertContentBodyRequestParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.String), { nullable: true }),
  "spaceKeyContext": S.optionalWith(S.String, { nullable: true }),
  "contentIdContext": S.optionalWith(S.String, { nullable: true }),
  "allowCache": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "embeddedContentRender": S.optionalWith(AsyncConvertContentBodyRequestParamsEmbeddedContentRender, { nullable: true, default: () => "current" as const })
}) {}

export class AsyncContentBodyRepresentation extends S.Literal("view", "export_view", "styled_view", "storage", "editor", "editor2", "anonymous_export_view", "wiki", "atlas_doc_format") {}

/**
* Rerunning is reserved for when the job is working, but there is a previous run's value in the cache. You may choose to continue polling, or use the cached value.
*/
export class AsyncContentBodyStatus extends S.Literal("WORKING", "QUEUED", "FAILED", "COMPLETED", "RERUNNING") {}

export class AsyncContentBody extends S.Class<AsyncContentBody>("AsyncContentBody")({
  "value": S.optionalWith(S.String, { nullable: true }),
  "representation": S.optionalWith(AsyncContentBodyRepresentation, { nullable: true }),
  "renderTaskId": S.optionalWith(S.String, { nullable: true }),
  "error": S.optionalWith(S.String, { nullable: true }),
  /**
* Rerunning is reserved for when the job is working, but there is a previous run's value in the cache. You may choose to continue polling, or use the cached value.
*/
"status": S.optionalWith(AsyncContentBodyStatus, { nullable: true }),
  "embeddedContent": S.optionalWith(S.Array(EmbeddedContent), { nullable: true }),
  "webresource": S.optionalWith(WebResourceDependencies, { nullable: true }),
  "mediaToken": S.optionalWith(S.Struct({
  "collectionIds": S.optionalWith(S.Array(S.String), { nullable: true }),
  "contentId": S.optionalWith(S.String, { nullable: true }),
  "expiryDateTime": S.optionalWith(S.String, { nullable: true }),
  "fileIds": S.optionalWith(S.Array(S.String), { nullable: true }),
  "token": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "content": S.optionalWith(S.String, { nullable: true }),
  "embeddedContent": S.optionalWith(S.String, { nullable: true }),
  "webresource": S.optionalWith(S.String, { nullable: true }),
  "mediaToken": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class BulkAsyncConvertContentBodyResponseParams extends S.Struct({
  "ids": S.Array(S.String)
}) {}

export class AsyncContentBodyArray extends S.Array(AsyncContentBody) {}

/**
* Mode used for rendering embedded content, such as attachments. - `current` renders the embedded content using the latest version. - `version-at-save` renders the embedded content using the version at the time of save.
*/
export class ContentBodyConversionInputEmbeddedContentRender extends S.Literal("current", "version-at-save") {}

export class ContentBodyConversionInput extends S.Class<ContentBodyConversionInput>("ContentBodyConversionInput")({
  /**
* The name of the target format for the content body conversion.
*/
"to": S.String,
  /**
* If `false`, the cache will erase its current value and begin a new conversion. If `true`, the cache will not erase its current value, and will set the status of the async conversion to RERUNNING. Once the data is updated, the status will change to COMPLETED. Large macros that take a long time to convert and that need not be immediately up to date (e.g. a macro in which the new conversion result is the same as a previous conversion result that was completed within the last 5 minutes) should set this field to `true`. Cache values are stored per user per content body and expansions.
*/
"allowCache": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  /**
* The space key used for resolving embedded content (page includes, files, and links) in the content body. For example, if the source content contains the link `<ac:link><ri:page ri:content-title="Example page" /><ac:link>` and the `spaceKeyContext=TEST` parameter is provided, then the link will be converted into a link to the "Example page" page in the "TEST" space.
*/
"spaceKeyContext": S.optionalWith(S.String, { nullable: true }),
  /**
* The content ID used to find the space for resolving embedded content (page includes, files, and links) in the content body. For example, if the source content contains the link `<ac:link><ri:page ri:content-title="Example page" /><ac:link>` and the `contentIdContext=123` parameter is provided, then the link will be converted into a link to the "Example page" page in the same space that has the content with ID=123. Note that `spaceKeyContext` will be ignored if this parameter is provided.
*/
"contentIdContext": S.optionalWith(S.String, { nullable: true }),
  /**
* Mode used for rendering embedded content, such as attachments. - `current` renders the embedded content using the latest version. - `version-at-save` renders the embedded content using the version at the time of save.
*/
"embeddedContentRender": S.optionalWith(ContentBodyConversionInputEmbeddedContentRender, { nullable: true, default: () => "current" as const }),
  /**
* A multi-value, comma-separated parameter indicating which properties of the content to expand and populate. Expands are dependent
* on the `to` conversion format and may be irrelevant for certain conversions (e.g. `macroRenderedOutput` is redundant when
* converting to `view` format). 
* 
* If rendering to `view` format, and the body content being converted includes arbitrary nested content (such as macros); then it is 
* necessary to include webresource expands in the request. Webresources for content body are the batched JS and CSS dependencies for
* any nested dynamic content (i.e. macros).
* 
* - `embeddedContent` returns metadata for nested content (e.g. page included using page include macro)
* - `mediaToken` returns JWT token for retrieving attachment data from Media API
* - `macroRenderedOutput` additionally converts body to view format
* - `webresource.superbatch.uris.js` returns all common JS dependencies as static URLs
* - `webresource.superbatch.uris.css` returns all common CSS dependencies as static URLs
* - `webresource.superbatch.uris.all` returns all common dependencies as static URLs
* - `webresource.superbatch.tags.all` returns all common JS dependencies as html `<script>` tags
* - `webresource.superbatch.tags.css` returns all common CSS dependencies as html `<style>` tags
* - `webresource.superbatch.tags.js` returns all common dependencies as html `<script>` and `<style>` tags
* - `webresource.uris.js` returns JS dependencies specific to conversion
* - `webresource.uris.css` returns CSS dependencies specific to conversion
* - `webresource.uris.all` returns all dependencies specific to conversion     
* - `webresource.tags.all` returns common JS dependencies as html `<script>` tags
* - `webresource.tags.css` returns common CSS dependencies as html `<style>` tags
* - `webresource.tags.js` returns common dependencies as html `<script>` and `<style>` tags
*/
"expand": S.optionalWith(S.Array(S.String), { nullable: true }),
  "body": ContentBodyCreate
}) {}

export class BulkContentBodyConversionInput extends S.Class<BulkContentBodyConversionInput>("BulkContentBodyConversionInput")({
  "conversionInputs": S.optionalWith(S.Array(ContentBodyConversionInput), { nullable: true })
}) {}

export class AsyncIdArray extends S.Array(AsyncId) {}

export class GetAllLabelContentParamsType extends S.Literal("page", "blogpost", "attachment", "page_template") {}

export class GetAllLabelContentParams extends S.Struct({
  "name": S.optionalWith(S.NullOr(S.String), { default: () => null }),
  "type": S.optionalWith(S.NullOr(GetAllLabelContentParamsType), { default: () => null }),
  "start": S.optionalWith(S.Int, { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int, { nullable: true, default: () => 200 as const })
}) {}

export class LabeledContentType extends S.Literal("page", "blogpost", "attachment", "page_template") {}

export class LabeledContent extends S.Class<LabeledContent>("LabeledContent")({
  "contentType": LabeledContentType,
  "contentId": S.Int,
  /**
* Title of the content.
*/
"title": S.String
}) {}

export class LabeledContentPageResponse extends S.Class<LabeledContentPageResponse>("LabeledContentPageResponse")({
  "results": S.Array(LabeledContent),
  "start": S.optionalWith(S.Int, { nullable: true }),
  "limit": S.optionalWith(S.Int, { nullable: true }),
  "size": S.Int
}) {}

export class LabelDetails extends S.Class<LabelDetails>("LabelDetails")({
  "label": Label,
  "associatedContents": S.optionalWith(LabeledContentPageResponse, { nullable: true })
}) {}

export class GetGroupsParamsAccessType extends S.Literal("user", "admin", "site-admin") {}

export class GetGroupsParams extends S.Struct({
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 200 as const }),
  "accessType": S.optionalWith(S.NullOr(GetGroupsParamsAccessType), { default: () => null })
}) {}

/**
* Same as GroupArray but with `_links` property.
*/
export class GroupArrayWithLinks extends S.Class<GroupArrayWithLinks>("GroupArrayWithLinks")({
  "results": S.Array(Group),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  /**
* This property will return total count of the objects before pagination is applied.
* This value is returned if `shouldReturnTotalSize` is set to `true`.
*/
"totalSize": S.optionalWith(S.Int, { nullable: true, default: () => 0 as const }),
  "_links": GenericLinks
}) {}

export class GroupName extends S.Class<GroupName>("GroupName")({
  "name": S.String
}) {}

export class GetGroupByGroupIdParams extends S.Struct({
  "id": S.String
}) {}

export class RemoveGroupByIdParams extends S.Struct({
  "id": S.String
}) {}

export class SearchGroupsParams extends S.Struct({
  "query": S.String,
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 200 as const }),
  "shouldReturnTotalSize": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const })
}) {}

export class GetGroupMembersByGroupIdParams extends S.Struct({
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 200 as const }),
  "shouldReturnTotalSize": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "expand": S.optionalWith(S.Array(S.Literal("operations", "personalSpace", "isExternalCollaborator")), { nullable: true })
}) {}

export class AddUserToGroupByGroupIdParams extends S.Struct({
  "groupId": S.String
}) {}

export class AccountId extends S.Class<AccountId>("AccountId")({
  "accountId": S.String
}) {}

export class RemoveMemberFromGroupByGroupIdParams extends S.Struct({
  "groupId": S.String,
  "accountId": S.String,
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetTasksParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 100 as const })
}) {}

/**
* Current status of a long running task
* 
* Status keys:
* 
* - `ERROR_UNKNOWN` - Generic error
* - `ERROR_LOCK_FAILED` - Could not get the lock on destination space
* - `ERROR_RELINK` - Error when relink pages/attachments
* - `ERROR_COPY_PAGE` - Error while copying 1 page
* - `WARN_RENAME_PAGE` - Warning page is rename during copy
* - `WARN_IGNORE_COPY_PERMISSION` - Warning could not copy permission
* - `WARN_IGNORE_COPY_ATTACHMENT` - Warning could not copy attachment
* - `WARN_IGNORE_DELETE_PAGE` - Warning ignoring delete of a non agreed on page
* - `STATUS_COPIED_PAGES` - Message total pages are copied
* - `STATUS_COPYING_PAGES` - Message copy pages
* - `STATUS_RELINK_PAGES` - Message relink pages/attachments
* - `STATUS_DELETING_PAGES` - Message delete pages
* - `STATUS_DELETED_PAGES` - Message total pages are deleted
* - `STATUS_MOVING_PAGES` - Message move pages
* - `WARN_IGNORE_VIEW_RESTRICTED` - Permission changed - view restricted
* - `WARN_IGNORE_EDIT_RESTRICTED` - Permission changed - edit restricted
* - `INITIALIZING_TASK` - Message when initializing task
* - `UNKNOWN_STATUS` - Message when status is unknown
*/
export class LongTaskStatus extends S.Class<LongTaskStatus>("LongTaskStatus")({
  /**
* the ARI for the long task, based on its ID
*/
"ari": S.optionalWith(S.String, { nullable: true }),
  "id": S.String,
  "name": S.Struct({
  "key": S.String,
  "args": S.Array(S.Struct({
  
}))
}),
  "elapsedTime": S.Int,
  "percentageComplete": S.Int,
  "successful": S.Boolean,
  "finished": S.Boolean,
  "messages": S.Array(Message),
  "status": S.optionalWith(S.String, { nullable: true }),
  "errors": S.optionalWith(S.Array(Message), { nullable: true }),
  "additionalDetails": S.optionalWith(S.Struct({
  "destinationId": S.optionalWith(S.String, { nullable: true }),
  "destinationUrl": S.optionalWith(S.String, { nullable: true }),
  "totalPageNeedToCopy": S.optionalWith(S.Int, { nullable: true }),
  "additionalProperties": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}) {}

export class LongTaskStatusArray extends S.Class<LongTaskStatusArray>("LongTaskStatusArray")({
  "results": S.Array(LongTaskStatus),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": GenericLinks
}) {}

/**
* Same as LongTaskStatus but with `_links` property.
* 
* Status keys:
* 
* - `ERROR_UNKNOWN` - Generic error
* - `ERROR_LOCK_FAILED` - Could not get the lock on destination space
* - `ERROR_RELINK` - Error when relink pages/attachments
* - `ERROR_COPY_PAGE` - Error while copying 1 page
* - `WARN_RENAME_PAGE` - Warning page is rename during copy
* - `WARN_IGNORE_COPY_PERMISSION` - Warning could not copy permission
* - `WARN_IGNORE_COPY_ATTACHMENT` - Warning could not copy attachment
* - `WARN_IGNORE_DELETE_PAGE` - Warning ignoring delete of a non agreed on page
* - `STATUS_COPIED_PAGES` - Message total pages are copied
* - `STATUS_COPYING_PAGES` - Message copy pages
* - `STATUS_RELINK_PAGES` - Message relink pages/attachments
* - `STATUS_DELETING_PAGES` - Message delete pages
* - `STATUS_DELETED_PAGES` - Message total pages are deleted
* - `STATUS_MOVING_PAGES` - Message move pages
* - `WARN_IGNORE_VIEW_RESTRICTED` - Permission changed - view restricted
* - `WARN_IGNORE_EDIT_RESTRICTED` - Permission changed - edit restricted
* - `INITIALIZING_TASK` - Message when initializing task
* - `UNKNOWN_STATUS` - Message when status is unknown
*/
export class LongTaskStatusWithLinks extends S.Class<LongTaskStatusWithLinks>("LongTaskStatusWithLinks")({
  /**
* the ARI for the long task, based on its ID
*/
"ari": S.optionalWith(S.String, { nullable: true }),
  "id": S.String,
  "name": S.Struct({
  "key": S.String,
  "args": S.Array(S.Struct({
  
}))
}),
  "elapsedTime": S.Int,
  "percentageComplete": S.Int,
  "successful": S.Boolean,
  "finished": S.Boolean,
  "messages": S.Array(Message),
  "_links": GenericLinks,
  "status": S.optionalWith(S.String, { nullable: true }),
  "errors": S.optionalWith(S.Array(Message), { nullable: true }),
  "additionalDetails": S.optionalWith(S.Struct({
  "destinationId": S.optionalWith(S.String, { nullable: true }),
  "destinationUrl": S.optionalWith(S.String, { nullable: true }),
  "totalPageNeedToCopy": S.optionalWith(S.Int, { nullable: true }),
  "additionalProperties": S.optionalWith(S.String, { nullable: true })
}), { nullable: true })
}) {}

export class FindTargetFromSourceParams extends S.Struct({
  "sourceStatus": S.optionalWith(S.String, { nullable: true }),
  "targetStatus": S.optionalWith(S.String, { nullable: true }),
  "sourceVersion": S.optionalWith(S.Int, { nullable: true }),
  "targetVersion": S.optionalWith(S.Int, { nullable: true }),
  "expand": S.optionalWith(S.Array(S.Literal("relationData", "source", "target")), { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 25 as const })
}) {}

export class RelationData extends S.Class<RelationData>("RelationData")({
  "createdBy": S.optionalWith(S.suspend(() => User), { nullable: true }),
  "createdDate": S.optionalWith(S.String, { nullable: true }),
  "friendlyCreatedDate": S.optionalWith(S.String, { nullable: true })
}) {}

export class Relation extends S.Class<Relation>("Relation")({
  "name": S.String,
  "relationData": S.optionalWith(RelationData, { nullable: true }),
  "source": S.optionalWith(S.Union(Content,
User,
Space), { nullable: true }),
  "target": S.optionalWith(S.Union(Content,
User,
Space), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "relationData": S.optionalWith(S.String, { nullable: true }),
  "source": S.optionalWith(S.String, { nullable: true }),
  "target": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": GenericLinks
}) {}

export class RelationArray extends S.Class<RelationArray>("RelationArray")({
  "results": S.Array(Relation),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": GenericLinks
}) {}

export class GetRelationshipParams extends S.Struct({
  "sourceStatus": S.optionalWith(S.String, { nullable: true }),
  "targetStatus": S.optionalWith(S.String, { nullable: true }),
  "sourceVersion": S.optionalWith(S.Int, { nullable: true }),
  "targetVersion": S.optionalWith(S.Int, { nullable: true }),
  "expand": S.optionalWith(S.Array(S.Literal("relationData", "source", "target")), { nullable: true })
}) {}

export class CreateRelationshipParams extends S.Struct({
  "sourceStatus": S.optionalWith(S.String, { nullable: true }),
  "targetStatus": S.optionalWith(S.String, { nullable: true }),
  "sourceVersion": S.optionalWith(S.Int, { nullable: true }),
  "targetVersion": S.optionalWith(S.Int, { nullable: true })
}) {}

export class DeleteRelationshipParams extends S.Struct({
  "sourceStatus": S.optionalWith(S.String, { nullable: true }),
  "targetStatus": S.optionalWith(S.String, { nullable: true }),
  "sourceVersion": S.optionalWith(S.Int, { nullable: true }),
  "targetVersion": S.optionalWith(S.Int, { nullable: true })
}) {}

export class FindSourcesForTargetParams extends S.Struct({
  "sourceStatus": S.optionalWith(S.String, { nullable: true }),
  "targetStatus": S.optionalWith(S.String, { nullable: true }),
  "sourceVersion": S.optionalWith(S.Int, { nullable: true }),
  "targetVersion": S.optionalWith(S.Int, { nullable: true }),
  "expand": S.optionalWith(S.Array(S.Literal("relationData", "source", "target")), { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 25 as const })
}) {}

export class SearchByCQLParamsExcerpt extends S.Literal("highlight", "indexed", "none", "highlight_unescaped", "indexed_unescaped") {}

export class SearchByCQLParamsSitePermissionTypeFilter extends S.Literal("all", "externalCollaborator", "none") {}

export class SearchByCQLParams extends S.Struct({
  "cql": S.String,
  "cqlcontext": S.optionalWith(S.String, { nullable: true }),
  "cursor": S.optionalWith(S.String, { nullable: true }),
  "next": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "prev": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 25 as const }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "includeArchivedSpaces": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "excludeCurrentSpaces": S.optionalWith(S.Boolean, { nullable: true, default: () => false as const }),
  "excerpt": S.optionalWith(SearchByCQLParamsExcerpt, { nullable: true, default: () => "highlight" as const }),
  "sitePermissionTypeFilter": S.optionalWith(SearchByCQLParamsSitePermissionTypeFilter, { nullable: true, default: () => "none" as const }),
  "_": S.optionalWith(S.Int, { nullable: true }),
  "expand": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

export class ContainerSummary extends S.Class<ContainerSummary>("ContainerSummary")({
  "title": S.String,
  "displayUrl": S.String
}) {}

export class Breadcrumb extends S.Class<Breadcrumb>("Breadcrumb")({
  "label": S.String,
  "url": S.String,
  "separator": S.String
}) {}

export class SearchResult extends S.Class<SearchResult>("SearchResult")({
  "content": S.optionalWith(S.suspend(() => Content), { nullable: true }),
  "user": S.optionalWith(S.suspend(() => User), { nullable: true }),
  "space": S.optionalWith(S.suspend(() => Space), { nullable: true }),
  "title": S.String,
  "excerpt": S.String,
  "url": S.String,
  "resultParentContainer": S.optionalWith(ContainerSummary, { nullable: true }),
  "resultGlobalContainer": S.optionalWith(ContainerSummary, { nullable: true }),
  "breadcrumbs": S.Array(Breadcrumb),
  "entityType": S.String,
  "iconCssClass": S.String,
  "lastModified": S.String,
  "friendlyLastModified": S.optionalWith(S.String, { nullable: true }),
  "score": S.optionalWith(S.Number, { nullable: true })
}) {}

export class SearchPageResponseSearchResult extends S.Class<SearchPageResponseSearchResult>("SearchPageResponseSearchResult")({
  "results": S.Array(SearchResult),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "totalSize": S.Int,
  "cqlQuery": S.String,
  "searchDuration": S.Int,
  "archivedResultCount": S.optionalWith(S.Int, { nullable: true }),
  "_links": GenericLinks
}) {}

export class SearchUserParamsSitePermissionTypeFilter extends S.Literal("all", "externalCollaborator", "none") {}

export class SearchUserParams extends S.Struct({
  "cql": S.String,
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 25 as const }),
  "expand": S.optionalWith(S.Array(S.String), { nullable: true }),
  "sitePermissionTypeFilter": S.optionalWith(SearchUserParamsSitePermissionTypeFilter, { nullable: true, default: () => "none" as const })
}) {}

export class GetLookAndFeelSettingsParams extends S.Struct({
  "spaceKey": S.optionalWith(S.String, { nullable: true })
}) {}

export class LookAndFeelSettingsSelected extends S.Literal("global", "custom") {}

export class LookAndFeelSettings extends S.Class<LookAndFeelSettings>("LookAndFeelSettings")({
  "selected": LookAndFeelSettingsSelected,
  "global": LookAndFeel,
  "theme": S.optionalWith(LookAndFeel, { nullable: true }),
  "custom": LookAndFeel
}) {}

export class LookAndFeelSelectionLookAndFeelType extends S.Literal("global", "custom", "theme") {}

/**
* Look and feel selection
*/
export class LookAndFeelSelection extends S.Class<LookAndFeelSelection>("LookAndFeelSelection")({
  /**
* The key of the space for which the look and feel settings will be
* set.
*/
"spaceKey": S.String,
  "lookAndFeelType": LookAndFeelSelectionLookAndFeelType
}) {}

export class UpdateLookAndFeelSettingsParams extends S.Struct({
  "spaceKey": S.optionalWith(S.String, { nullable: true })
}) {}

export class LookAndFeelWithLinks extends S.Class<LookAndFeelWithLinks>("LookAndFeelWithLinks")({
  "_links": S.optionalWith(GenericLinks, { nullable: true }),
  "headings": S.Struct({
  "color": S.String
}),
  "links": S.Struct({
  "color": S.String
}),
  "menus": MenusLookAndFeel,
  "header": HeaderLookAndFeel,
  "horizontalHeader": S.optionalWith(HorizontalHeaderLookAndFeel, { nullable: true }),
  "content": ContentLookAndFeel,
  "bordersAndDividers": S.Struct({
  "color": S.String
}),
  "spaceReference": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}) {}

export class ResetLookAndFeelSettingsParams extends S.Struct({
  "spaceKey": S.optionalWith(S.String, { nullable: true })
}) {}

export class SystemInfoEntity extends S.Class<SystemInfoEntity>("SystemInfoEntity")({
  "cloudId": S.String,
  "commitHash": S.String,
  "baseUrl": S.optionalWith(S.String, { nullable: true }),
  "fallbackBaseUrl": S.optionalWith(S.String, { nullable: true }),
  "edition": S.optionalWith(S.String, { nullable: true }),
  "siteTitle": S.optionalWith(S.String, { nullable: true }),
  "defaultLocale": S.optionalWith(S.String, { nullable: true }),
  "defaultTimeZone": S.optionalWith(S.String, { nullable: true }),
  "microsPerimeter": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetThemesParams extends S.Struct({
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 100 as const })
}) {}

/**
* Theme object without links. Used in ThemeArray.
*/
export class ThemeNoLinks extends S.Class<ThemeNoLinks>("ThemeNoLinks")({
  "themeKey": S.String,
  "name": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(S.String, { nullable: true }),
  "icon": S.optionalWith(Icon, { nullable: true })
}) {}

export class ThemeArray extends S.Class<ThemeArray>("ThemeArray")({
  "results": S.Array(ThemeNoLinks),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": GenericLinks
}) {}

/**
* The description of the new/updated space. Note, only the 'plain' representation
* can be used for the description when creating or updating a space.
*/
export class SpaceDescriptionCreate extends S.Class<SpaceDescriptionCreate>("SpaceDescriptionCreate")({
  "plain": S.Struct({
  /**
* The space description.
*/
"value": S.optionalWith(S.String, { nullable: true }),
  /**
* Set to 'plain'.
*/
"representation": S.optionalWith(S.String, { nullable: true })
})
}) {}

export class GroupCreateType extends S.Literal("group") {}

export class GroupCreate extends S.Class<GroupCreate>("GroupCreate")({
  "type": GroupCreateType.pipe(S.propertySignature, S.withConstructorDefault(() => "group" as const)),
  "id": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* This object represents a permission for given space. Permissions consist of
* at least one operation object with an accompanying subjects object.
* 
* The following combinations of `operation` and `targetType` values are
* valid for the `operation` object:
* 
*   - 'create': 'page', 'blogpost', 'comment', 'attachment'
*   - 'read': 'space'
*   - 'delete': 'page', 'blogpost', 'comment', 'attachment'
*   - 'export': 'space'
*   - 'administer': 'space'
*/
export class SpacePermissionCreate extends S.Class<SpacePermissionCreate>("SpacePermissionCreate")({
  /**
* The users and/or groups that the permission applies to.
*/
"subjects": S.optionalWith(S.Struct({
  "user": S.optionalWith(S.Struct({
  "results": S.Array(S.suspend(() => User)),
  "size": S.Int
}), { nullable: true }),
  "group": S.optionalWith(S.Struct({
  "results": S.Array(GroupCreate),
  "size": S.Int
}), { nullable: true })
}), { nullable: true }),
  "operation": OperationCheckResult,
  /**
* Grant anonymous users permission to use the operation.
*/
"anonymousAccess": S.Boolean.pipe(S.propertySignature, S.withConstructorDefault(() => false as const)),
  /**
* Grants access to unlicensed users from JIRA Service Desk when used
* with the 'read space' operation.
*/
"unlicensedAccess": S.Boolean.pipe(S.propertySignature, S.withConstructorDefault(() => false as const))
}) {}

/**
* This is the request object used when creating a new space.
*/
export class SpaceCreate extends S.Class<SpaceCreate>("SpaceCreate")({
  /**
* The name of the new space.
*/
"name": S.String.pipe(S.maxLength(200)),
  /**
* The key for the new space. Format: See [Space
* keys](https://confluence.atlassian.com/x/lqNMMQ). If `alias` is not provided, this is required.
*/
"key": S.optionalWith(S.String, { nullable: true }),
  /**
* This field will be used as the new identifier for the space in confluence page URLs.
* If the property is not provided the alias will be the provided key.
* This property is experimental and may be changed or removed in the future.
*/
"alias": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(SpaceDescriptionCreate, { nullable: true }),
  /**
* The permissions for the new space. If no permissions are provided, the
* [Confluence default space permissions](https://confluence.atlassian.com/x/UAgzKw#CreateaSpace-Spacepermissions)
* are applied. Note that if permissions are provided, the space is
* created with only the provided set of permissions, not
* including the default space permissions. Space permissions
* can be modified after creation using the space permissions
* endpoints, and a private space can be created using the
* create private space endpoint.
*/
"permissions": S.optionalWith(S.Array(SpacePermissionCreate), { nullable: true })
}) {}

/**
* The properties of a space that can be updated.
*/
export class SpaceUpdate extends S.Class<SpaceUpdate>("SpaceUpdate")({
  /**
* The updated name of the space.
*/
"name": S.optionalWith(S.String.pipe(S.maxLength(200)), { nullable: true }),
  "description": S.optionalWith(SpaceDescriptionCreate, { nullable: true }),
  /**
* The updated homepage for this space
*/
"homepage": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  /**
* The updated type for this space.
*/
"type": S.optionalWith(S.String, { nullable: true }),
  /**
* The updated status for this space.
*/
"status": S.optionalWith(S.String, { nullable: true })
}) {}

export class PermissionSubjectType extends S.Literal("user", "group") {}

/**
* The user or group that the permission applies to.
*/
export class PermissionSubject extends S.Class<PermissionSubject>("PermissionSubject")({
  "type": PermissionSubjectType,
  /**
* for `type=user`, identifier should be user's accountId or `anonymous` for anonymous users
* 
* for `type=group`, identifier should be the groupId.
*/
"identifier": S.String
}) {}

export class SpacePermissionRequestOperationKey extends S.Literal("administer", "archive", "copy", "create", "delete", "export", "move", "purge", "purge_version", "read", "restore", "restrict_content", "update", "use") {}

/**
* The space or content type that the operation applies to.
*/
export class SpacePermissionRequestOperationTarget extends S.Literal("page", "blogpost", "comment", "attachment", "space") {}

/**
* This object represents the request for the single space permission. Permissions consist of
* one operation object with an accompanying subjects object.
* 
* The following combinations of `operation.key` and `operation.target` values are
* valid for the `operation` object:
* ``` bash
* 'create': 'page', 'blogpost', 'comment', 'attachment'
* 'read': 'space'
* 'delete': 'page', 'blogpost', 'comment', 'attachment', 'space'
* 'export': 'space'
* 'administer': 'space'
* 'archive': 'page'
* 'restrict_content': 'space'
* ```
* 
* For example, to enable Delete Own permission, set the `operation` object to the following:
* ```
* "operation": {
*     "key": "delete",
*     "target": "space"
* }
* ```
* To enable Add/Delete Restrictions permissions, set the `operation` object to the following:
* ```
* "operation": {
*     "key": "restrict_content",
*     "target": "space"
* }
* ```
*/
export class SpacePermissionRequest extends S.Class<SpacePermissionRequest>("SpacePermissionRequest")({
  "subject": PermissionSubject,
  "operation": S.Struct({
  "key": SpacePermissionRequestOperationKey,
  /**
* The space or content type that the operation applies to.
*/
"target": SpacePermissionRequestOperationTarget
}),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class SpacePermissionV2OperationKey extends S.Literal("administer", "archive", "copy", "create", "delete", "export", "move", "purge", "purge_version", "read", "restore", "restrict_content", "update", "use") {}

/**
* The space or content type that the operation applies to.
*/
export class SpacePermissionV2OperationTarget extends S.Literal("page", "blogpost", "comment", "attachment", "space") {}

/**
* This object represents a single space permission. Permissions consist of
* at least one operation object with an accompanying subjects object.
* 
* The following combinations of `operation.key` and `operation.target` values are
* valid for the `operation` object:
* ``` bash
* 'create': 'page', 'blogpost', 'comment', 'attachment'
* 'read': 'space'
* 'delete': 'page', 'blogpost', 'comment', 'attachment', 'space'
* 'export': 'space'
* 'administer': 'space'
* 'archive': 'page'
* 'restrict_content': 'space'
* ```
* 
* For example, to enable Delete Own permission, set the `operation` object to the following:
* ```
* "operation": {
*     "key": "delete",
*     "target": "space"
* }
* ```
* To enable Add/Delete Restrictions permissions, set the `operation` object to the following:
* ```
* "operation": {
*     "key": "restrict_content",
*     "target": "space"
* }
* ```
*/
export class SpacePermissionV2 extends S.Class<SpacePermissionV2>("SpacePermissionV2")({
  "id": S.Int,
  "subject": PermissionSubject,
  "operation": S.Struct({
  "key": SpacePermissionV2OperationKey,
  /**
* The space or content type that the operation applies to.
*/
"target": SpacePermissionV2OperationTarget
}),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

/**
* This object represents a list of space permissions for custom content type for an individual user. Permissions consist of
* a subjects object and a list with at least one operation object.
*/
export class SpacePermissionCustomContent extends S.Class<SpacePermissionCustomContent>("SpacePermissionCustomContent")({
  "subject": PermissionSubject,
  "operations": S.Array(S.Struct({
  /**
* The operation type
*/
"key": S.Literal("read", "create", "delete"),
  /**
* The custom content type
*/
"target": S.String,
  /**
* Grant or restrict access
*/
"access": S.Boolean
}))
}) {}

export class SpaceSettingsUpdate extends S.Class<SpaceSettingsUpdate>("SpaceSettingsUpdate")({
  /**
* Defines whether an override for the space home should be used. This is
* used in conjunction with a space theme provided by an app. For
* example, if this property is set to true, a theme can display a page
* other than the space homepage when users visit the root URL for a
* space. This property allows apps to provide content-only theming
* without overriding the space home.
*/
"routeOverrideEnabled": S.optionalWith(S.Boolean, { nullable: true })
}) {}

/**
* Space suggested content states that users can choose from
*/
export class GetSpaceContentStates200 extends S.Array(ContentState) {}

export class ContentStateSettings extends S.Class<ContentStateSettings>("ContentStateSettings")({
  /**
* Whether users can place any content states on content
*/
"contentStatesAllowed": S.Boolean,
  /**
* Whether users can place their custom states on content
*/
"customContentStatesAllowed": S.Boolean,
  /**
* Whether users can place space suggested states on content
*/
"spaceContentStatesAllowed": S.Boolean,
  /**
* space suggested content states that users can choose from
*/
"spaceContentStates": S.optionalWith(S.Array(ContentState), { nullable: true })
}) {}

export class GetContentsWithStateParams extends S.Struct({
  "state-id": S.Int,
  "expand": S.optionalWith(S.Array(S.String), { nullable: true }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(100)), { nullable: true, default: () => 25 as const }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true })
}) {}

export class ThemeUpdate extends S.Class<ThemeUpdate>("ThemeUpdate")({
  /**
* The key of the theme to be set as the space theme.
*/
"themeKey": S.String
}) {}

export class GetWatchersForSpaceParams extends S.Struct({
  "start": S.optionalWith(S.String, { nullable: true }),
  "limit": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetLabelsForSpaceParamsPrefix extends S.Literal("global", "my", "team") {}

export class GetLabelsForSpaceParams extends S.Struct({
  "prefix": S.optionalWith(GetLabelsForSpaceParamsPrefix, { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 200 as const })
}) {}

export class AddLabelsToSpaceRequest extends S.Array(LabelCreate) {}

export class DeleteLabelFromSpaceParams extends S.Struct({
  "name": S.String,
  "prefix": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* The type of the template. Set to `page`.
*/
export class ContentTemplateUpdateTemplateType extends S.Literal("page") {}

/**
* The body of the new content. Does not apply to attachments.
* Only one body format should be specified as the property for
* this object, e.g. `storage`.
* 
* Note, `editor2` format is used by Atlassian only. `anonymous_export_view` is
* the same as `export_view` format but only content viewable by an anonymous
* user is included.
*/
export class ContentTemplateBodyCreate extends S.Class<ContentTemplateBodyCreate>("ContentTemplateBodyCreate")({
  "view": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "export_view": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "styled_view": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "storage": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "editor": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "editor2": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "wiki": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "atlas_doc_format": S.optionalWith(ContentBodyCreate, { nullable: true }),
  "anonymous_export_view": S.optionalWith(ContentBodyCreate, { nullable: true })
}) {}

/**
* This object is used to update content templates.
*/
export class ContentTemplateUpdate extends S.Class<ContentTemplateUpdate>("ContentTemplateUpdate")({
  /**
* The ID of the template being updated.
*/
"templateId": S.String,
  /**
* The name of the template. Set to the current `name` if this field is
* not being updated.
*/
"name": S.String,
  /**
* The type of the template. Set to `page`.
*/
"templateType": ContentTemplateUpdateTemplateType,
  "body": ContentTemplateBodyCreate,
  /**
* A description of the template.
*/
"description": S.optionalWith(S.String.pipe(S.maxLength(100)), { nullable: true }),
  /**
* Labels for the template.
*/
"labels": S.optionalWith(S.Array(Label), { nullable: true }),
  /**
* The key for the space of the template. Required if the template is a
* space template. Set this to the current `space.key`.
*/
"space": S.optionalWith(S.Struct({
  "key": S.String
}), { nullable: true })
}) {}

/**
* The body of the new content. Does not apply to attachments.
* Only one body format should be specified as the property for
* this object, e.g. `storage`.
* 
* Note, `editor2` format is used by Atlassian only. `anonymous_export_view` is
* the same as `export_view` format but only content viewable by an anonymous
* user is included.
*/
export class ContentTemplateBody extends S.Class<ContentTemplateBody>("ContentTemplateBody")({
  "view": S.optionalWith(ContentBody, { nullable: true }),
  "export_view": S.optionalWith(ContentBody, { nullable: true }),
  "styled_view": S.optionalWith(ContentBody, { nullable: true }),
  "storage": S.optionalWith(ContentBody, { nullable: true }),
  "editor": S.optionalWith(ContentBody, { nullable: true }),
  "editor2": S.optionalWith(ContentBody, { nullable: true }),
  "wiki": S.optionalWith(ContentBody, { nullable: true }),
  "atlas_doc_format": S.optionalWith(ContentBody, { nullable: true }),
  "anonymous_export_view": S.optionalWith(ContentBody, { nullable: true })
}) {}

export class ContentTemplate extends S.Class<ContentTemplate>("ContentTemplate")({
  "templateId": S.String,
  "originalTemplate": S.optionalWith(S.Struct({
  "pluginKey": S.optionalWith(S.String, { nullable: true }),
  "moduleKey": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "referencingBlueprint": S.optionalWith(S.String, { nullable: true }),
  "name": S.String,
  "description": S.String,
  "space": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  "labels": S.Array(Label),
  "templateType": S.String,
  "editorVersion": S.optionalWith(S.String, { nullable: true }),
  "body": S.optionalWith(ContentTemplateBody, { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "body": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": GenericLinks
}) {}

/**
* This object is used to create content templates.
*/
export class ContentTemplateCreate extends S.Class<ContentTemplateCreate>("ContentTemplateCreate")({
  /**
* The name of the new template.
*/
"name": S.String,
  /**
* The type of the new template. Set to `page`.
*/
"templateType": S.String,
  "body": ContentTemplateBodyCreate,
  /**
* A description of the new template.
*/
"description": S.optionalWith(S.String.pipe(S.maxLength(255)), { nullable: true }),
  /**
* Labels for the new template.
*/
"labels": S.optionalWith(S.Array(Label), { nullable: true }),
  /**
* The key for the space of the new template. Only applies to space templates.
* If the spaceKey is not specified, the template will be created as a global
* template.
*/
"space": S.optionalWith(S.Struct({
  "key": S.String
}), { nullable: true })
}) {}

export class GetBlueprintTemplatesParams extends S.Struct({
  "spaceKey": S.optionalWith(S.String, { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 25 as const }),
  "expand": S.optionalWith(S.Array(S.Literal("body", "body.storage")), { nullable: true })
}) {}

export class BlueprintTemplate extends S.Class<BlueprintTemplate>("BlueprintTemplate")({
  "templateId": S.String,
  "originalTemplate": S.Struct({
  "pluginKey": S.String,
  "moduleKey": S.String
}),
  "referencingBlueprint": S.String,
  "name": S.String,
  "description": S.String,
  "space": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
  "labels": S.Array(Label),
  "templateType": S.String,
  "editorVersion": S.optionalWith(S.String, { nullable: true }),
  "body": S.optionalWith(ContentTemplateBody, { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "body": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": GenericLinks
}) {}

export class BlueprintTemplateArray extends S.Class<BlueprintTemplateArray>("BlueprintTemplateArray")({
  "results": S.Array(BlueprintTemplate),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": GenericLinks
}) {}

export class GetContentTemplatesParams extends S.Struct({
  "spaceKey": S.optionalWith(S.String, { nullable: true }),
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 25 as const }),
  "expand": S.optionalWith(S.Array(S.Literal("body", "body.storage")), { nullable: true })
}) {}

export class ContentTemplateArray extends S.Class<ContentTemplateArray>("ContentTemplateArray")({
  "results": S.Array(ContentTemplate),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": GenericLinks
}) {}

export class GetContentTemplateParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("body", "body.storage")), { nullable: true })
}) {}

export class GetUserParams extends S.Struct({
  "accountId": S.String,
  "expand": S.optionalWith(S.Array(S.Literal("operations", "personalSpace", "isExternalCollaborator")), { nullable: true })
}) {}

export class GetAnonymousUserParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("operations")), { nullable: true })
}) {}

export class UserAnonymous extends S.Class<UserAnonymous>("UserAnonymous")({
  "type": S.String,
  "profilePicture": S.NullOr(Icon),
  "displayName": S.String,
  "operations": S.optionalWith(S.Array(OperationCheckResult), { nullable: true }),
  "_expandable": S.optionalWith(S.Struct({
  "operations": S.optionalWith(S.String, { nullable: true })
}), { nullable: true }),
  "_links": GenericLinks
}) {}

export class GetCurrentUserParams extends S.Struct({
  "expand": S.optionalWith(S.Array(S.Literal("operations", "personalSpace", "isExternalCollaborator")), { nullable: true })
}) {}

export class GetGroupMembershipsForUserParams extends S.Struct({
  "accountId": S.String,
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 200 as const })
}) {}

export class GetBulkUserLookupParams extends S.Struct({
  "accountId": S.String,
  "expand": S.optionalWith(S.Array(S.Literal("operations", "personalSpace", "isExternalCollaborator")), { nullable: true })
}) {}

export class BulkUserLookupType extends S.Literal("known", "unknown", "anonymous", "user") {}

export class BulkUserLookup extends S.Class<BulkUserLookup>("BulkUserLookup")({
  "type": BulkUserLookupType,
  "username": S.optionalWith(GenericUserName, { nullable: true }),
  "userKey": S.optionalWith(GenericUserKey, { nullable: true }),
  "accountId": S.NullOr(GenericAccountId),
  /**
* The account type of the user, may return empty string if unavailable.
*/
"accountType": S.String,
  /**
* The email address of the user. Depending on the user's privacy setting, this may return an empty string.
*/
"email": S.String,
  /**
* The public name or nickname of the user. Will always contain a value.
*/
"publicName": S.String,
  "profilePicture": S.NullOr(Icon),
  /**
* The displays name of the user. Depending on the user's privacy setting, this may be the same as publicName.
*/
"displayName": S.String,
  /**
* This displays user time zone. Depending on the user's privacy setting, this may return null.
*/
"timeZone": S.optionalWith(S.String, { nullable: true }),
  /**
* This is deprecated. Use `isGuest` instead to find out whether the user is a guest user.
*/
"isExternalCollaborator": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Whether the user is a guest user
*/
"isGuest": S.optionalWith(S.Boolean, { nullable: true }),
  "operations": S.optionalWith(S.Array(OperationCheckResult), { nullable: true }),
  "details": S.optionalWith(UserDetails, { nullable: true }),
  "personalSpace": S.optionalWith(S.suspend(() => Space), { nullable: true }),
  "_expandable": S.Struct({
  "operations": S.optionalWith(S.String, { nullable: true }),
  "details": S.optionalWith(S.String, { nullable: true }),
  "personalSpace": S.optionalWith(S.String, { nullable: true })
}),
  "_links": GenericLinks
}) {}

export class BulkUserLookupArray extends S.Class<BulkUserLookupArray>("BulkUserLookupArray")({
  "results": S.Array(BulkUserLookup),
  "start": S.Int,
  "limit": S.Int,
  "size": S.Int,
  "_links": GenericLinks
}) {}

export class GetContentWatchStatusParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class UserWatch extends S.Class<UserWatch>("UserWatch")({
  "watching": S.Boolean
}) {}

export class AddContentWatcherParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class RemoveContentWatcherParams extends S.Struct({
  "X-Atlassian-Token": S.String.pipe(S.propertySignature, S.withConstructorDefault(() => "no-check" as const)),
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class IsWatchingLabelParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class AddLabelWatcherParams extends S.Struct({
  "X-Atlassian-Token": S.String.pipe(S.propertySignature, S.withConstructorDefault(() => "no-check" as const)),
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class RemoveLabelWatcherParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class IsWatchingSpaceParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class AddSpaceWatcherParams extends S.Struct({
  "X-Atlassian-Token": S.String.pipe(S.propertySignature, S.withConstructorDefault(() => "no-check" as const)),
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class RemoveSpaceWatchParams extends S.Struct({
  "key": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetPrivacyUnsafeUserEmailParams extends S.Struct({
  "accountId": S.String
}) {}

export class AccountIdEmailRecord extends S.Class<AccountIdEmailRecord>("AccountIdEmailRecord")({
  "accountId": S.String,
  "email": S.String
}) {}

export class GetPrivacyUnsafeUserEmailBulkParams extends S.Struct({
  "accountId": S.Array(S.String)
}) {}

export class AccountIdEmailRecordArray extends S.Array(AccountIdEmailRecord) {}

export class RemoveModulesParams extends S.Struct({
  "moduleKey": S.Array(S.String)
}) {}

export class GetViewsParams extends S.Struct({
  "fromDate": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetViews200 extends S.Struct({
  /**
* The content ID.
*/
"id": S.optionalWith(S.Int, { nullable: true }),
  /**
* The total number of views for the content.
*/
"count": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetViewersParams extends S.Struct({
  "fromDate": S.optionalWith(S.String, { nullable: true })
}) {}

export class GetViewers200 extends S.Struct({
  /**
* The content ID.
*/
"id": S.optionalWith(S.Int, { nullable: true }),
  /**
* The total number of distinct viewers for the content.
*/
"count": S.optionalWith(S.Int, { nullable: true })
}) {}

export class GetUserPropertiesParams extends S.Struct({
  "start": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0)), { nullable: true, default: () => 0 as const }),
  "limit": S.optionalWith(S.Int.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(25)), { nullable: true, default: () => 5 as const })
}) {}

export class UserPropertyKeyArray extends S.Class<UserPropertyKeyArray>("UserPropertyKeyArray")({
  "results": S.Array(S.Struct({
  "key": S.optionalWith(S.String, { nullable: true })
})),
  "start": S.optionalWith(S.Int, { nullable: true }),
  "limit": S.optionalWith(S.Int, { nullable: true }),
  "size": S.optionalWith(S.Int, { nullable: true }),
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class UserProperty extends S.Class<UserProperty>("UserProperty")({
  "key": S.String,
  /**
* The value of the content property.
*/
"value": S.Struct({
  
}),
  /**
* a unique identifier for the user property
*/
"id": S.String,
  /**
* datetime when the property was last modified such as `2022-02-01T12:00:00.111Z`
*/
"lastModifiedDate": S.String,
  /**
* datetime when the property was created such as `2022-01-01T12:00:00.111Z`
*/
"createdDate": S.String,
  "_links": S.optionalWith(GenericLinks, { nullable: true })
}) {}

export class UserPropertyUpdate extends S.Class<UserPropertyUpdate>("UserPropertyUpdate")({
  /**
* The value of the user property.
*/
"value": S.Struct({
  
})
}) {}

export class UserPropertyCreate extends S.Class<UserPropertyCreate>("UserPropertyCreate")({
  /**
* The value of the user property.
*/
"value": S.Struct({
  
})
}) {}

export const make = (
  httpClient: HttpClient.HttpClient, 
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): ConfluenceV1Client => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse: <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ) => (
    request: HttpClientRequest.HttpClientRequest,
  ) => Effect.Effect<any, any> = options.transformClient
    ? (f) => (request) =>
        Effect.flatMap(
          Effect.flatMap(options.transformClient!(httpClient), (client) =>
            client.execute(request),
          ),
          f,
        )
    : (f) => (request) => Effect.flatMap(httpClient.execute(request), f)
  const decodeSuccess =
    <A, I, R>(schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, A, I, R>(tag: Tag, schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(ConfluenceV1ClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "getAuditRecords": (options) => HttpClientRequest.get(`/wiki/rest/api/audit`).pipe(
    HttpClientRequest.setUrlParams({ "startDate": options?.["startDate"] as any, "endDate": options?.["endDate"] as any, "searchString": options?.["searchString"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AuditRecordArray),
      orElse: unexpectedStatus
    }))
  ),
  "createAuditRecord": (options) => HttpClientRequest.post(`/wiki/rest/api/audit`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AuditRecord),
      orElse: unexpectedStatus
    }))
  ),
  "exportAuditRecords": (options) => HttpClientRequest.get(`/wiki/rest/api/audit/export`).pipe(
    HttpClientRequest.setUrlParams({ "startDate": options?.["startDate"] as any, "endDate": options?.["endDate"] as any, "searchString": options?.["searchString"] as any, "format": options?.["format"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getRetentionPeriod": () => HttpClientRequest.get(`/wiki/rest/api/audit/retention`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetentionPeriod),
      orElse: unexpectedStatus
    }))
  ),
  "setRetentionPeriod": (options) => HttpClientRequest.put(`/wiki/rest/api/audit/retention`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetentionPeriod),
      orElse: unexpectedStatus
    }))
  ),
  "getAuditRecordsForTimePeriod": (options) => HttpClientRequest.get(`/wiki/rest/api/audit/since`).pipe(
    HttpClientRequest.setUrlParams({ "number": options?.["number"] as any, "units": options?.["units"] as any, "searchString": options?.["searchString"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AuditRecordArray),
      orElse: unexpectedStatus
    }))
  ),
  "archivePages": (options) => HttpClientRequest.post(`/wiki/rest/api/content/archive`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LongTask),
      orElse: unexpectedStatus
    }))
  ),
  "publishSharedDraft": (draftId, options) => HttpClientRequest.put(`/wiki/rest/api/content/blueprint/instance/${draftId}`).pipe(
    HttpClientRequest.setUrlParams({ "status": options.params?.["status"] as any, "expand": options.params?.["expand"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Content),
      orElse: unexpectedStatus
    }))
  ),
  "publishLegacyDraft": (draftId, options) => HttpClientRequest.post(`/wiki/rest/api/content/blueprint/instance/${draftId}`).pipe(
    HttpClientRequest.setUrlParams({ "status": options.params?.["status"] as any, "expand": options.params?.["expand"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Content),
      orElse: unexpectedStatus
    }))
  ),
  "searchContentByCQL": (options) => HttpClientRequest.get(`/wiki/rest/api/content/search`).pipe(
    HttpClientRequest.setUrlParams({ "cql": options?.["cql"] as any, "cqlcontext": options?.["cqlcontext"] as any, "expand": options?.["expand"] as any, "cursor": options?.["cursor"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentArray),
      orElse: unexpectedStatus
    }))
  ),
  "deletePageTree": (id) => HttpClientRequest.del(`/wiki/rest/api/content/${id}/pageTree`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LongTask),
      orElse: unexpectedStatus
    }))
  ),
  "movePage": (pageId, position, targetId) => HttpClientRequest.put(`/wiki/rest/api/content/${pageId}/move/${position}/${targetId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(MovePage200),
      orElse: unexpectedStatus
    }))
  ),
  "createOrUpdateAttachments": (id, options) => HttpClientRequest.put(`/wiki/rest/api/content/${id}/child/attachment`).pipe(
    HttpClientRequest.setUrlParams({ "status": options.params?.["status"] as any }),
    HttpClientRequest.bodyFormDataRecord(options.payload as any),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentArray),
      orElse: unexpectedStatus
    }))
  ),
  "createAttachment": (id, options) => HttpClientRequest.post(`/wiki/rest/api/content/${id}/child/attachment`).pipe(
    HttpClientRequest.setUrlParams({ "status": options.params?.["status"] as any }),
    HttpClientRequest.bodyFormDataRecord(options.payload as any),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentArray),
      orElse: unexpectedStatus
    }))
  ),
  "updateAttachmentProperties": (id, attachmentId, options) => HttpClientRequest.put(`/wiki/rest/api/content/${id}/child/attachment/${attachmentId}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Content),
      orElse: unexpectedStatus
    }))
  ),
  "updateAttachmentData": (id, attachmentId, options) => HttpClientRequest.post(`/wiki/rest/api/content/${id}/child/attachment/${attachmentId}/data`).pipe(
    HttpClientRequest.bodyFormDataRecord(options as any),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Content),
      orElse: unexpectedStatus
    }))
  ),
  "downloadAttatchment": (id, attachmentId, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/child/attachment/${attachmentId}/download`).pipe(
    HttpClientRequest.setUrlParams({ "version": options?.["version"] as any, "status": options?.["status"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "302": () => Effect.void,
      "400": () => Effect.void,
      "401": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getContentDescendants": (id, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/descendant`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentChildren),
      orElse: unexpectedStatus
    }))
  ),
  "getDescendantsOfType": (id, type, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/descendant/${type}`).pipe(
    HttpClientRequest.setUrlParams({ "depth": options?.["depth"] as any, "expand": options?.["expand"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentArray),
      orElse: unexpectedStatus
    }))
  ),
  "getMacroBodyByMacroId": (id, version, macroId) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/history/${version}/macro/id/${macroId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(MacroInstance),
      orElse: unexpectedStatus
    }))
  ),
  "getAndConvertMacroBodyByMacroId": (id, version, macroId, to, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/history/${version}/macro/id/${macroId}/convert/${to}`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any, "spaceKeyContext": options?.["spaceKeyContext"] as any, "embeddedContentRender": options?.["embeddedContentRender"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentBody),
      "400": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getAndAsyncConvertMacroBodyByMacroId": (id, version, macroId, to, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/history/${version}/macro/id/${macroId}/convert/async/${to}`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any, "allowCache": options?.["allowCache"] as any, "spaceKeyContext": options?.["spaceKeyContext"] as any, "embeddedContentRender": options?.["embeddedContentRender"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AsyncId),
      orElse: unexpectedStatus
    }))
  ),
  "addLabelsToContent": (id, options) => HttpClientRequest.post(`/wiki/rest/api/content/${id}/label`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LabelArray),
      orElse: unexpectedStatus
    }))
  ),
  "removeLabelFromContentUsingQueryParameter": (id, options) => HttpClientRequest.del(`/wiki/rest/api/content/${id}/label`).pipe(
    HttpClientRequest.setUrlParams({ "name": options?.["name"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removeLabelFromContent": (id, label) => HttpClientRequest.del(`/wiki/rest/api/content/${id}/label/${label}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getWatchesForPage": (id, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/notification/child-created`).pipe(
    HttpClientRequest.setUrlParams({ "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(WatchArray),
      orElse: unexpectedStatus
    }))
  ),
  "getWatchesForSpace": (id, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/notification/created`).pipe(
    HttpClientRequest.setUrlParams({ "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpaceWatchArray),
      orElse: unexpectedStatus
    }))
  ),
  "copyPageHierarchy": (id, options) => HttpClientRequest.post(`/wiki/rest/api/content/${id}/pagehierarchy/copy`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LongTask),
      orElse: unexpectedStatus
    }))
  ),
  "copyPage": (id, options) => HttpClientRequest.post(`/wiki/rest/api/content/${id}/copy`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options.params?.["expand"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "checkContentPermission": (id, options) => HttpClientRequest.post(`/wiki/rest/api/content/${id}/permission/check`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PermissionCheckResponse),
      orElse: unexpectedStatus
    }))
  ),
  "getRestrictions": (id, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/restriction`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentRestrictionArray),
      orElse: unexpectedStatus
    }))
  ),
  "updateRestrictions": (id, options) => HttpClientRequest.put(`/wiki/rest/api/content/${id}/restriction`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options.params?.["expand"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentRestrictionArray),
      orElse: unexpectedStatus
    }))
  ),
  "addRestrictions": (id, options) => HttpClientRequest.post(`/wiki/rest/api/content/${id}/restriction`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options.params?.["expand"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentRestrictionArray),
      orElse: unexpectedStatus
    }))
  ),
  "deleteRestrictions": (id, options) => HttpClientRequest.del(`/wiki/rest/api/content/${id}/restriction`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentRestrictionArray),
      orElse: unexpectedStatus
    }))
  ),
  "getRestrictionsByOperation": (id, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/restriction/byOperation`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetRestrictionsByOperation200),
      orElse: unexpectedStatus
    }))
  ),
  "getRestrictionsForOperation": (id, operationKey, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/restriction/byOperation/${operationKey}`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentRestriction),
      orElse: unexpectedStatus
    }))
  ),
  "getIndividualGroupRestrictionStatusByGroupId": (id, operationKey, groupId) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/restriction/byOperation/${operationKey}/byGroupId/${groupId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "addGroupToContentRestrictionByGroupId": (id, operationKey, groupId) => HttpClientRequest.put(`/wiki/rest/api/content/${id}/restriction/byOperation/${operationKey}/byGroupId/${groupId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removeGroupFromContentRestriction": (id, operationKey, groupId) => HttpClientRequest.del(`/wiki/rest/api/content/${id}/restriction/byOperation/${operationKey}/byGroupId/${groupId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getContentRestrictionStatusForUser": (id, operationKey, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/restriction/byOperation/${operationKey}/user`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "addUserToContentRestriction": (id, operationKey, options) => HttpClientRequest.put(`/wiki/rest/api/content/${id}/restriction/byOperation/${operationKey}/user`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removeUserFromContentRestriction": (id, operationKey, options) => HttpClientRequest.del(`/wiki/rest/api/content/${id}/restriction/byOperation/${operationKey}/user`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getContentState": (id, options) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/state`).pipe(
    HttpClientRequest.setUrlParams({ "status": options?.["status"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentStateResponse),
      "401": () => Effect.void,
      "403": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "setContentState": (id, options) => HttpClientRequest.put(`/wiki/rest/api/content/${id}/state`).pipe(
    HttpClientRequest.setUrlParams({ "status": options.params?.["status"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentStateResponse),
      "400": () => Effect.void,
      "401": () => Effect.void,
      "403": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "removeContentState": (id, options) => HttpClientRequest.del(`/wiki/rest/api/content/${id}/state`).pipe(
    HttpClientRequest.setUrlParams({ "status": options?.["status"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentStateResponse),
      "401": () => Effect.void,
      "403": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getAvailableContentStates": (id) => HttpClientRequest.get(`/wiki/rest/api/content/${id}/state/available`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AvailableContentStates),
      "400": () => Effect.void,
      "401": () => Effect.void,
      "403": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "restoreContentVersion": (id, options) => HttpClientRequest.post(`/wiki/rest/api/content/${id}/version`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options.params?.["expand"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Version),
      orElse: unexpectedStatus
    }))
  ),
  "deleteContentVersion": (id, versionNumber) => HttpClientRequest.del(`/wiki/rest/api/content/${id}/version/${versionNumber}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getCustomContentStates": () => HttpClientRequest.get(`/wiki/rest/api/content-states`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCustomContentStates200),
      "401": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "asyncConvertContentBodyRequest": (to, options) => HttpClientRequest.post(`/wiki/rest/api/contentbody/convert/async/${to}`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options.params?.["expand"] as any, "spaceKeyContext": options.params?.["spaceKeyContext"] as any, "contentIdContext": options.params?.["contentIdContext"] as any, "allowCache": options.params?.["allowCache"] as any, "embeddedContentRender": options.params?.["embeddedContentRender"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AsyncId),
      orElse: unexpectedStatus
    }))
  ),
  "asyncConvertContentBodyResponse": (id) => HttpClientRequest.get(`/wiki/rest/api/contentbody/convert/async/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AsyncContentBody),
      orElse: unexpectedStatus
    }))
  ),
  "bulkAsyncConvertContentBodyResponse": (options) => HttpClientRequest.get(`/wiki/rest/api/contentbody/convert/async/bulk/tasks`).pipe(
    HttpClientRequest.setUrlParams({ "ids": options?.["ids"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AsyncContentBodyArray),
      orElse: unexpectedStatus
    }))
  ),
  "bulkAsyncConvertContentBodyRequest": (options) => HttpClientRequest.post(`/wiki/rest/api/contentbody/convert/async/bulk/tasks`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AsyncIdArray),
      orElse: unexpectedStatus
    }))
  ),
  "getAllLabelContent": (options) => HttpClientRequest.get(`/wiki/rest/api/label`).pipe(
    HttpClientRequest.setUrlParams({ "name": options?.["name"] as any, "type": options?.["type"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LabelDetails),
      orElse: unexpectedStatus
    }))
  ),
  "getGroups": (options) => HttpClientRequest.get(`/wiki/rest/api/group`).pipe(
    HttpClientRequest.setUrlParams({ "start": options?.["start"] as any, "limit": options?.["limit"] as any, "accessType": options?.["accessType"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GroupArrayWithLinks),
      orElse: unexpectedStatus
    }))
  ),
  "createGroup": (options) => HttpClientRequest.post(`/wiki/rest/api/group`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Group),
      orElse: unexpectedStatus
    }))
  ),
  "getGroupByGroupId": (options) => HttpClientRequest.get(`/wiki/rest/api/group/by-id`).pipe(
    HttpClientRequest.setUrlParams({ "id": options?.["id"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Group),
      orElse: unexpectedStatus
    }))
  ),
  "removeGroupById": (options) => HttpClientRequest.del(`/wiki/rest/api/group/by-id`).pipe(
    HttpClientRequest.setUrlParams({ "id": options?.["id"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "searchGroups": (options) => HttpClientRequest.get(`/wiki/rest/api/group/picker`).pipe(
    HttpClientRequest.setUrlParams({ "query": options?.["query"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any, "shouldReturnTotalSize": options?.["shouldReturnTotalSize"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GroupArrayWithLinks),
      orElse: unexpectedStatus
    }))
  ),
  "getGroupMembersByGroupId": (groupId, options) => HttpClientRequest.get(`/wiki/rest/api/group/${groupId}/membersByGroupId`).pipe(
    HttpClientRequest.setUrlParams({ "start": options?.["start"] as any, "limit": options?.["limit"] as any, "shouldReturnTotalSize": options?.["shouldReturnTotalSize"] as any, "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UserArray),
      orElse: unexpectedStatus
    }))
  ),
  "addUserToGroupByGroupId": (options) => HttpClientRequest.post(`/wiki/rest/api/group/userByGroupId`).pipe(
    HttpClientRequest.setUrlParams({ "groupId": options.params?.["groupId"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removeMemberFromGroupByGroupId": (options) => HttpClientRequest.del(`/wiki/rest/api/group/userByGroupId`).pipe(
    HttpClientRequest.setUrlParams({ "groupId": options?.["groupId"] as any, "accountId": options?.["accountId"] as any, "key": options?.["key"] as any, "username": options?.["username"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getTasks": (options) => HttpClientRequest.get(`/wiki/rest/api/longtask`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LongTaskStatusArray),
      orElse: unexpectedStatus
    }))
  ),
  "getTask": (id) => HttpClientRequest.get(`/wiki/rest/api/longtask/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LongTaskStatusWithLinks),
      orElse: unexpectedStatus
    }))
  ),
  "findTargetFromSource": (relationName, sourceType, sourceKey, targetType, options) => HttpClientRequest.get(`/wiki/rest/api/relation/${relationName}/from/${sourceType}/${sourceKey}/to/${targetType}`).pipe(
    HttpClientRequest.setUrlParams({ "sourceStatus": options?.["sourceStatus"] as any, "targetStatus": options?.["targetStatus"] as any, "sourceVersion": options?.["sourceVersion"] as any, "targetVersion": options?.["targetVersion"] as any, "expand": options?.["expand"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RelationArray),
      orElse: unexpectedStatus
    }))
  ),
  "getRelationship": (relationName, sourceType, sourceKey, targetType, targetKey, options) => HttpClientRequest.get(`/wiki/rest/api/relation/${relationName}/from/${sourceType}/${sourceKey}/to/${targetType}/${targetKey}`).pipe(
    HttpClientRequest.setUrlParams({ "sourceStatus": options?.["sourceStatus"] as any, "targetStatus": options?.["targetStatus"] as any, "sourceVersion": options?.["sourceVersion"] as any, "targetVersion": options?.["targetVersion"] as any, "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Relation),
      orElse: unexpectedStatus
    }))
  ),
  "createRelationship": (relationName, sourceType, sourceKey, targetType, targetKey, options) => HttpClientRequest.put(`/wiki/rest/api/relation/${relationName}/from/${sourceType}/${sourceKey}/to/${targetType}/${targetKey}`).pipe(
    HttpClientRequest.setUrlParams({ "sourceStatus": options?.["sourceStatus"] as any, "targetStatus": options?.["targetStatus"] as any, "sourceVersion": options?.["sourceVersion"] as any, "targetVersion": options?.["targetVersion"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Relation),
      orElse: unexpectedStatus
    }))
  ),
  "deleteRelationship": (relationName, sourceType, sourceKey, targetType, targetKey, options) => HttpClientRequest.del(`/wiki/rest/api/relation/${relationName}/from/${sourceType}/${sourceKey}/to/${targetType}/${targetKey}`).pipe(
    HttpClientRequest.setUrlParams({ "sourceStatus": options?.["sourceStatus"] as any, "targetStatus": options?.["targetStatus"] as any, "sourceVersion": options?.["sourceVersion"] as any, "targetVersion": options?.["targetVersion"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "findSourcesForTarget": (relationName, targetType, targetKey, sourceType, options) => HttpClientRequest.get(`/wiki/rest/api/relation/${relationName}/to/${targetType}/${targetKey}/from/${sourceType}`).pipe(
    HttpClientRequest.setUrlParams({ "sourceStatus": options?.["sourceStatus"] as any, "targetStatus": options?.["targetStatus"] as any, "sourceVersion": options?.["sourceVersion"] as any, "targetVersion": options?.["targetVersion"] as any, "expand": options?.["expand"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RelationArray),
      orElse: unexpectedStatus
    }))
  ),
  "searchByCQL": (options) => HttpClientRequest.get(`/wiki/rest/api/search`).pipe(
    HttpClientRequest.setUrlParams({ "cql": options?.["cql"] as any, "cqlcontext": options?.["cqlcontext"] as any, "cursor": options?.["cursor"] as any, "next": options?.["next"] as any, "prev": options?.["prev"] as any, "limit": options?.["limit"] as any, "start": options?.["start"] as any, "includeArchivedSpaces": options?.["includeArchivedSpaces"] as any, "excludeCurrentSpaces": options?.["excludeCurrentSpaces"] as any, "excerpt": options?.["excerpt"] as any, "sitePermissionTypeFilter": options?.["sitePermissionTypeFilter"] as any, "_": options?.["_"] as any, "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SearchPageResponseSearchResult),
      orElse: unexpectedStatus
    }))
  ),
  "searchUser": (options) => HttpClientRequest.get(`/wiki/rest/api/search/user`).pipe(
    HttpClientRequest.setUrlParams({ "cql": options?.["cql"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any, "expand": options?.["expand"] as any, "sitePermissionTypeFilter": options?.["sitePermissionTypeFilter"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SearchPageResponseSearchResult),
      orElse: unexpectedStatus
    }))
  ),
  "getLookAndFeelSettings": (options) => HttpClientRequest.get(`/wiki/rest/api/settings/lookandfeel`).pipe(
    HttpClientRequest.setUrlParams({ "spaceKey": options?.["spaceKey"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LookAndFeelSettings),
      orElse: unexpectedStatus
    }))
  ),
  "updateLookAndFeel": (options) => HttpClientRequest.put(`/wiki/rest/api/settings/lookandfeel`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LookAndFeelSelection),
      orElse: unexpectedStatus
    }))
  ),
  "updateLookAndFeelSettings": (options) => HttpClientRequest.post(`/wiki/rest/api/settings/lookandfeel/custom`).pipe(
    HttpClientRequest.setUrlParams({ "spaceKey": options.params?.["spaceKey"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LookAndFeelWithLinks),
      orElse: unexpectedStatus
    }))
  ),
  "resetLookAndFeelSettings": (options) => HttpClientRequest.del(`/wiki/rest/api/settings/lookandfeel/custom`).pipe(
    HttpClientRequest.setUrlParams({ "spaceKey": options?.["spaceKey"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getSystemInfo": () => HttpClientRequest.get(`/wiki/rest/api/settings/systemInfo`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SystemInfoEntity),
      orElse: unexpectedStatus
    }))
  ),
  "getThemes": (options) => HttpClientRequest.get(`/wiki/rest/api/settings/theme`).pipe(
    HttpClientRequest.setUrlParams({ "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ThemeArray),
      orElse: unexpectedStatus
    }))
  ),
  "getGlobalTheme": () => HttpClientRequest.get(`/wiki/rest/api/settings/theme/selected`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Theme),
      orElse: unexpectedStatus
    }))
  ),
  "getTheme": (themeKey) => HttpClientRequest.get(`/wiki/rest/api/settings/theme/${themeKey}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Theme),
      orElse: unexpectedStatus
    }))
  ),
  "createSpace": (options) => HttpClientRequest.post(`/wiki/rest/api/space`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Space),
      orElse: unexpectedStatus
    }))
  ),
  "createPrivateSpace": (options) => HttpClientRequest.post(`/wiki/rest/api/space/_private`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Space),
      orElse: unexpectedStatus
    }))
  ),
  "updateSpace": (spaceKey, options) => HttpClientRequest.put(`/wiki/rest/api/space/${spaceKey}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Space),
      orElse: unexpectedStatus
    }))
  ),
  "deleteSpace": (spaceKey) => HttpClientRequest.del(`/wiki/rest/api/space/${spaceKey}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LongTask),
      orElse: unexpectedStatus
    }))
  ),
  "addPermissionToSpace": (spaceKey, options) => HttpClientRequest.post(`/wiki/rest/api/space/${spaceKey}/permission`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpacePermissionV2),
      orElse: unexpectedStatus
    }))
  ),
  "addCustomContentPermissions": (spaceKey, options) => HttpClientRequest.post(`/wiki/rest/api/space/${spaceKey}/permission/custom-content`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removePermission": (spaceKey, id) => HttpClientRequest.del(`/wiki/rest/api/space/${spaceKey}/permission/${id}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceSettings": (spaceKey) => HttpClientRequest.get(`/wiki/rest/api/space/${spaceKey}/settings`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpaceSettings),
      orElse: unexpectedStatus
    }))
  ),
  "updateSpaceSettings": (spaceKey, options) => HttpClientRequest.put(`/wiki/rest/api/space/${spaceKey}/settings`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpaceSettings),
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceContentStates": (spaceKey) => HttpClientRequest.get(`/wiki/rest/api/space/${spaceKey}/state`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetSpaceContentStates200),
      "401": () => Effect.void,
      "403": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getContentStateSettings": (spaceKey) => HttpClientRequest.get(`/wiki/rest/api/space/${spaceKey}/state/settings`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentStateSettings),
      "401": () => Effect.void,
      "403": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getContentsWithState": (spaceKey, options) => HttpClientRequest.get(`/wiki/rest/api/space/${spaceKey}/state/content`).pipe(
    HttpClientRequest.setUrlParams({ "state-id": options?.["state-id"] as any, "expand": options?.["expand"] as any, "limit": options?.["limit"] as any, "start": options?.["start"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentArray),
      "400": () => Effect.void,
      "401": () => Effect.void,
      "403": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getSpaceTheme": (spaceKey) => HttpClientRequest.get(`/wiki/rest/api/space/${spaceKey}/theme`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Theme),
      orElse: unexpectedStatus
    }))
  ),
  "setSpaceTheme": (spaceKey, options) => HttpClientRequest.put(`/wiki/rest/api/space/${spaceKey}/theme`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(Theme),
      orElse: unexpectedStatus
    }))
  ),
  "resetSpaceTheme": (spaceKey) => HttpClientRequest.del(`/wiki/rest/api/space/${spaceKey}/theme`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getWatchersForSpace": (spaceKey, options) => HttpClientRequest.get(`/wiki/rest/api/space/${spaceKey}/watch`).pipe(
    HttpClientRequest.setUrlParams({ "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(SpaceWatchArray),
      orElse: unexpectedStatus
    }))
  ),
  "getLabelsForSpace": (spaceKey, options) => HttpClientRequest.get(`/wiki/rest/api/space/${spaceKey}/label`).pipe(
    HttpClientRequest.setUrlParams({ "prefix": options?.["prefix"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LabelArray),
      orElse: unexpectedStatus
    }))
  ),
  "addLabelsToSpace": (spaceKey, options) => HttpClientRequest.post(`/wiki/rest/api/space/${spaceKey}/label`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LabelArray),
      orElse: unexpectedStatus
    }))
  ),
  "deleteLabelFromSpace": (spaceKey, options) => HttpClientRequest.del(`/wiki/rest/api/space/${spaceKey}/label`).pipe(
    HttpClientRequest.setUrlParams({ "name": options?.["name"] as any, "prefix": options?.["prefix"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "updateContentTemplate": (options) => HttpClientRequest.put(`/wiki/rest/api/template`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentTemplate),
      orElse: unexpectedStatus
    }))
  ),
  "createContentTemplate": (options) => HttpClientRequest.post(`/wiki/rest/api/template`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentTemplate),
      orElse: unexpectedStatus
    }))
  ),
  "getBlueprintTemplates": (options) => HttpClientRequest.get(`/wiki/rest/api/template/blueprint`).pipe(
    HttpClientRequest.setUrlParams({ "spaceKey": options?.["spaceKey"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any, "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(BlueprintTemplateArray),
      orElse: unexpectedStatus
    }))
  ),
  "getContentTemplates": (options) => HttpClientRequest.get(`/wiki/rest/api/template/page`).pipe(
    HttpClientRequest.setUrlParams({ "spaceKey": options?.["spaceKey"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any, "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentTemplateArray),
      orElse: unexpectedStatus
    }))
  ),
  "getContentTemplate": (contentTemplateId, options) => HttpClientRequest.get(`/wiki/rest/api/template/${contentTemplateId}`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ContentTemplate),
      orElse: unexpectedStatus
    }))
  ),
  "removeTemplate": (contentTemplateId) => HttpClientRequest.del(`/wiki/rest/api/template/${contentTemplateId}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "403": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getUser": (options) => HttpClientRequest.get(`/wiki/rest/api/user`).pipe(
    HttpClientRequest.setUrlParams({ "accountId": options?.["accountId"] as any, "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(User),
      orElse: unexpectedStatus
    }))
  ),
  "getAnonymousUser": (options) => HttpClientRequest.get(`/wiki/rest/api/user/anonymous`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UserAnonymous),
      orElse: unexpectedStatus
    }))
  ),
  "getCurrentUser": (options) => HttpClientRequest.get(`/wiki/rest/api/user/current`).pipe(
    HttpClientRequest.setUrlParams({ "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(User),
      orElse: unexpectedStatus
    }))
  ),
  "getGroupMembershipsForUser": (options) => HttpClientRequest.get(`/wiki/rest/api/user/memberof`).pipe(
    HttpClientRequest.setUrlParams({ "accountId": options?.["accountId"] as any, "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GroupArrayWithLinks),
      orElse: unexpectedStatus
    }))
  ),
  "getBulkUserLookup": (options) => HttpClientRequest.get(`/wiki/rest/api/user/bulk`).pipe(
    HttpClientRequest.setUrlParams({ "accountId": options?.["accountId"] as any, "expand": options?.["expand"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(BulkUserLookupArray),
      orElse: unexpectedStatus
    }))
  ),
  "getContentWatchStatus": (contentId, options) => HttpClientRequest.get(`/wiki/rest/api/user/watch/content/${contentId}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UserWatch),
      orElse: unexpectedStatus
    }))
  ),
  "addContentWatcher": (contentId, options) => HttpClientRequest.post(`/wiki/rest/api/user/watch/content/${contentId}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removeContentWatcher": (contentId, options) => HttpClientRequest.del(`/wiki/rest/api/user/watch/content/${contentId}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    HttpClientRequest.setHeaders({ "X-Atlassian-Token": options?.["X-Atlassian-Token"] ?? undefined }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "isWatchingLabel": (labelName, options) => HttpClientRequest.get(`/wiki/rest/api/user/watch/label/${labelName}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UserWatch),
      orElse: unexpectedStatus
    }))
  ),
  "addLabelWatcher": (labelName, options) => HttpClientRequest.post(`/wiki/rest/api/user/watch/label/${labelName}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    HttpClientRequest.setHeaders({ "X-Atlassian-Token": options?.["X-Atlassian-Token"] ?? undefined }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removeLabelWatcher": (labelName, options) => HttpClientRequest.del(`/wiki/rest/api/user/watch/label/${labelName}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "isWatchingSpace": (spaceKey, options) => HttpClientRequest.get(`/wiki/rest/api/user/watch/space/${spaceKey}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UserWatch),
      orElse: unexpectedStatus
    }))
  ),
  "addSpaceWatcher": (spaceKey, options) => HttpClientRequest.post(`/wiki/rest/api/user/watch/space/${spaceKey}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    HttpClientRequest.setHeaders({ "X-Atlassian-Token": options?.["X-Atlassian-Token"] ?? undefined }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removeSpaceWatch": (spaceKey, options) => HttpClientRequest.del(`/wiki/rest/api/user/watch/space/${spaceKey}`).pipe(
    HttpClientRequest.setUrlParams({ "key": options?.["key"] as any, "username": options?.["username"] as any, "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getPrivacyUnsafeUserEmail": (options) => HttpClientRequest.get(`/wiki/rest/api/user/email`).pipe(
    HttpClientRequest.setUrlParams({ "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AccountIdEmailRecord),
      orElse: unexpectedStatus
    }))
  ),
  "getPrivacyUnsafeUserEmailBulk": (options) => HttpClientRequest.get(`/wiki/rest/api/user/email/bulk`).pipe(
    HttpClientRequest.setUrlParams({ "accountId": options?.["accountId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AccountIdEmailRecordArray),
      orElse: unexpectedStatus
    }))
  ),
  "getModules": () => HttpClientRequest.get(`/atlassian-connect/1/app/module/dynamic`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "registerModules": () => HttpClientRequest.post(`/atlassian-connect/1/app/module/dynamic`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "removeModules": (options) => HttpClientRequest.del(`/atlassian-connect/1/app/module/dynamic`).pipe(
    HttpClientRequest.setUrlParams({ "moduleKey": options?.["moduleKey"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      orElse: unexpectedStatus
    }))
  ),
  "getViews": (contentId, options) => HttpClientRequest.get(`/wiki/rest/api/analytics/content/${contentId}/views`).pipe(
    HttpClientRequest.setUrlParams({ "fromDate": options?.["fromDate"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetViews200),
      "400": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getViewers": (contentId, options) => HttpClientRequest.get(`/wiki/rest/api/analytics/content/${contentId}/viewers`).pipe(
    HttpClientRequest.setUrlParams({ "fromDate": options?.["fromDate"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetViewers200),
      "400": () => Effect.void,
      "404": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "getUserProperties": (userId, options) => HttpClientRequest.get(`/wiki/rest/api/user/${userId}/property`).pipe(
    HttpClientRequest.setUrlParams({ "start": options?.["start"] as any, "limit": options?.["limit"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UserPropertyKeyArray),
      orElse: unexpectedStatus
    }))
  ),
  "getUserProperty": (userId, key) => HttpClientRequest.get(`/wiki/rest/api/user/${userId}/property/${key}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UserProperty),
      orElse: unexpectedStatus
    }))
  ),
  "updateUserProperty": (userId, key, options) => HttpClientRequest.put(`/wiki/rest/api/user/${userId}/property/${key}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "createUserProperty": (userId, key, options) => HttpClientRequest.post(`/wiki/rest/api/user/${userId}/property/${key}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "201": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "deleteUserProperty": (userId, key) => HttpClientRequest.del(`/wiki/rest/api/user/${userId}/property/${key}`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface ConfluenceV1Client {
  readonly httpClient: HttpClient.HttpClient
  /**
* Returns all records in the audit log, optionally for a certain date range.
* This contains information about events like space exports, group membership
* changes, app installations, etc. For more information, see
* [Audit log](https://confluence.atlassian.com/confcloud/audit-log-802164269.html)
* in the Confluence administrator's guide.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission.
*/
readonly "getAuditRecords": (options?: typeof GetAuditRecordsParams.Encoded | undefined) => Effect.Effect<typeof AuditRecordArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a record in the audit log.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission.
*/
readonly "createAuditRecord": (options: typeof AuditRecordCreate.Encoded) => Effect.Effect<typeof AuditRecord.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Exports audit records as a CSV file or ZIP file.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission.
*/
readonly "exportAuditRecords": (options?: typeof ExportAuditRecordsParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the retention period for records in the audit log. The retention
* period is how long an audit record is kept for, from creation date until
* it is deleted.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission.
*/
readonly "getRetentionPeriod": () => Effect.Effect<typeof RetentionPeriod.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Sets the retention period for records in the audit log. The retention period
* can be set to a maximum of 1 year.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission.
*/
readonly "setRetentionPeriod": (options: typeof RetentionPeriod.Encoded) => Effect.Effect<typeof RetentionPeriod.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns records from the audit log, for a time period back from the current
* date. For example, you can use this method to get the last 3 months of records.
* 
* This contains information about events like space exports, group membership
* changes, app installations, etc. For more information, see
* [Audit log](https://confluence.atlassian.com/confcloud/audit-log-802164269.html)
* in the Confluence administrator's guide.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission.
*/
readonly "getAuditRecordsForTimePeriod": (options?: typeof GetAuditRecordsForTimePeriodParams.Encoded | undefined) => Effect.Effect<typeof AuditRecordArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Archives a list of pages. The pages to be archived are specified as a list of content IDs.
* This API accepts the archival request and returns a task ID.
* The archival process happens asynchronously.
* Use the /longtask/<taskId> REST API to get the copy task status.
* 
* Each content ID needs to resolve to page objects that are not already in an archived state.
* The content IDs need not belong to the same space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Archive' permission for each of the pages in the corresponding space it belongs to.
*/
readonly "archivePages": (options: typeof ArchivePagesRequest.Encoded) => Effect.Effect<typeof LongTask.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Publishes a shared draft of a page created from a blueprint.
* 
* By default, the following objects are expanded: `body.storage`, `history`, `space`, `version`, `ancestors`.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the draft and 'Add' permission for the space that
* the content will be created in.
*/
readonly "publishSharedDraft": (draftId: string, options: { readonly params?: typeof PublishSharedDraftParams.Encoded | undefined; readonly payload: typeof ContentBlueprintDraft.Encoded }) => Effect.Effect<typeof Content.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Publishes a legacy draft of a page created from a blueprint. Legacy drafts
* will eventually be removed in favor of shared drafts. For now, this method
* works the same as [Publish shared draft](#api-content-blueprint-instance-draftId-put).
* 
* By default, the following objects are expanded: `body.storage`, `history`, `space`, `version`, `ancestors`.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the draft and 'Add' permission for the space that
* the content will be created in.
*/
readonly "publishLegacyDraft": (draftId: string, options: { readonly params?: typeof PublishLegacyDraftParams.Encoded | undefined; readonly payload: typeof ContentBlueprintDraft.Encoded }) => Effect.Effect<typeof Content.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the list of content that matches a Confluence Query Language
* (CQL) query. For information on CQL, see:
* [Advanced searching using CQL](https://developer.atlassian.com/cloud/confluence/advanced-searching-using-cql/).
* 
* Example initial call:
* ```
* /wiki/rest/api/content/search?cql=type=page&limit=25
* ```
* 
* Example response:
* ```
* {
*   "results": [
*     { ... },
*     { ... },
*     ...
*     { ... }
*   ],
*   "limit": 25,
*   "size": 25,
*   ...
*   "_links": {
*     "base": "<url>",
*     "context": "<url>",
*     "next": "/rest/api/content/search?cql=type=page&limit=25&cursor=raNDoMsTRiNg",
*     "self": "<url>"
*   }
* }
* ```
* 
* When additional results are available, returns `next` and `prev` URLs to retrieve them in subsequent calls. The URLs each contain a cursor that points to the appropriate set of results. Use `limit` to specify the number of results returned in each call.
* Example subsequent call (taken from example response):
* ```
* /wiki/rest/api/content/search?cql=type=page&limit=25&cursor=raNDoMsTRiNg
* ```
* The response to this will have a `prev` URL similar to the `next` in the example response.
* 
* If the expand query parameter is used with the `body.export_view` and/or `body.styled_view` properties, then the query limit parameter will be restricted to a maximum value of 25.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* Only content that the user has permission to view will be returned.
*/
readonly "searchContentByCQL": (options: typeof SearchContentByCQLParams.Encoded) => Effect.Effect<typeof ContentArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Moves a pagetree rooted at a page to the space's trash:
* 
* - If the content's type is `page` and its status is `current`, it will be trashed including
* all its descendants.
* - For every other combination of content type and status, this API is not supported.
* 
* This API accepts the pageTree delete request and returns a task ID.
* The delete process happens asynchronously.
* 
*  Response example:
*  <pre><code>
*  {
*       "id" : "1180606",
*       "links" : {
*            "status" : "/rest/api/longtask/1180606"
*       }
*  }
*  </code></pre>
*  Use the `/longtask/<taskId>` REST API to get the copy task status.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Delete' permission for the space that the content is in.
*/
readonly "deletePageTree": (id: string) => Effect.Effect<typeof LongTask.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Move a page to a new location relative to a target page:
* 
* * `before` - move the page under the same parent as the target, before the target in the list of children
* * `after` - move the page under the same parent as the target, after the target in the list of children
* * `append` - move the page to be a child of the target
* 
* Caution: This API can move pages to the top level of a space. Top-level pages are difficult to find in the UI
* because they do not show up in the page tree display. To avoid this, never use `before` or `after` positions
* when the `targetId` is a top-level page.
*/
readonly "movePage": (pageId: string, position: string, targetId: string) => Effect.Effect<typeof MovePage200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds an attachment to a piece of content. If the attachment already exists
* for the content, then the attachment is updated (i.e. a new version of the
* attachment is created).
* 
* Note, you must set a `X-Atlassian-Token: nocheck` header on the request
* for this method, otherwise it will be blocked. This protects against XSRF
* attacks, which is necessary as this method accepts multipart/form-data.
* 
* The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt).
* Most client libraries have classes that make it easier to implement
* multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/)
* Java class provided by Apache HTTP Components.
* 
* Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5),
* in the case where the form data is text,
* the charset parameter for the "text/plain" Content-Type may be used to
* indicate the character encoding used in that part. In the case of this
* API endpoint, the `comment` body parameter should be sent with `type=text/plain`
* and `charset=utf-8` values. This will force the charset to be UTF-8.
* 
* Example: This curl command attaches a file ('example.txt') to a piece of
* content (id='123') with a comment and `minorEdits`=true. If the 'example.txt'
* file already exists, it will update it with a new version of the attachment.
* 
* ``` bash
* curl -D- \
*   -u admin:admin \
*   -X PUT \
*   -H 'X-Atlassian-Token: nocheck' \
*   -F 'file=@"example.txt"' \
*   -F 'minorEdit="true"' \
*   -F 'comment="Example attachment comment"; type=text/plain; charset=utf-8' \
*   http://myhost/rest/api/content/123/child/attachment
* ```
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "createOrUpdateAttachments": (id: string, options: { readonly params?: typeof CreateOrUpdateAttachmentsParams.Encoded | undefined; readonly payload: typeof CreateOrUpdateAttachmentsRequest.Encoded }) => Effect.Effect<typeof ContentArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds an attachment to a piece of content. This method only adds a new
* attachment. If you want to update an existing attachment, use
* [Create or update attachments](#api-content-id-child-attachment-put).
* 
* Note, you must set a `X-Atlassian-Token: nocheck` header on the request
* for this method, otherwise it will be blocked. This protects against XSRF
* attacks, which is necessary as this method accepts multipart/form-data.
* 
* The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt).
* Most client libraries have classes that make it easier to implement
* multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/)
* Java class provided by Apache HTTP Components.
* 
* Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5),
* in the case where the form data is text,
* the charset parameter for the "text/plain" Content-Type may be used to
* indicate the character encoding used in that part. In the case of this
* API endpoint, the `comment` body parameter should be sent with `type=text/plain`
* and `charset=utf-8` values. This will force the charset to be UTF-8.
* 
* Example: This curl command attaches a file ('example.txt') to a container
* (id='123') with a comment and `minorEdits`=true.
* 
* ``` bash
* curl -D- \
*   -u admin:admin \
*   -X POST \
*   -H 'X-Atlassian-Token: nocheck' \
*   -F 'file=@"example.txt"' \
*   -F 'minorEdit="true"' \
*   -F 'comment="Example attachment comment"; type=text/plain; charset=utf-8' \
*   https://myhost/wiki/rest/api/content/123/child/attachment
* ```
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "createAttachment": (id: string, options: { readonly params?: typeof CreateAttachmentParams.Encoded | undefined; readonly payload: typeof CreateAttachmentRequest.Encoded }) => Effect.Effect<typeof ContentArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the attachment properties, i.e. the non-binary data of an attachment
* like the filename, media-type, comment, and parent container.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "updateAttachmentProperties": (id: string, attachmentId: string, options: typeof AttachmentPropertiesUpdateBody.Encoded) => Effect.Effect<typeof Content.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the binary data of an attachment, given the attachment ID, and
* optionally the comment and the minor edit field.
* 
* This method is essentially the same as [Create or update attachments](#api-content-id-child-attachment-put),
* except that it matches the attachment ID rather than the name.
* 
* Note, you must set a `X-Atlassian-Token: nocheck` header on the request
* for this method, otherwise it will be blocked. This protects against XSRF
* attacks, which is necessary as this method accepts multipart/form-data.
* 
* The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt).
* Most client libraries have classes that make it easier to implement
* multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/)
* Java class provided by Apache HTTP Components.
* 
* Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5),
* in the case where the form data is text,
* the charset parameter for the "text/plain" Content-Type may be used to
* indicate the character encoding used in that part. In the case of this
* API endpoint, the `comment` body parameter should be sent with `type=text/plain`
* and `charset=utf-8` values. This will force the charset to be UTF-8.
* 
* Example: This curl command updates an attachment (id='att456') that is attached
* to a piece of content (id='123') with a comment and `minorEdits`=true.
* 
* ``` bash
* curl -D- \
*   -u admin:admin \
*   -X POST \
*   -H 'X-Atlassian-Token: nocheck' \
*   -F 'file=@"example.txt"' \
*   -F 'minorEdit="true"' \
*   -F 'comment="Example attachment comment"; type=text/plain; charset=utf-8' \
*   http://myhost/rest/api/content/123/child/attachment/att456/data
* ```
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "updateAttachmentData": (id: string, attachmentId: string, options: typeof UpdateAttachmentDataRequest.Encoded) => Effect.Effect<typeof Content.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Redirects the client to a URL that serves an attachment's binary data.
*/
readonly "downloadAttatchment": (id: string, attachmentId: string, options?: typeof DownloadAttatchmentParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a map of the descendants of a piece of content. This is similar
* to [Get content children](#api-content-id-child-get), except that this
* method returns child pages at all levels, rather than just the direct
* child pages.
* 
* A piece of content has different types of descendants, depending on its type:
* 
* - `page`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `whiteboard`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `database`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `embed`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `folder`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `blogpost`: descendant is `comment`, `attachment`
* - `attachment`: descendant is `comment`
* - `comment`: descendant is `attachment`
* 
* The map will always include all descendant types that are valid for the content.
* However, if the content has no instances of a descendant type, the map will
* contain an empty array for that descendant type.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space, and permission to view the content if it
* is a page.
*/
readonly "getContentDescendants": (id: string, options?: typeof GetContentDescendantsParams.Encoded | undefined) => Effect.Effect<typeof ContentChildren.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all descendants of a given type, for a piece of content. This is
* similar to [Get content children by type](#api-content-id-child-type-get),
* except that this method returns child pages at all levels, rather than just
* the direct child pages.
* 
* A piece of content has different types of descendants, depending on its type:
* 
* - `page`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `whiteboard`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `database`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `embed`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `folder`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment`
* - `blogpost`: descendant is `comment`, `attachment`
* - `attachment`: descendant is `comment`
* - `comment`: descendant is `attachment`
* 
* Custom content types that are provided by apps can also be returned.
* 
* If the expand query parameter is used with the `body.export_view` and/or `body.styled_view` properties, then the query limit parameter will be restricted to a maximum value of 25.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space, and permission to view the content if it
* is a page.
*/
readonly "getDescendantsOfType": (id: string, type: string, options?: typeof GetDescendantsOfTypeParams.Encoded | undefined) => Effect.Effect<typeof ContentArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the body of a macro in storage format, for the given macro ID.
* This includes information like the name of the macro, the body of the macro,
* and any macro parameters. This method is mainly used by Cloud apps.
* 
* About the macro ID: When a macro is created in a new version of content,
* Confluence will generate a random ID for it, unless an ID is specified
* (by an app). The macro ID will look similar to this: '50884bd9-0cb8-41d5-98be-f80943c14f96'.
* The ID is then persisted as new versions of content are created, and is
* only modified by Confluence if there are conflicting IDs.
* 
* For Forge macros, the value for macro ID is the "local ID" of that particular ADF node.
* This value can be retrieved either client-side by calling view.getContext() and accessing "localId"
* on the resulting object, or server-side by examining the "local-id" parameter node inside the "parameters" node.
* 
* Note that there are other attributes named "local-id", but only this particular one is used to store the macro ID.
* 
* Example:
* <ac:adf-node type="extension">
*   <ac:adf-attribute key="extension-type">com.atlassian.ecosystem</ac:adf-attribute>
*   <ac:adf-attribute key="parameters">
*       <ac:adf-parameter key="local-id">e9c4aa10-73fa-417c-888d-48c719ae4165</ac:adf-parameter>
*   </ac:adf-parameter>
* </ac:adf-node>
* 
* Note, to preserve backwards compatibility this resource will also match on
* the hash of the macro body, even if a macro ID is found. This check will
* eventually become redundant, as macro IDs are generated for pages and
* transparently propagate out to all instances.
* 
* This backwards compatibility logic does not apply to Forge macros; those
* can only be retrieved by their ID.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content that the macro is in.
*/
readonly "getMacroBodyByMacroId": (id: string, version: string, macroId: string) => Effect.Effect<typeof MacroInstance.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the body of a macro in format specified in path, for the given macro ID.
* This includes information like the name of the macro, the body of the macro,
* and any macro parameters.
* 
* About the macro ID: When a macro is created in a new version of content,
* Confluence will generate a random ID for it, unless an ID is specified
* (by an app). The macro ID will look similar to this: '50884bd9-0cb8-41d5-98be-f80943c14f96'.
* The ID is then persisted as new versions of content are created, and is
* only modified by Confluence if there are conflicting IDs.
* 
* For Forge macros, the value for macro ID is the "local ID" of that particular ADF node.
* This value can be retrieved either client-side by calling view.getContext() and accessing "localId"
* on the resulting object, or server-side by examining the "local-id" parameter node inside the "parameters" node.
* 
* Note that there are other attributes named "local-id", but only this particular one is used to store the macro ID.
* 
* Example:
* <ac:adf-node type="extension">
*   <ac:adf-attribute key="extension-type">com.atlassian.ecosystem</ac:adf-attribute>
*   <ac:adf-attribute key="parameters">
*       <ac:adf-parameter key="local-id">e9c4aa10-73fa-417c-888d-48c719ae4165</ac:adf-parameter>
*   </ac:adf-parameter>
* </ac:adf-node>
* 
* Note, to preserve backwards compatibility this resource will also match on
* the hash of the macro body, even if a macro ID is found. This check will
* eventually become redundant, as macro IDs are generated for pages and
* transparently propagate out to all instances.
* 
* This backwards compatibility logic does not apply to Forge macros; those
* can only be retrieved by their ID.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content that the macro is in.
*/
readonly "getAndConvertMacroBodyByMacroId": (id: string, version: string, macroId: string, to: string, options?: typeof GetAndConvertMacroBodyByMacroIdParams.Encoded | undefined) => Effect.Effect<typeof ContentBody.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns Async Id of the conversion task which will convert the macro into a content body of the desired format.
* The result will be available for 5 minutes after completion of the conversion.
* 
* About the macro ID: When a macro is created in a new version of content,
* Confluence will generate a random ID for it, unless an ID is specified
* (by an app). The macro ID will look similar to this: '884bd9-0cb8-41d5-98be-f80943c14f96'.
* The ID is then persisted as new versions of content are created, and is
* only modified by Confluence if there are conflicting IDs.
* 
* For Forge macros, the value for macro ID is the "local ID" of that particular ADF node.
* This value can be retrieved either client-side by calling view.getContext() and accessing "localId"
* on the resulting object, or server-side by examining the "local-id" parameter node inside the "parameters" node.
* 
* Note that there are other attributes named "local-id", but only this particular one is used to store the macro ID.
* 
* Example:
* <ac:adf-node type="extension">
*   <ac:adf-attribute key="extension-type">com.atlassian.ecosystem</ac:adf-attribute>
*   <ac:adf-attribute key="parameters">
*       <ac:adf-parameter key="local-id">e9c4aa10-73fa-417c-888d-48c719ae4165</ac:adf-parameter>
*   </ac:adf-parameter>
* </ac:adf-node>
* 
* Note, to preserve backwards compatibility this resource will also match on
* the hash of the macro body, even if a macro ID is found. This check will
* eventually become redundant, as macro IDs are generated for pages and
* transparently propagate out to all instances.
* 
* This backwards compatibility logic does not apply to Forge macros; those
* can only be retrieved by their ID.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content that the macro is in.
*/
readonly "getAndAsyncConvertMacroBodyByMacroId": (id: string, version: string, macroId: string, to: string, options?: typeof GetAndAsyncConvertMacroBodyByMacroIdParams.Encoded | undefined) => Effect.Effect<typeof AsyncId.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds labels to a piece of content. Does not modify the existing labels.
* 
* Notes:
* 
* - Labels can also be added when creating content ([Create content](#api-content-post)).
* - Labels can be updated when updating content ([Update content](#api-content-id-put)).
* This will delete the existing labels and replace them with the labels in
* the request.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "addLabelsToContent": (id: string, options: typeof AddLabelsToContentRequest.Encoded) => Effect.Effect<typeof LabelArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Removes a label from a piece of content. Labels can't be deleted from archived content.
* This is similar to [Remove label from content](#api-content-id-label-label-delete)
* except that the label name is specified via a query parameter.
* 
* Use this method if the label name has "/" characters, as
* [Remove label from content using query parameter](#api-content-id-label-delete)
* does not accept "/" characters for the label name.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "removeLabelFromContentUsingQueryParameter": (id: string, options: typeof RemoveLabelFromContentUsingQueryParameterParams.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Removes a label from a piece of content. Labels can't be deleted from archived content.
* This is similar to [Remove label from content using query parameter](#api-content-id-label-delete)
* except that the label name is specified via a path parameter.
* 
* Use this method if the label name does not have "/" characters, as the path
* parameter does not accept "/" characters for security reasons. Otherwise,
* use [Remove label from content using query parameter](#api-content-id-label-delete).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "removeLabelFromContent": (id: string, label: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the watches for a page. A user that watches a page will receive
* receive notifications when the page is updated.
* 
* If you want to manage watches for a page, use the following `user` methods:
* 
* - [Get content watch status for user](#api-user-watch-content-contentId-get)
* - [Add content watch](#api-user-watch-content-contentId-post)
* - [Remove content watch](#api-user-watch-content-contentId-delete)
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getWatchesForPage": (id: string, options?: typeof GetWatchesForPageParams.Encoded | undefined) => Effect.Effect<typeof WatchArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all space watches for the space that the content is in. A user that
* watches a space will receive receive notifications when any content in the
* space is updated.
* 
* If you want to manage watches for a space, use the following `user` methods:
* 
* - [Get space watch status for user](#api-user-watch-space-spaceKey-get)
* - [Add space watch](#api-user-watch-space-spaceKey-post)
* - [Remove space watch](#api-user-watch-space-spaceKey-delete)
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getWatchesForSpace": (id: string, options?: typeof GetWatchesForSpaceParams.Encoded | undefined) => Effect.Effect<typeof SpaceWatchArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Copy page hierarchy allows the copying of an entire hierarchy of pages and their associated properties, permissions and attachments.
*  The id path parameter refers to the content id of the page to copy, and the new parent of this copied page is defined using the destinationPageId in the request body.
*  The titleOptions object defines the rules of renaming page titles during the copy;
*  for example, search and replace can be used in conjunction to rewrite the copied page titles.
* 
*  Response example:
*  <pre><code>
*  {
*       "id" : "1180606",
*       "links" : {
*            "status" : "/rest/api/longtask/1180606"
*       }
*  }
*  </code></pre>
*  Use the /longtask/<taskId> REST API to get the copy task status.
*/
readonly "copyPageHierarchy": (id: string, options: typeof CopyPageHierarchyRequest.Encoded) => Effect.Effect<typeof LongTask.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Copies a single page and its associated properties, permissions, attachments, and custom contents.
*  The `id` path parameter refers to the content ID of the page to copy. The target of the page to be copied
*  is defined using the `destination` in the request body and can be one of the following types.
* 
*   - `space`: page will be copied to the specified space as a root page on the space
*   - `parent_page`: page will be copied as a child of the specified parent page
*   - `parent_content`: page will be copied as a child of the specified parent content
*   - `existing_page`: page will be copied and replace the specified page
* 
* By default, the following objects are expanded: `space`, `history`, `version`.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: 'Add' permission for the space that the content will be copied in and permission to update the content if copying to an `existing_page`.
*/
readonly "copyPage": (id: string, options: { readonly params?: typeof CopyPageParams.Encoded | undefined; readonly payload: typeof CopyPageRequest.Encoded }) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Check if a user or a group can perform an operation to the specified content. The `operation` to check
* must be provided. The users account ID or the ID of the group can be provided in the `subject` to check
* permissions against a specified user or group. The following permission checks are done to make sure that the
* user or group has the proper access:
* 
* - site permissions
* - space permissions
* - content restrictions
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission) if checking permission for self,
* otherwise 'Confluence Administrator' global permission is required.
*/
readonly "checkContentPermission": (id: string, options: typeof ContentPermissionRequest.Encoded) => Effect.Effect<typeof PermissionCheckResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the restrictions on a piece of content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content.
*/
readonly "getRestrictions": (id: string, options?: typeof GetRestrictionsParams.Encoded | undefined) => Effect.Effect<typeof ContentRestrictionArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates restrictions for a piece of content. This removes the existing
* restrictions and replaces them with the restrictions in the request.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "updateRestrictions": (id: string, options: { readonly params?: typeof UpdateRestrictionsParams.Encoded | undefined; readonly payload: typeof ContentRestrictionAddOrUpdateArray.Encoded }) => Effect.Effect<typeof ContentRestrictionArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds restrictions to a piece of content. Note, this does not change any
* existing restrictions on the content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "addRestrictions": (id: string, options: { readonly params?: typeof AddRestrictionsParams.Encoded | undefined; readonly payload: typeof ContentRestrictionAddOrUpdateArray.Encoded }) => Effect.Effect<typeof ContentRestrictionArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Removes all restrictions (read and update) on a piece of content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "deleteRestrictions": (id: string, options?: typeof DeleteRestrictionsParams.Encoded | undefined) => Effect.Effect<typeof ContentRestrictionArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns restrictions on a piece of content by operation. This method is
* similar to [Get restrictions](#api-content-id-restriction-get) except that
* the operations are properties of the return object, rather than items in
* a results array.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content.
*/
readonly "getRestrictionsByOperation": (id: string, options?: typeof GetRestrictionsByOperationParams.Encoded | undefined) => Effect.Effect<typeof GetRestrictionsByOperation200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the restictions on a piece of content for a given operation (read
* or update).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content.
*/
readonly "getRestrictionsForOperation": (id: string, operationKey: string, options?: typeof GetRestrictionsForOperationParams.Encoded | undefined) => Effect.Effect<typeof ContentRestriction.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns whether the specified content restriction applies to a group.
* For example, if a page with `id=123` has a `read` restriction for the `123456` group id,
* the following request will return `true`:
* 
* `/wiki/rest/api/content/123/restriction/byOperation/read/byGroupId/123456`
* 
* Note that a response of `true` does not guarantee that the group can view the page, as it does not account for
* account-inherited restrictions, space permissions, or even product access. For more
* information, see [Confluence permissions](https://confluence.atlassian.com/x/_AozKw).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content.
*/
readonly "getIndividualGroupRestrictionStatusByGroupId": (id: string, operationKey: string, groupId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Adds a group to a content restriction by Group Id. That is, grant read or update
* permission to the group for a piece of content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "addGroupToContentRestrictionByGroupId": (id: string, operationKey: string, groupId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Removes a group from a content restriction. That is, remove read or update
* permission for the group for a piece of content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "removeGroupFromContentRestriction": (id: string, operationKey: string, groupId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns whether the specified content restriction applies to a user.
* For example, if a page with `id=123` has a `read` restriction for a user with an account ID of
* `384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192`, the following request will return `true`:
* 
* `/wiki/rest/api/content/123/restriction/byOperation/read/user?accountId=384093:32b4d9w0-f6a5-3535-11a3-9c8c88d10192`
* 
* Note that a response of `true` does not guarantee that the user can view the page, as it does not account for
* account-inherited restrictions, space permissions, or even product access. For more
* information, see [Confluence permissions](https://confluence.atlassian.com/x/_AozKw).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content.
*/
readonly "getContentRestrictionStatusForUser": (id: string, operationKey: string, options?: typeof GetContentRestrictionStatusForUserParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Adds a user to a content restriction. That is, grant read or update
* permission to the user for a piece of content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "addUserToContentRestriction": (id: string, operationKey: string, options?: typeof AddUserToContentRestrictionParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Removes a group from a content restriction. That is, remove read or update
* permission for the group for a piece of content.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "removeUserFromContentRestriction": (id: string, operationKey: string, options?: typeof RemoveUserFromContentRestrictionParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Gets the current content state of the draft or current version of content. To specify the draft version, set
* the parameter status to draft, otherwise archived or current will get the relevant published state.
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the content.
*/
readonly "getContentState": (id: string, options?: typeof GetContentStateParams.Encoded | undefined) => Effect.Effect<typeof ContentStateResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Sets the content state of the content specified and creates a new version
* (publishes the content without changing the body) of the content with the new state.
* 
* You may pass in either an id of a state, or the name and color of a desired new state.
* If all 3 are passed in, id will be used.
* If the name and color passed in already exist under the current user's existing custom states, the existing state will be reused.
* If custom states are disabled in the space of the content (which can be determined by getting the content state space settings of the content's space)
* then this set will fail.
* 
* You may not remove a content state via this PUT request. You must use the DELETE method. A specified state is required in the body of this request.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "setContentState": (id: string, options: { readonly params: typeof SetContentStateParams.Encoded; readonly payload: typeof ContentStateRestInput.Encoded }) => Effect.Effect<typeof ContentStateResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Removes the content state of the content specified and creates a new version
* (publishes the content without changing the body) of the content with the new status.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "removeContentState": (id: string, options?: typeof RemoveContentStateParams.Encoded | undefined) => Effect.Effect<typeof ContentStateResponse.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Gets content states that are available for the content to be set as.
* Will return all enabled Space Content States.
* Will only return most the 3 most recently published custom content states to match UI editor list.
* To get all custom content states, use the /content-states endpoint.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to edit the content.
*/
readonly "getAvailableContentStates": (id: string) => Effect.Effect<typeof AvailableContentStates.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Restores a historical version to be the latest version. That is, a new version
* is created with the content of the historical version.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "restoreContentVersion": (id: string, options: { readonly params?: typeof RestoreContentVersionParams.Encoded | undefined; readonly payload: typeof VersionRestore.Encoded }) => Effect.Effect<typeof Version.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete a historical version. This does not delete the changes made to the
* content in that version, rather the changes for the deleted version are
* rolled up into the next version. Note, you cannot delete the current version.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "deleteContentVersion": (id: string, versionNumber: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Get custom content states that authenticated user has created.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**
* Must have user authentication.
*/
readonly "getCustomContentStates": () => Effect.Effect<typeof GetCustomContentStates200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Converts a content body from one format to another format asynchronously.
* Returns the asyncId for the asynchronous task.
* 
* Supported conversions:
* 
* - atlas_doc_format: editor, export_view, storage, styled_view, view
* - storage: atlas_doc_format, editor, export_view, styled_view, view
* - editor: storage
* 
* No other conversions are supported at the moment.
* Once a conversion is completed, it will be available for 5 minutes at the result endpoint.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* If request specifies 'contentIdContext', 'View' permission for the space, and permission to view the content.
*/
readonly "asyncConvertContentBodyRequest": (to: string, options: { readonly params?: typeof AsyncConvertContentBodyRequestParams.Encoded | undefined; readonly payload: typeof ContentBodyCreate.Encoded }) => Effect.Effect<typeof AsyncId.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the asynchronous content body for the corresponding id if the task is complete 
* or returns the status of the task.
* 
* After the task is completed, the result can be obtained for 5 minutes, or until an identical conversion request is made again,
* with allowCache query param set to false.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* If request specifies 'contentIdContext', 'View' permission for the space, and permission to view the content.
*/
readonly "asyncConvertContentBodyResponse": (id: string) => Effect.Effect<typeof AsyncContentBody.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the content body for the corresponding `asyncId` of a completed conversion task. If
* the task is not completed, the task status is returned instead.
* 
* Once a conversion task is completed, the result can be obtained for up to 5 minutes, or
* until an identical conversion request is made again with the `allowCache` parameter set to
* false.
* 
* Note that there is a maximum limit of 50 task results per request to this endpoint.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "bulkAsyncConvertContentBodyResponse": (options: typeof BulkAsyncConvertContentBodyResponseParams.Encoded) => Effect.Effect<typeof AsyncContentBodyArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Asynchronously converts content bodies from one format to another format in bulk. Use the Content body
* REST API to get the status of conversion tasks. Note that there is a maximum limit of 10 conversions per
* request to this endpoint.
* 
* Supported conversions:
* 
* - storage: editor, export_view, styled_view, view
* - editor: storage
* 
* Once a conversion task is completed, it is available for polling for up to 5 minutes.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space, and permission to view the content if the `spaceKeyContext` or
* `contentIdContext` are present.
*/
readonly "bulkAsyncConvertContentBodyRequest": (options: typeof BulkContentBodyConversionInput.Encoded) => Effect.Effect<typeof AsyncIdArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns label information and a list of contents associated with the label.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission). Only contents
* that the user is permitted to view is returned.
*/
readonly "getAllLabelContent": (options: typeof GetAllLabelContentParams.Encoded) => Effect.Effect<typeof LabelDetails.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all user groups. The returned groups are ordered alphabetically in
* ascending order by group name.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getGroups": (options?: typeof GetGroupsParams.Encoded | undefined) => Effect.Effect<typeof GroupArrayWithLinks.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new user group.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* User must be a site admin.
*/
readonly "createGroup": (options: typeof GroupName.Encoded) => Effect.Effect<typeof Group.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a user group for a given group id.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getGroupByGroupId": (options: typeof GetGroupByGroupIdParams.Encoded) => Effect.Effect<typeof Group.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Delete user group.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* User must be a site admin.
*/
readonly "removeGroupById": (options: typeof RemoveGroupByIdParams.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Get search results of groups by partial query provided.
*/
readonly "searchGroups": (options: typeof SearchGroupsParams.Encoded) => Effect.Effect<typeof GroupArrayWithLinks.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the users that are members of a group.
* 
* Use updated Get group API
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getGroupMembersByGroupId": (groupId: string, options?: typeof GetGroupMembersByGroupIdParams.Encoded | undefined) => Effect.Effect<typeof UserArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds a user as a member in a group represented by its groupId
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* User must be a site admin.
*/
readonly "addUserToGroupByGroupId": (options: { readonly params: typeof AddUserToGroupByGroupIdParams.Encoded; readonly payload: typeof AccountId.Encoded }) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Remove user as a member from a group.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* User must be a site admin.
*/
readonly "removeMemberFromGroupByGroupId": (options: typeof RemoveMemberFromGroupByGroupIdParams.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns information about all active long-running tasks (e.g. space export),
* such as how long each task has been running and the percentage of each task
* that has completed.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getTasks": (options?: typeof GetTasksParams.Encoded | undefined) => Effect.Effect<typeof LongTaskStatusArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns information about an active long-running task (e.g. space export),
* such as how long it has been running and the percentage of the task that
* has completed.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getTask": (id: string) => Effect.Effect<typeof LongTaskStatusWithLinks.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all target entities that have a particular relationship to the
* source entity. Note, relationships are one way.
* 
* For example, the following method finds all content that the current user
* has an 'ignore' relationship with:
* `GET /wiki/rest/api/relation/ignore/from/user/current/to/content`
* Note, 'ignore' is an example custom relationship type.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view both the target entity and source entity.
*/
readonly "findTargetFromSource": (relationName: string, sourceType: string, sourceKey: string, targetType: string, options?: typeof FindTargetFromSourceParams.Encoded | undefined) => Effect.Effect<typeof RelationArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Find whether a particular type of relationship exists from a source
* entity to a target entity. Note, relationships are one way.
* 
* For example, you can use this method to find whether the current user has
* selected a particular page as a favorite (i.e. 'save for later'):
* `GET /wiki/rest/api/relation/favourite/from/user/current/to/content/123`
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view both the target entity and source entity.
*/
readonly "getRelationship": (relationName: string, sourceType: string, sourceKey: string, targetType: string, targetKey: string, options?: typeof GetRelationshipParams.Encoded | undefined) => Effect.Effect<typeof Relation.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a relationship between two entities (user, space, content). The
* 'favourite' relationship is supported by default, but you can use this method
* to create any type of relationship between two entities.
* 
* For example, the following method creates a 'sibling' relationship between
* two pieces of content:
* `PUT /wiki/rest/api/relation/sibling/from/content/123/to/content/456`
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "createRelationship": (relationName: string, sourceType: string, sourceKey: string, targetType: string, targetKey: string, options?: typeof CreateRelationshipParams.Encoded | undefined) => Effect.Effect<typeof Relation.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a relationship between two entities (user, space, content).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
* For favourite relationships, the current user can only delete their own
* favourite relationships. A space administrator can delete favourite
* relationships for any user.
*/
readonly "deleteRelationship": (relationName: string, sourceType: string, sourceKey: string, targetType: string, targetKey: string, options?: typeof DeleteRelationshipParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all target entities that have a particular relationship to the
* source entity. Note, relationships are one way.
* 
* For example, the following method finds all users that have a 'collaborator'
* relationship to a piece of content with an ID of '1234':
* `GET /wiki/rest/api/relation/collaborator/to/content/1234/from/user`
* Note, 'collaborator' is an example custom relationship type.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view both the target entity and source entity.
*/
readonly "findSourcesForTarget": (relationName: string, targetType: string, targetKey: string, sourceType: string, options?: typeof FindSourcesForTargetParams.Encoded | undefined) => Effect.Effect<typeof RelationArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Searches for content using the
* [Confluence Query Language (CQL)](https://developer.atlassian.com/cloud/confluence/advanced-searching-using-cql/).
* 
* **Note that CQL input queries submitted through the `/wiki/rest/api/search` endpoint no longer support user-specific fields like `user`, `user.fullname`, `user.accountid`, and `user.userkey`.** 
* See this [deprecation notice](https://developer.atlassian.com/cloud/confluence/deprecation-notice-search-api/) for more details.
* 
* Example initial call:
* ```
* /wiki/rest/api/search?cql=type=page&limit=25
* ```
* 
* Example response:
* ```
* {
*   "results": [
*     { ... },
*     { ... },
*     ...
*     { ... }
*   ],
*   "limit": 25,
*   "size": 25,
*   ...
*   "_links": {
*     "base": "<url>",
*     "context": "<url>",
*     "next": "/rest/api/search?cql=type=page&limit=25&cursor=raNDoMsTRiNg",
*     "self": "<url>"
*   }
* }
* ```
* 
* When additional results are available, returns `next` and `prev` URLs to retrieve them in subsequent calls. The URLs each contain a cursor that points to the appropriate set of results. Use `limit` to specify the number of results returned in each call.
* 
* Example subsequent call (taken from example response):
* ```
* /wiki/rest/api/search?cql=type=page&limit=25&cursor=raNDoMsTRiNg
* ```
* The response to this will have a `prev` URL similar to the `next` in the example response.
* 
* If the expand query parameter is used with the `body.export_view` and/or `body.styled_view` properties, then the query limit parameter will be restricted to a maximum value of 25.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to view the entities. Note, only entities that the user has
* permission to view will be returned.
*/
readonly "searchByCQL": (options: typeof SearchByCQLParams.Encoded) => Effect.Effect<typeof SearchPageResponseSearchResult.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Searches for users using user-specific queries from the
* [Confluence Query Language (CQL)](https://developer.atlassian.com/cloud/confluence/advanced-searching-using-cql/).
* 
* Note that CQL input queries submitted through the `/wiki/rest/api/search/user` endpoint only support user-specific fields like `user`, `user.fullname`, `user.accountid`, and `user.userkey`.
* 
* Note that some user fields may be set to null depending on the user's privacy settings.
* These are: email, profilePicture, displayName, and timeZone.
*/
readonly "searchUser": (options: typeof SearchUserParams.Encoded) => Effect.Effect<typeof SearchPageResponseSearchResult.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the look and feel settings for the site or a single space. This
* includes attributes such as the color scheme, padding, and border radius.
* 
* The look and feel settings for a space can be inherited from the global
* look and feel settings or provided by a theme.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* None
*/
readonly "getLookAndFeelSettings": (options?: typeof GetLookAndFeelSettingsParams.Encoded | undefined) => Effect.Effect<typeof LookAndFeelSettings.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Sets the look and feel settings to the default (global) settings, the
* custom settings, or the current theme's settings for a space.
* The custom and theme settings can only be selected if there is already
* a theme set for a space. Note, the default space settings are inherited
* from the current global settings.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "updateLookAndFeel": (options: typeof LookAndFeelSelection.Encoded) => Effect.Effect<typeof LookAndFeelSelection.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the look and feel settings for the site or for a single space.
* If custom settings exist, they are updated. If no custom settings exist,
* then a set of custom settings is created.
* 
* Note, if a theme is selected for a space, the space look and feel settings
* are provided by the theme and cannot be overridden.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "updateLookAndFeelSettings": (options: { readonly params?: typeof UpdateLookAndFeelSettingsParams.Encoded | undefined; readonly payload: typeof LookAndFeel.Encoded }) => Effect.Effect<typeof LookAndFeelWithLinks.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Resets the custom look and feel settings for the site or a single space.
* This changes the values of the custom settings to be the same as the
* default settings. It does not change which settings (default or custom)
* are selected. Note, the default space settings are inherited from the
* current global settings.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "resetLookAndFeelSettings": (options?: typeof ResetLookAndFeelSettingsParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the system information for the Confluence Cloud tenant. This
* information is used by Atlassian.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getSystemInfo": () => Effect.Effect<typeof SystemInfoEntity.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all themes, not including the default theme.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: None
*/
readonly "getThemes": (options?: typeof GetThemesParams.Encoded | undefined) => Effect.Effect<typeof ThemeArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the globally assigned theme.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: None
*/
readonly "getGlobalTheme": () => Effect.Effect<typeof Theme.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a theme. This includes information about the theme name,
* description, and icon.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: None
*/
readonly "getTheme": (themeKey: string) => Effect.Effect<typeof Theme.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new space. Note, currently you cannot set space labels when
* creating a space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Create Space(s)' global permission.
*/
readonly "createSpace": (options: typeof SpaceCreate.Encoded) => Effect.Effect<typeof Space.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new space that is only visible to the creator. This method is
* the same as the [Create space](#api-space-post) method with permissions
* set to the current user only. Note, currently you cannot set space
* labels when creating a space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Create Space(s)' global permission.
*/
readonly "createPrivateSpace": (options: typeof SpaceCreate.Encoded) => Effect.Effect<typeof Space.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the name, description, or homepage of a space.
* 
* -   For security reasons, permissions cannot be updated via the API and
* must be changed via the user interface instead.
* -   Currently you cannot set space labels when updating a space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "updateSpace": (spaceKey: string, options: typeof SpaceUpdate.Encoded) => Effect.Effect<typeof Space.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Permanently deletes a space without sending it to the trash. Note, the space will be deleted in a long running task.
* Therefore, the space may not be deleted yet when this method has
* returned. Clients should poll the status link that is returned in the
* response until the task completes.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "deleteSpace": (spaceKey: string) => Effect.Effect<typeof LongTask.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds new permission to space.
* 
* If the permission to be added is a group permission, the group can be identified
* by its group name or group id.
* 
* Note: Apps cannot access this REST resource - including when utilizing user impersonation.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "addPermissionToSpace": (spaceKey: string, options: typeof SpacePermissionRequest.Encoded) => Effect.Effect<typeof SpacePermissionV2.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds new custom content permission to space.
* 
* If the permission to be added is a group permission, the group can be identified
* by its group name or group id.
* 
* Note: Only apps can access this REST resource and only make changes to the respective app permissions.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "addCustomContentPermissions": (spaceKey: string, options: typeof SpacePermissionCustomContent.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Removes a space permission. Note that removing Read Space permission for a user or group will remove all
* the space permissions for that user or group.
* 
* Note: Apps cannot access this REST resource - including when utilizing user impersonation.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "removePermission": (spaceKey: string, id: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the settings of a space. Currently only the
* `routeOverrideEnabled` setting can be returned.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space.
*/
readonly "getSpaceSettings": (spaceKey: string) => Effect.Effect<typeof SpaceSettings.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates the settings for a space. Currently only the
* `routeOverrideEnabled` setting can be updated.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "updateSpaceSettings": (spaceKey: string, options: typeof SpaceSettingsUpdate.Encoded) => Effect.Effect<typeof SpaceSettings.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Get content states that are suggested in the space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space.
*/
readonly "getSpaceContentStates": (spaceKey: string) => Effect.Effect<typeof GetSpaceContentStates200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Get object describing whether content states are allowed at all, if custom content states or space content states
* are restricted, and a list of space content states allowed for the space if they are not restricted.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "getContentStateSettings": (spaceKey: string) => Effect.Effect<typeof ContentStateSettings.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all content that has the provided content state in a space.
* 
* If the expand query parameter is used with the `body.export_view` and/or `body.styled_view` properties, then the query limit parameter will be restricted to a maximum value of 25.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space.
*/
readonly "getContentsWithState": (spaceKey: string, options: typeof GetContentsWithStateParams.Encoded) => Effect.Effect<typeof ContentArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the theme selected for a space, if one is set. If no space
* theme is set, this means that the space is inheriting the global look
* and feel settings.
* 
* **[Permissions required](https://confluence.atlassian.com/x/_AozKw)**: View permission for the space.
*/
readonly "getSpaceTheme": (spaceKey: string) => Effect.Effect<typeof Theme.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Sets the theme for a space. Note, if you want to reset the space theme to
* the default Confluence theme, use the 'Reset space theme' method instead
* of this method.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "setSpaceTheme": (spaceKey: string, options: typeof ThemeUpdate.Encoded) => Effect.Effect<typeof Theme.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Resets the space theme. This means that the space will inherit the
* global look and feel settings
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space.
*/
readonly "resetSpaceTheme": (spaceKey: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a list of watchers of a space
*/
readonly "getWatchersForSpace": (spaceKey: string, options?: typeof GetWatchersForSpaceParams.Encoded | undefined) => Effect.Effect<typeof SpaceWatchArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a list of labels associated with a space. Can provide a prefix as well as other filters to
* select different types of labels.
*/
readonly "getLabelsForSpace": (spaceKey: string, options?: typeof GetLabelsForSpaceParams.Encoded | undefined) => Effect.Effect<typeof LabelArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds labels to a piece of content. Does not modify the existing labels.
* 
* Notes:
* 
* - Labels can also be added when creating content ([Create content](#api-content-post)).
* - Labels can be updated when updating content ([Update content](#api-content-id-put)).
* This will delete the existing labels and replace them with the labels in
* the request.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to update the content.
*/
readonly "addLabelsToSpace": (spaceKey: string, options: typeof AddLabelsToSpaceRequest.Encoded) => Effect.Effect<typeof LabelArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Remove label from a space
*/
readonly "deleteLabelFromSpace": (spaceKey: string, options: typeof DeleteLabelFromSpaceParams.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Updates a content template. Note, blueprint templates cannot be updated
* via the REST API.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space to update a space template or 'Confluence Administrator'
* global permission to update a global template.
*/
readonly "updateContentTemplate": (options: typeof ContentTemplateUpdate.Encoded) => Effect.Effect<typeof ContentTemplate.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a new content template. Note, blueprint templates cannot be created via the REST API.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Admin' permission for the space to create a space template or 'Confluence Administrator'
* global permission to create a global template.
*/
readonly "createContentTemplate": (options: typeof ContentTemplateCreate.Encoded) => Effect.Effect<typeof ContentTemplate.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all templates provided by blueprints. Use this method to retrieve
* all global blueprint templates or all blueprint templates in a space.
* 
* Note, all global blueprints are inherited by each space. Space blueprints
* can be customised without affecting the global blueprints.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space to view blueprints for the space and permission
* to access the Confluence site ('Can use' global permission) to view global blueprints.
*/
readonly "getBlueprintTemplates": (options?: typeof GetBlueprintTemplatesParams.Encoded | undefined) => Effect.Effect<typeof BlueprintTemplateArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all content templates. Use this method to retrieve all global
* content templates or all content templates in a space.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space to view space templates and permission to
* access the Confluence site ('Can use' global permission) to view global templates.
*/
readonly "getContentTemplates": (options?: typeof GetContentTemplatesParams.Encoded | undefined) => Effect.Effect<typeof ContentTemplateArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a content template. This includes information about template,
* like the name, the space or blueprint that the template is in, the body
* of the template, and more.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'View' permission for the space to view space templates and permission to
* access the Confluence site ('Can use' global permission) to view global templates.
*/
readonly "getContentTemplate": (contentTemplateId: string, options?: typeof GetContentTemplateParams.Encoded | undefined) => Effect.Effect<typeof ContentTemplate.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a template. This results in different actions depending on the
* type of template:
* 
* - If the template is a content template, it is deleted.
* - If the template is a modified space-level blueprint template, it reverts
* to the template inherited from the global-level blueprint template.
* - If the template is a modified global-level blueprint template, it reverts
* to the default global-level blueprint template.
* 
*  Note, unmodified blueprint templates cannot be deleted.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
*         'Admin' permission for the space to delete a space template or 'Confluence Administrator'
*         global permission to delete a global template.
*/
readonly "removeTemplate": (contentTemplateId: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a user. This includes information about the user, such as the
* display name, account ID, profile picture, and more. The information returned may be
* restricted by the user's profile visibility settings.
* 
* **Note:** to add, edit, or delete users in your organization, see the
* [user management REST API](/cloud/admin/user-management/about/).
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getUser": (options: typeof GetUserParams.Encoded) => Effect.Effect<typeof User.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns information about how anonymous users are represented, like the
* profile picture and display name.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getAnonymousUser": (options?: typeof GetAnonymousUserParams.Encoded | undefined) => Effect.Effect<typeof UserAnonymous.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the currently logged-in user. This includes information about
* the user, like the display name, userKey, account ID, profile picture,
* and more.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getCurrentUser": (options?: typeof GetCurrentUserParams.Encoded | undefined) => Effect.Effect<typeof User.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the groups that a user is a member of.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getGroupMembershipsForUser": (options: typeof GetGroupMembershipsForUserParams.Encoded) => Effect.Effect<typeof GroupArrayWithLinks.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns user details for the ids provided in the request.
* Currently this API returns a maximum of 100 results.
* If more than 100 account ids are passed in, then the first 100 will be returned.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getBulkUserLookup": (options: typeof GetBulkUserLookupParams.Encoded) => Effect.Effect<typeof BulkUserLookupArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns whether a user is watching a piece of content. Choose the user by
* doing one of the following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "getContentWatchStatus": (contentId: string, options?: typeof GetContentWatchStatusParams.Encoded | undefined) => Effect.Effect<typeof UserWatch.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds a user as a watcher to a piece of content. Choose the user by doing
* one of the following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* Note, you must add the `X-Atlassian-Token: no-check` header when making a
* request, as this operation has XSRF protection.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "addContentWatcher": (contentId: string, options?: typeof AddContentWatcherParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Removes a user as a watcher from a piece of content. Choose the user by
* doing one of the following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "removeContentWatcher": (contentId: string, options: typeof RemoveContentWatcherParams.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns whether a user is watching a label. Choose the user by doing one
* of the following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "isWatchingLabel": (labelName: string, options?: typeof IsWatchingLabelParams.Encoded | undefined) => Effect.Effect<typeof UserWatch.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds a user as a watcher to a label. Choose the user by doing one of the
* following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* Note, you must add the `X-Atlassian-Token: no-check` header when making a
* request, as this operation has XSRF protection.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "addLabelWatcher": (labelName: string, options: typeof AddLabelWatcherParams.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Removes a user as a watcher from a label. Choose the user by doing one of
* the following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "removeLabelWatcher": (labelName: string, options?: typeof RemoveLabelWatcherParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns whether a user is watching a space. Choose the user by
* doing one of the following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "isWatchingSpace": (spaceKey: string, options?: typeof IsWatchingSpaceParams.Encoded | undefined) => Effect.Effect<typeof UserWatch.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Adds a user as a watcher to a space. Choose the user by doing one of the
* following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* Note, you must add the `X-Atlassian-Token: no-check` header when making a
* request, as this operation has XSRF protection.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "addSpaceWatcher": (spaceKey: string, options: typeof AddSpaceWatcherParams.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Removes a user as a watcher from a space. Choose the user by doing one of
* the following:
* 
* - Specify a user via a query parameter: Use the `accountId` to identify the user.
* - Do not specify a user: The currently logged-in user will be used.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* 'Confluence Administrator' global permission if specifying a user, otherwise
* permission to access the Confluence site ('Can use' global permission).
*/
readonly "removeSpaceWatch": (spaceKey: string, options?: typeof RemoveSpaceWatchParams.Encoded | undefined) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a user's email address regardless of the users profile visibility settings. For Connect apps, this API is only available to apps approved by
* Atlassian, according to these [guidelines](https://community.developer.atlassian.com/t/guidelines-for-requesting-access-to-email-address/27603).
* For Forge apps, this API only supports access via asApp() requests.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getPrivacyUnsafeUserEmail": (options: typeof GetPrivacyUnsafeUserEmailParams.Encoded) => Effect.Effect<typeof AccountIdEmailRecord.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns a user's email address regardless of the users profile visibility settings. For Connect apps, this API is only available to apps approved by
* Atlassian, according to these [guidelines](https://community.developer.atlassian.com/t/guidelines-for-requesting-access-to-email-address/27603).
* For Forge apps, this API only supports access via asApp() requests.
* 
* Any accounts which are not available will not be included in the result.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getPrivacyUnsafeUserEmailBulk": (options: typeof GetPrivacyUnsafeUserEmailBulkParams.Encoded) => Effect.Effect<typeof AccountIdEmailRecordArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns all modules registered dynamically by the calling app.
* 
* **[Permissions](#permissions) required:** Only Connect apps can make this request.
*/
readonly "getModules": () => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Registers a list of modules. For the list of modules that support dynamic registration, see [Dynamic modules](https://developer.atlassian.com/cloud/confluence/dynamic-modules/).
* 
* **[Permissions](#permissions) required:** Only Connect apps can make this request.
*/
readonly "registerModules": () => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Remove all or a list of modules registered by the calling app.
* 
* **[Permissions](#permissions) required:** Only Connect apps can make this request.
*/
readonly "removeModules": (options: typeof RemoveModulesParams.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Get the total number of views a piece of content has.
*/
readonly "getViews": (contentId: string, options?: typeof GetViewsParams.Encoded | undefined) => Effect.Effect<typeof GetViews200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Get the total number of distinct viewers a piece of content has.
*/
readonly "getViewers": (contentId: string, options?: typeof GetViewersParams.Encoded | undefined) => Effect.Effect<typeof GetViewers200.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the properties for a user as list of property keys. For more information
* about user properties, see [Confluence entity properties](https://developer.atlassian.com/cloud/confluence/confluence-entity-properties/).
* `Note`, these properties stored against a user are on a Confluence site level and not space/content level.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getUserProperties": (userId: string, options?: typeof GetUserPropertiesParams.Encoded | undefined) => Effect.Effect<typeof UserPropertyKeyArray.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Returns the property corresponding to `key` for a user. For more information
* about user properties, see [Confluence entity properties](https://developer.atlassian.com/cloud/confluence/confluence-entity-properties/).
* `Note`, these properties stored against a user are on a Confluence site level and not space/content level.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "getUserProperty": (userId: string, key: string) => Effect.Effect<typeof UserProperty.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Updates a property for the given user. Note, you cannot update the key of a user property, only the value.
* For more information about user properties, see
* [Confluence entity properties](https://developer.atlassian.com/cloud/confluence/confluence-entity-properties/).
* `Note`, these properties stored against a user are on a Confluence site level and not space/content level.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "updateUserProperty": (userId: string, key: string, options: typeof UserPropertyUpdate.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Creates a property for a user. For more information  about user properties, see [Confluence entity properties]
* (https://developer.atlassian.com/cloud/confluence/confluence-entity-properties/).
* `Note`, these properties stored against a user are on a Confluence site level and not space/content level.
* 
* `Note:` the number of properties which could be created per app in a tenant for each user might be
* restricted by fixed system limits.
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "createUserProperty": (userId: string, key: string, options: typeof UserPropertyCreate.Encoded) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
  /**
* Deletes a property for the given user.
* For more information about user properties, see
* [Confluence entity properties](https://developer.atlassian.com/cloud/confluence/confluence-entity-properties/).
* `Note`, these properties stored against a user are on a Confluence site level and not space/content level.
* 
* **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
* Permission to access the Confluence site ('Can use' global permission).
*/
readonly "deleteUserProperty": (userId: string, key: string) => Effect.Effect<void, HttpClientError.HttpClientError | ParseError>
}

export interface ConfluenceV1ClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class ConfluenceV1ClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const ConfluenceV1ClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): ConfluenceV1ClientError<Tag, E> =>
  new ConfluenceV1ClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any
